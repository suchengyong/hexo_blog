{"meta":{"title":"苏成勇个人博客","subtitle":"我只是一个代码搬运工...","description":"前端个人技术博客分享,javascript技术博客,nodejs技术博客,CSS3技术博客,React技术博客,Vue技术博客,git 技术博客","author":"苏成勇","url":"http://yoursite.com"},"pages":[{},{},{},{}],"posts":[{"title":"Vue使用Canvas绘制图片、矩形、线条、文字，下载图片","date":"2020-05-11T02:30:58.000Z","path":"2020/05/11/vue_canvas/","text":"1、 前言1.1 、业务场景图片储存在后台中，根据图片的地址，在vue页面中，查看图片，并根据坐标标注指定区域。由于浏览器的机制，使用window.location.href下载图片时，并不会保存到本地，会在浏览器打开。 2、 实现原理2.1、 绘制画布&lt;el-dialog title=&quot;查看图片&quot; :visible.sync=&quot;dialogJPG&quot; append-to-body&gt; &lt;canvas id=&quot;mycanvas&quot; width=&quot;940&quot; height=&quot;570&quot;&gt;&lt;/canvas&gt; &lt;/el-dialog&gt; 这里为了交互体验，使用了element-ui的弹窗方式。将canvas画布放到了弹窗中。为了突出画布效果可以在css中设置一个边框。 #mycanvas { border: 1px solid rgb(199, 198, 198); } 2.2 绘制图片// imageUrl为后台提供图片地址 doDraw(imageUrl){ // 获取canvas var canvas = document.getElementById(&quot;mycanvas&quot;) // 由于弹窗，确保已获取到 var a = setInterval(() =&gt;{ // 重复获取 canvas = document.getElementById(&quot;mycanvas&quot;) if(!canvas){ return false } else { clearInterval(a) // 可以理解为一个画笔，可画路径、矩形、文字、图像 var context = canvas.getContext(&#39;2d&#39;) var img = new Image() img.src = imageUrl // 加载图片 img.onload = function(){ if(img.complete){ // 根据图像重新设定了canvas的长宽 canvas.setAttribute(&quot;width&quot;,img.width) canvas.setAttribute(&quot;height&quot;,img.height) // 绘制图片 context.drawImage(img,0,0,img.width,img.height) } } } },1) }, context.drawImage()方法的参数介绍，可参照 W3school 2.3 、绘制矩形context.strokeStyle = &quot;red&quot; context.lineWidth = 3; context.strokeRect(x, y, width, height) context 同上面的定义strokeStyle 矩形颜色lineWidth 矩形边框宽度x,y,width,height 矩形位置加长宽 2.4 、绘制线条context.moveTo(x1,y1) context.lineTo(x2,y2) context.strokeStyle = &quot;red&quot; context.lineWidth = 3; context.stroke() (x1,y1) (x2,y2) 线条的起点和终点坐标strokeStyle lineWidth 线条的样式 2.5 、绘制文字context.font = &quot;26px Arial bolder&quot; context.fillStyle = &#39;red&#39; context.fillText(text,x,y) font fillStyle 文字样式text 文字内容x,y 文字显示坐标 2.6 、下载图片// 图片地址和图片名称 downIamge (imgsrc, name) { let image = new Image() image.setAttribute(&#39;crossOrigin&#39;, &#39;anonymous&#39;) image.onload = function () { let canvas = document.createElement(&#39;canvas&#39;) canvas.width = image.width canvas.height = image.height let context = canvas.getContext(&#39;2d&#39;) context.drawImage(image, 0, 0, image.width, image.height) let url = canvas.toDataURL(&#39;image/jpg&#39;) let a = document.createElement(&#39;a&#39;) let event = new MouseEvent(&#39;click&#39;) a.download = name a.href = url a.dispatchEvent(event) } image.src = imgsrc },","content":"<h2 id=\"1、-前言\"><a href=\"#1、-前言\" class=\"headerlink\" title=\"1、 前言\"></a>1、 前言</h2><h4 id=\"1-1-、业务场景\"><a href=\"#1-1-、业务场景\" class=\"headerlink\" title=\"1.1 、业务场景\"></a>1.1 、业务场景</h4><p>图片储存在后台中，根据图片的地址，在vue页面中，查看图片，并根据坐标标注指定区域。<br>由于浏览器的机制，使用window.location.href下载图片时，并不会保存到本地，会在浏览器打开。</p>\n<h3 id=\"2、-实现原理\"><a href=\"#2、-实现原理\" class=\"headerlink\" title=\"2、 实现原理\"></a>2、 实现原理</h3><h4 id=\"2-1、-绘制画布\"><a href=\"#2-1、-绘制画布\" class=\"headerlink\" title=\"2.1、 绘制画布\"></a>2.1、 绘制画布</h4><pre><code>&lt;el-dialog\n    title=&quot;查看图片&quot;\n    :visible.sync=&quot;dialogJPG&quot;\n    append-to-body&gt;\n    &lt;canvas id=&quot;mycanvas&quot; width=&quot;940&quot; height=&quot;570&quot;&gt;&lt;/canvas&gt;\n&lt;/el-dialog&gt;\n</code></pre><p>这里为了交互体验，使用了element-ui的弹窗方式。将canvas画布放到了弹窗中。<br>为了突出画布效果可以在css中设置一个边框。</p>\n<pre><code>#mycanvas {\n    border: 1px solid rgb(199, 198, 198);\n}\n</code></pre><h4 id=\"2-2-绘制图片\"><a href=\"#2-2-绘制图片\" class=\"headerlink\" title=\"2.2 绘制图片\"></a>2.2 绘制图片</h4><pre><code>//  imageUrl为后台提供图片地址\ndoDraw(imageUrl){\n    //  获取canvas\n    var canvas = document.getElementById(&quot;mycanvas&quot;)\n    //  由于弹窗，确保已获取到\n    var a = setInterval(() =&gt;{\n        //  重复获取\n        canvas = document.getElementById(&quot;mycanvas&quot;)\n        if(!canvas){\n          return false\n        } else {\n            clearInterval(a)\n            //  可以理解为一个画笔，可画路径、矩形、文字、图像\n            var context = canvas.getContext(&#39;2d&#39;)\n            var img = new Image()\n            img.src = imageUrl\n            //  加载图片\n            img.onload = function(){\n                if(img.complete){\n                    //  根据图像重新设定了canvas的长宽\n                    canvas.setAttribute(&quot;width&quot;,img.width)\n                    canvas.setAttribute(&quot;height&quot;,img.height)\n                    //  绘制图片\n                    context.drawImage(img,0,0,img.width,img.height)\n                }\n            }\n        }\n    },1)\n},\n</code></pre><p>context.drawImage()方法的参数介绍，可参照 W3school</p>\n<h4 id=\"2-3-、绘制矩形\"><a href=\"#2-3-、绘制矩形\" class=\"headerlink\" title=\"2.3 、绘制矩形\"></a>2.3 、绘制矩形</h4><pre><code>context.strokeStyle = &quot;red&quot;\ncontext.lineWidth = 3;\ncontext.strokeRect(x, y, width, height)\n</code></pre><p>context 同上面的定义<br>strokeStyle 矩形颜色<br>lineWidth 矩形边框宽度<br>x,y,width,height 矩形位置加长宽</p>\n<h4 id=\"2-4-、绘制线条\"><a href=\"#2-4-、绘制线条\" class=\"headerlink\" title=\"2.4 、绘制线条\"></a>2.4 、绘制线条</h4><pre><code>context.moveTo(x1,y1)\ncontext.lineTo(x2,y2)\ncontext.strokeStyle = &quot;red&quot;\ncontext.lineWidth = 3;\ncontext.stroke()\n</code></pre><p>(x1,y1) (x2,y2) 线条的起点和终点坐标<br>strokeStyle lineWidth 线条的样式</p>\n<h4 id=\"2-5-、绘制文字\"><a href=\"#2-5-、绘制文字\" class=\"headerlink\" title=\"2.5 、绘制文字\"></a>2.5 、绘制文字</h4><pre><code>context.font = &quot;26px Arial bolder&quot;\ncontext.fillStyle = &#39;red&#39;\ncontext.fillText(text,x,y)\n</code></pre><p>font fillStyle 文字样式<br>text 文字内容<br>x,y 文字显示坐标</p>\n<h4 id=\"2-6-、下载图片\"><a href=\"#2-6-、下载图片\" class=\"headerlink\" title=\"2.6 、下载图片\"></a>2.6 、下载图片</h4><pre><code>// 图片地址和图片名称\ndownIamge (imgsrc, name) {\n    let image = new Image()\n    image.setAttribute(&#39;crossOrigin&#39;, &#39;anonymous&#39;)\n    image.onload = function () {\n        let canvas = document.createElement(&#39;canvas&#39;)\n        canvas.width = image.width\n        canvas.height = image.height\n        let context = canvas.getContext(&#39;2d&#39;)\n        context.drawImage(image, 0, 0, image.width, image.height)\n        let url = canvas.toDataURL(&#39;image/jpg&#39;)\n        let a = document.createElement(&#39;a&#39;)\n        let event = new MouseEvent(&#39;click&#39;)\n        a.download = name\n        a.href = url\n        a.dispatchEvent(event)\n    }\n    image.src = imgsrc\n},\n</code></pre>","updated":"2020-05-11T03:04:22.523Z","comments":true,"link":"","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://yoursite.com/categories/前端开发/"}],"tags":[{"name":"vue,canvas","slug":"vue-canvas","permalink":"http://yoursite.com/tags/vue-canvas/"}]},{"title":"Vue + Koa从零打造一个H5页面可视化编辑器——Quark-h5","date":"2020-05-11T02:30:58.000Z","path":"2020/05/11/quark_h5/","text":"前言想必你一定使用过易企秀或百度H5等微场景生成工具制作过炫酷的h5页面，除了感叹其神奇之处有没有想过其实现方式呢？本文从零开始实现一个H5编辑器项目完整设计思路和主要实现步骤，并开源前后端代码。有需要的小伙伴可以按照该教程从零实现自己的H5编辑器。（实现起来并不复杂，该教程只是提供思路，并非最佳实践） 原文章地址：https://mp.weixin.qq.com/s/SG9ZYIivbpbXOOTlal9Akw Github: https://github.com/huangwei9527/quark-h5 演示地址：http://47.104.247.183:4000/ 技术栈前端：vue: 模块化开发少不了angular，react，vue三选一，这里选择了vue。vuex: 状态管理sass: css预编译器。element-ui：不造轮子，有现成的优秀的vue组件库当然要用起来。没有的自己再封装一些就可以了。loadsh：工具类 服务端：koa：后端语言采用nodejs，koa文档和学习资料也比较多，express原班人马打造，这个正合适。mongodb：一个基于分布式文件存储的数据库，比较灵活。 工程搭建基于vue-cli3环境搭建 如何规划好我们项目的目录结构？首先我们需要有一个目录作为前端项目，一个目录作为后端项目。所以我们要对vue-cli 生成的项目结构做一下改造：··· · |-- client// 原 src 目录，改成 client 用作前端项目目录 |-- server// 新增 server 用于服务端项目目录 |-- engine-template// 新增 engine-template 用于页面模板库目录 |-- docs// 新增 docs 预留编写项目文档目录 · ··· 这样的话 我们需要再把我们webpack配置文件稍作一下调整，首先是把原先的编译指向src的目录改成client，其次为了 npm run build 能正常编译 client 我们也需要为 babel-loader 再增加一个编译目录： 根目录新增vue.config.js,目的是为了改造项目入口,改为:client/main.jsmodule.exports = { pages: { index: { entry: &quot;client/main.js&quot; } } } babel-loader能正常编译 client, engine-template目录， 在vue.config.js新增如下配置 // 扩展 webpack 配置 chainWebpack: config =&gt; { config.module .rule(&#39;js&#39;) .include.add(/engine-template/).end() .include.add(/client/).end() .use(&#39;babel&#39;) .loader(&#39;babel-loader&#39;) .tap(options =&gt; { // 修改它的选项... return options }) } 这样我们搭建起来一个简易的项目目录结构。 工程目录结构|-- client--------前端项目界面代码 |--common--------前端界面对应静态资源 |--components--------组件 |--config--------配置文件 |--eventBus--------eventBus |--filter--------过滤器 |--mixins--------混入 |--pages--------页面 |--router--------路由配置 |--store--------vuex状态管理 |--service--------axios封装 |--App.vue--------App |--main.js--------入口文件 |--permission.js--------权限控制 |-- server--------服务器端项目代码 |--confog--------数据库链接相关 |--middleware--------中间件 |--models--------Schema和Model |--routes--------路由 |--views--------ejs页面模板 |--public--------静态资源 |--utils--------工具方法 |--app.js--------服务端入口 |-- common--------前后端公用代码模块（如加解密） |-- engine-template--------页面模板引擎，使用webpack打包成js提供页面引用 |-- docs--------预留编写项目文档目录 |-- config.json--------配置文件 前端编辑器实现编辑器的实现思路是：编辑器生成页面JSON数据，服务端负责存取JSON数据，渲染时从服务端取数据JSON交给前端模板处理。 数据结构确认了实现逻辑，数据结构也是非常重要的，把一个页面定义成一个JSON数据，数据结构大致是这样的： 页面工程数据接口 { title: &#39;&#39;, // 标题 description: &#39;&#39;, //描述 coverImage: &#39;&#39;, // 封面 auther: &#39;&#39;, // 作者 script: &#39;&#39;, // 页面插入脚本 width: 375, // 高 height: 644, // 宽 pages: [], // 多页页面 shareConfig: {}, // 微信分享配置 pageMode: 0, // 渲染模式，用于扩展多种模式渲染，翻页h5/长页/PC页面等等 } 多页页面pages其中一页数据结构：{ name: &#39;&#39;, elements: [], // 页面元素 commonStyle: { backgroundColor: &#39;&#39;, backgroundImage: &#39;&#39;, backgroundSize: &#39;cover&#39; }, config: {} } 元素数据结构：{ elName: &#39;&#39;, // 组件名 animations: [], // 图层的动画,可以支持多个动画 commonStyle: {}, // 公共样式，默认样式 events: [], // 事件配置数据，每个图层可以添加多个事件 propsValue: {}, // 属性参数 value: &#39;&#39;, // 绑定值 valueType: &#39;String&#39;, // 值类型 isForm: false// 是否是表单控件，用于表单提交时获取表单数据 } 核心代码编辑器核心代码，基于 Vue 动态组件特性实现： &lt;div v-for=&quot;item in activePage.element&quot; :key=&quot;item.uuid&quot; :style=&quot;getCommonStyle(item.commonStyle)&quot; :active=&quot;item.uuid === activeElementUUID&quot;&gt; &lt;component :is=&quot;item.elName&quot; v-bind=&quot;item&quot; /&gt; &lt;/div&gt; 画板元素渲染编辑画板只需要循环遍历pages[i].elements数组，将里面的元素组件JSON数据取出，通过动态组件渲染出各个组件，支持拖拽改变位置尺寸. 元素组件管理在client目录新建plugins来管理组件库。也可以将该组件库发到npm上工程中通过npm管理 组件库编写组件，考虑的是组件库，所以我们竟可能让我们的组件支持全局引入和按需引入，如果全局引入，那么所有的组件需要要注册到Vue component 上，并导出： client/plugins下新建index.js入口文件/** * 组件库入口 * */ import Text from&#39;./text&#39; // 所有组件列表 const components = [ Text ] // 定义 install 方法，接收 Vue 作为参数 const install = function (Vue) { // 判断是否安装，安装过就不继续往下执行 if (install.installed) return install.installed = true // 遍历注册所有组件 components.map(component =&gt; Vue.component(component.name, component)) } // 检测到 Vue 才执行，毕竟我们是基于 Vue 的 if (typeofwindow !== &#39;undefined&#39; &amp;&amp; window.Vue) { install(window.Vue) } exportdefault { install, // 所有组件，必须具有 install，才能使用 Vue.use() Text } 组件开发示例：text文本组件 client/plugins下新建text组件目录 |-- text --------text组件 |--src --------资源 |--index.vue --------组件 |--index.js --------入口 text/index.js // 为组件提供 install 方法，供组件对外按需引入 import Component from&#39;./src/index&#39; Component.install = Vue =&gt; { Vue.component(Component.name, Component) } exportdefault Component text/src/index.vue &lt;!--text.vue--&gt; &lt;template&gt; &lt;div class=&quot;qk-text&quot;&gt; {{text}} &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: &#39;QkText&#39;, // 这个名字很重要，它就是未来的标签名&lt;qk-text&gt;&lt;/qk-text&gt; props: { text: { type: String, default: &#39;这是一段文字&#39; } } } &lt;/script&gt; &lt;style lang=&quot;scss&quot; scoped&gt; &lt;/style&gt; 编辑器里使用组件库： // 引入组件库 import QKUI from&#39;client/plugins/index&#39; // 注册组件库 Vue.use(QKUI) // 使用： &lt;qk-text text=&quot;这是一段文字&quot;&gt;&lt;/qk-text&gt; 配置文件Quark-h5编辑器左侧选择组件区域可以通过一个配置文件定义可选组件新建一个ele-config.js配置文件： exportdefault [ { title: &#39;基础组件&#39;, components: [ { elName: &#39;qk-text&#39;, // 组件名，与组件库名称一致 title: &#39;文字&#39;, icon: &#39;iconfont iconwenben&#39;, // 给每个组件配置默认显示样式 defaultStyle: { height: 40 } } ] }, { title: &#39;表单组件&#39;, components: [] }, { title: &#39;功能组件&#39;, components: [] }, { title: &#39;业务组件&#39;, components: [] } ] 公共方法中提供一个function 通过组件名和默认样式获取元素组件JSON，getElementConfigJson(elName, defaultStyle)方法 封装一个动画执行方法 /** * 动画方法， 将动画css加入到元素上，返回promise提供执行后续操作（将动画重置） * @param $el 当前被执行动画的元素 * @param animationList 动画列表 * @param isDebugger 动画列表 * @returns {Promise&lt;void&gt;} */ exportdefaultasyncfunction runAnimation($el, animationList = [], isDebug , callback){ let playFn = function (animation) { returnnewPromise(resolve =&gt; { $el.style.animationName = animation.type $el.style.animationDuration = `${animation.duration}s` // 如果是循环播放就将循环次数置为1，这样有效避免编辑时因为预览循环播放组件播放动画无法触发animationend来暂停组件动画 $el.style.animationIterationCount = animation.infinite ? (isDebug ? 1 : &#39;infinite&#39;) : animation.interationCount $el.style.animationDelay = `${animation.delay}s` $el.style.animationFillMode = &#39;both&#39;let resolveFn = function(){ $el.removeEventListener(&#39;animationend&#39;, resolveFn, false); $el.addEventListener(&#39;animationcancel&#39;, resolveFn, false); resolve() } $el.addEventListener(&#39;animationend&#39;, resolveFn, false) $el.addEventListener(&#39;animationcancel&#39;, resolveFn, false); }) } for(let i = 0, len = animationList.length; i &lt; len; i++){ await playFn(animationList[i]) } if(callback){ callback() } } animationIterationCount 如果是编辑模式的化动画只执行一次，不然无法监听到动画结束animationend事件 执行动画前先将元素样式style缓存起来，当动画执行完再将原样式赋值给元素 let cssText = this.$el.style.cssText; runAnimations(this.$el, animations, true, () =&gt; { this.$el.style.cssText = cssText }) psd设计图导入生成h5页面将psd每个设计图中的每个图层导出成图片保存到静态资源服务器中， 服务端安装psd依赖 cnpm install psd --save 加入psd.js依赖，并且提供接口来处理数据var PSD = require(&#39;psd&#39;); router.post(&#39;/psdPpload&#39;,async ctx=&gt;{ const file = ctx.request.files.file; // 获取上传文件 let psd = await PSD.open(file.path) var timeStr = + newDate(); let descendantsList = psd.tree().descendants(); descendantsList.reverse(); let psdSourceList = [] let currentPathDir = `public/upload_static/psd_image/${timeStr}` for (var i = 0; i &lt; descendantsList.length; i++){ if (descendantsList[i].isGroup()) continue; if (!descendantsList[i].visible) continue; try{ await descendantsList[i].saveAsPng(path.join(ctx.state.SERVER_PATH, currentPathDir + `/${i}.png`)) psdSourceList.push({ ...descendantsList[i].export(), type: &#39;picture&#39;, imageSrc: ctx.state.BASE_URL + `/upload_static/psd_image/${timeStr}/${i}.png`, }) }catch (e) { // 转换不出来的图层先忽略 continue; } } ctx.body = { elements: psdSourceList, document: psd.tree().export().document }; }) 最后把获取的数据转义并返回给前端，前端获取到数据后使用系统统一方法，遍历添加统一图片组件 后端服务初始化项目工程目录上文已给出，也可以使用 koa-generator 脚手架工具生成 ejs-template 模板引擎配置app.js //配置ejs-template 模板引擎 render(app, { root: path.join(__dirname, &#39;views&#39;), layout: false, viewExt: &#39;html&#39;, cache: false, debug: false }); koa-static静态资源服务因为html2canvas需要图片允许跨域，所以在静态资源服务中所有资源请求设置’Access-Control-Allow-Origin’:’*’ app.js //配置静态web app.use(koaStatic(__dirname + &#39;/public&#39;), { gzip: true, setHeaders: function(res){ res.header( &#39;Access-Control-Allow-Origin&#39;, &#39;*&#39;) }}); 修改路由的注册方式，通过遍历routes文件夹读取文件app.js const fs = require(&#39;fs&#39;) fs.readdirSync(&#39;./routes&#39;).forEach(route=&gt; { let api = require(`./routes/${route}`) app.use(api.routes(), api.allowedMethods()) }) 添加jwt认证，同时过滤不需要认证的路由，如获取tokenapp.js const jwt = require(&#39;koa-jwt&#39;) app.use(jwt({ secret: &#39;yourstr&#39; }).unless({ path: [ /^\\/$/, /\\/token/, /\\/wechat/, { url: /\\/papers/, methods: [&#39;GET&#39;] } ] })); 中间件实现统一接口返回数据格式，全局错误捕获并响应middleware/formatresponse.js module.exports = async (ctx, next) =&gt; { await next().then(() =&gt; { if (ctx.status === 200) { ctx.body = { message: &#39;成功&#39;, code: 200, body: ctx.body, status: true } } elseif (ctx.status === 201) { // 201处理模板引擎渲染 } else { ctx.body = { message: ctx.body || &#39;接口异常，请重试&#39;, code: ctx.status, body: &#39;接口请求失败&#39;, status: false } } }).catch((err) =&gt; { if (err.status === 401) { ctx.status = 401; ctx.body = { code: 401, status: false, message: &#39;登录过期，请重新登录&#39; } } else { throw err } }) } koa2-cors跨域处理当接口发布到线上，前端通过ajax请求时，会报跨域的错误。koa2使用koa2-cors这个库非常方便的实现了跨域配置，使用起来也很简单 const cors = require(&#39;koa2-cors&#39;); app.use(cors()); 连接数据库我们使用mongodb数据库，在koa2中使用mongoose这个库来管理整个数据库的操作。 创建配置文件根目录下新建config文件夹，新建mongo.js //config/mongo.js const mongoose = require(&#39;mongoose&#39;).set(&#39;debug&#39;, true); const options = { autoReconnect: true } // username 数据库用户名 // password 数据库密码 // localhost 数据库ip // dbname 数据库名称 const url = &#39;mongodb://username:password@localhost:27017/dbname&#39; module.exports = { connect: ()=&gt; { mongoose.connect(url,options) let db = mongoose.connection db.on(&#39;error&#39;, console.error.bind(console, &#39;连接错误:&#39;)); db.once(&#39;open&#39;, ()=&gt; { console.log(&#39;mongodb connect suucess&#39;); }) } } 把mongodb配置信息放到config.json中统一管理 然后在app.js中引入 const mongoConf = require(&#39;./config/mongo&#39;); mongoConf.connect(); 启动运行启动前端 npm run dev-client 启动服务端 npm run dev-server 注意：如果没有生成过引擎模板js文件的，需要先编辑引擎模板，否则预览页面加载页面引擎.js 404报错 编译engine.js模板引擎 npm run lib:h5-swiper","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>想必你一定使用过易企秀或百度H5等微场景生成工具制作过炫酷的h5页面，除了感叹其神奇之处有没有想过其实现方式呢？本文从零开始实现一个H5编辑器项目完整设计思路和主要实现步骤，并开源前后端代码。有需要的小伙伴可以按照该教程从零实现自己的H5编辑器。（实现起来并不复杂，该教程只是提供思路，并非最佳实践）</p>\n<p>原文章地址：<a href=\"https://mp.weixin.qq.com/s/SG9ZYIivbpbXOOTlal9Akw\">https://mp.weixin.qq.com/s/SG9ZYIivbpbXOOTlal9Akw</a></p>\n<p>Github: <a href=\"https://github.com/huangwei9527/quark-h5\">https://github.com/huangwei9527/quark-h5</a></p>\n<p>演示地址：<a href=\"http://47.104.247.183:4000/\">http://47.104.247.183:4000/</a></p>\n<h3 id=\"技术栈\"><a href=\"#技术栈\" class=\"headerlink\" title=\"技术栈\"></a>技术栈</h3><p>前端：vue: 模块化开发少不了angular，react，vue三选一，这里选择了vue。vuex: 状态管理sass: css预编译器。element-ui：不造轮子，有现成的优秀的vue组件库当然要用起来。没有的自己再封装一些就可以了。loadsh：工具类</p>\n<p>服务端：koa：后端语言采用nodejs，koa文档和学习资料也比较多，express原班人马打造，这个正合适。mongodb：一个基于分布式文件存储的数据库，比较灵活。</p>\n<h3 id=\"工程搭建\"><a href=\"#工程搭建\" class=\"headerlink\" title=\"工程搭建\"></a>工程搭建</h3><h4 id=\"基于vue-cli3环境搭建\"><a href=\"#基于vue-cli3环境搭建\" class=\"headerlink\" title=\"基于vue-cli3环境搭建\"></a>基于vue-cli3环境搭建</h4><ul>\n<li>如何规划好我们项目的目录结构？首先我们需要有一个目录作为前端项目，一个目录作为后端项目。所以我们要对vue-cli 生成的项目结构做一下改造：<pre><code>···\n·\n|-- client// 原 src 目录，改成 client 用作前端项目目录\n|-- server// 新增 server 用于服务端项目目录\n|-- engine-template// 新增 engine-template 用于页面模板库目录\n|-- docs// 新增 docs 预留编写项目文档目录\n·\n···\n</code></pre></li>\n<li>这样的话 我们需要再把我们webpack配置文件稍作一下调整，首先是把原先的编译指向src的目录改成client，其次为了 npm run build 能正常编译 client 我们也需要为 babel-loader 再增加一个编译目录：</li>\n</ul>\n<ul>\n<li>根目录新增vue.config.js,目的是为了改造项目入口,改为:client/main.js<pre><code>module.exports = {\npages: {\n  index: {\n    entry: &quot;client/main.js&quot;\n  }\n}\n}\n</code></pre></li>\n<li>babel-loader能正常编译 client, engine-template目录， 在vue.config.js新增如下配置</li>\n</ul>\n<pre><code>// 扩展 webpack 配置\nchainWebpack: config =&gt; {\n    config.module\n    .rule(&#39;js&#39;)\n    .include.add(/engine-template/).end()\n    .include.add(/client/).end()\n    .use(&#39;babel&#39;)\n    .loader(&#39;babel-loader&#39;)\n    .tap(options =&gt; {\n    // 修改它的选项...\n    return options\n    })\n}\n</code></pre><p>这样我们搭建起来一个简易的项目目录结构。</p>\n<h3 id=\"工程目录结构\"><a href=\"#工程目录结构\" class=\"headerlink\" title=\"工程目录结构\"></a>工程目录结构</h3><pre><code>|-- client--------前端项目界面代码\n        |--common--------前端界面对应静态资源\n        |--components--------组件\n        |--config--------配置文件\n        |--eventBus--------eventBus\n        |--filter--------过滤器\n        |--mixins--------混入\n        |--pages--------页面\n        |--router--------路由配置\n        |--store--------vuex状态管理\n        |--service--------axios封装\n        |--App.vue--------App\n        |--main.js--------入口文件\n        |--permission.js--------权限控制\n|-- server--------服务器端项目代码\n        |--confog--------数据库链接相关\n        |--middleware--------中间件\n        |--models--------Schema和Model\n        |--routes--------路由\n        |--views--------ejs页面模板\n        |--public--------静态资源\n        |--utils--------工具方法\n        |--app.js--------服务端入口\n|-- common--------前后端公用代码模块（如加解密）\n|-- engine-template--------页面模板引擎，使用webpack打包成js提供页面引用\n|-- docs--------预留编写项目文档目录\n|-- config.json--------配置文件\n</code></pre><h3 id=\"前端编辑器实现\"><a href=\"#前端编辑器实现\" class=\"headerlink\" title=\"前端编辑器实现\"></a>前端编辑器实现</h3><p>编辑器的实现思路是：编辑器生成页面JSON数据，服务端负责存取JSON数据，渲染时从服务端取数据JSON交给前端模板处理。</p>\n<h3 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h3><p>确认了实现逻辑，数据结构也是非常重要的，把一个页面定义成一个JSON数据，数据结构大致是这样的：</p>\n<h5 id=\"页面工程数据接口\"><a href=\"#页面工程数据接口\" class=\"headerlink\" title=\"页面工程数据接口\"></a>页面工程数据接口</h5><pre><code> {\n    title: &#39;&#39;, // 标题\n    description: &#39;&#39;, //描述\n    coverImage: &#39;&#39;, // 封面\n    auther: &#39;&#39;, // 作者\n    script: &#39;&#39;, // 页面插入脚本\n    width: 375, // 高\n    height: 644, // 宽\n    pages: [], // 多页页面\n    shareConfig: {}, // 微信分享配置\n    pageMode: 0, // 渲染模式，用于扩展多种模式渲染，翻页h5/长页/PC页面等等\n}\n</code></pre><h4 id=\"多页页面pages其中一页数据结构：\"><a href=\"#多页页面pages其中一页数据结构：\" class=\"headerlink\" title=\"多页页面pages其中一页数据结构：\"></a>多页页面pages其中一页数据结构：</h4><pre><code>{\n    name: &#39;&#39;,\n    elements: [], // 页面元素\n    commonStyle: {\n    backgroundColor: &#39;&#39;,\n    backgroundImage: &#39;&#39;,\n    backgroundSize: &#39;cover&#39;\n    },\n    config: {}\n}\n</code></pre><h4 id=\"元素数据结构：\"><a href=\"#元素数据结构：\" class=\"headerlink\" title=\"元素数据结构：\"></a>元素数据结构：</h4><pre><code>{\n    elName: &#39;&#39;, // 组件名\n    animations: [], // 图层的动画,可以支持多个动画\n    commonStyle: {}, // 公共样式，默认样式\n    events: [], // 事件配置数据，每个图层可以添加多个事件\n    propsValue: {}, // 属性参数\n    value: &#39;&#39;, // 绑定值\n    valueType: &#39;String&#39;, // 值类型\n    isForm: false// 是否是表单控件，用于表单提交时获取表单数据\n}\n</code></pre><h3 id=\"核心代码\"><a href=\"#核心代码\" class=\"headerlink\" title=\"核心代码\"></a>核心代码</h3><p>编辑器核心代码，基于 Vue 动态组件特性实现：</p>\n<pre><code>&lt;div \n   v-for=&quot;item in activePage.element&quot;\n   :key=&quot;item.uuid&quot;\n   :style=&quot;getCommonStyle(item.commonStyle)&quot;\n   :active=&quot;item.uuid === activeElementUUID&quot;&gt;\n   &lt;component :is=&quot;item.elName&quot; v-bind=&quot;item&quot; /&gt;\n&lt;/div&gt;\n</code></pre><h3 id=\"画板元素渲染\"><a href=\"#画板元素渲染\" class=\"headerlink\" title=\"画板元素渲染\"></a>画板元素渲染</h3><p>编辑画板只需要循环遍历pages[i].elements数组，将里面的元素组件JSON数据取出，通过动态组件渲染出各个组件，支持拖拽改变位置尺寸.</p>\n<h3 id=\"元素组件管理\"><a href=\"#元素组件管理\" class=\"headerlink\" title=\"元素组件管理\"></a>元素组件管理</h3><p>在client目录新建plugins来管理组件库。也可以将该组件库发到npm上工程中通过npm管理</p>\n<h3 id=\"组件库\"><a href=\"#组件库\" class=\"headerlink\" title=\"组件库\"></a>组件库</h3><p>编写组件，考虑的是组件库，所以我们竟可能让我们的组件支持全局引入和按需引入，如果全局引入，那么所有的组件需要要注册到Vue component 上，并导出：</p>\n<h4 id=\"client-plugins下新建index-js入口文件\"><a href=\"#client-plugins下新建index-js入口文件\" class=\"headerlink\" title=\"client/plugins下新建index.js入口文件\"></a>client/plugins下新建index.js入口文件</h4><pre><code>/**\n * 组件库入口\n * */\n    import Text from&#39;./text&#39;\n    // 所有组件列表\n    const components = [\n        Text\n    ]\n    // 定义 install 方法，接收 Vue 作为参数\n    const install = function (Vue) {\n    // 判断是否安装，安装过就不继续往下执行\n    if (install.installed) return\n        install.installed = true\n        // 遍历注册所有组件\n        components.map(component =&gt; Vue.component(component.name, component))\n    }\n\n    // 检测到 Vue 才执行，毕竟我们是基于 Vue 的\n        if (typeofwindow !== &#39;undefined&#39; &amp;&amp; window.Vue) {\n        install(window.Vue)\n    }\n\n    exportdefault {\n        install,\n        // 所有组件，必须具有 install，才能使用     Vue.use()\n        Text\n    }\n</code></pre><h3 id=\"组件开发\"><a href=\"#组件开发\" class=\"headerlink\" title=\"组件开发\"></a>组件开发</h3><p>示例：text文本组件</p>\n<p>client/plugins下新建text组件目录</p>\n<pre><code> |-- text                --------text组件\n        |--src              --------资源\n        |--index.vue    --------组件\n        |--index.js         --------入口\n</code></pre><p>text/index.js</p>\n<pre><code>// 为组件提供 install 方法，供组件对外按需引入\n    import Component from&#39;./src/index&#39;\n    Component.install = Vue =&gt; {\n    Vue.component(Component.name, Component)\n    }\n    exportdefault Component\n</code></pre><p>text/src/index.vue</p>\n<pre><code>    &lt;!--text.vue--&gt;\n    &lt;template&gt;\n      &lt;div class=&quot;qk-text&quot;&gt;\n        {{text}}\n      &lt;/div&gt;\n    &lt;/template&gt;\n\n    &lt;script&gt;\n    export default {\n    name: &#39;QkText&#39;, // 这个名字很重要，它就是未来的标签名&lt;qk-text&gt;&lt;/qk-text&gt;\n    props: {\n    text: {\n    type: String,\n    default: &#39;这是一段文字&#39;\n          }\n    }\n    }\n    &lt;/script&gt;\n\n    &lt;style lang=&quot;scss&quot; scoped&gt;\n    &lt;/style&gt;\n</code></pre><h4 id=\"编辑器里使用组件库：\"><a href=\"#编辑器里使用组件库：\" class=\"headerlink\" title=\"编辑器里使用组件库：\"></a>编辑器里使用组件库：</h4><pre><code>    // 引入组件库\n    import QKUI from&#39;client/plugins/index&#39;\n    // 注册组件库\n    Vue.use(QKUI)\n\n    // 使用：\n    &lt;qk-text text=&quot;这是一段文字&quot;&gt;&lt;/qk-text&gt;\n</code></pre><h4 id=\"配置文件\"><a href=\"#配置文件\" class=\"headerlink\" title=\"配置文件\"></a>配置文件</h4><p>Quark-h5编辑器左侧选择组件区域可以通过一个配置文件定义可选组件新建一个ele-config.js配置文件：</p>\n<pre><code>exportdefault [\n    {\n    title: &#39;基础组件&#39;,\n    components: [\n    {\n    elName: &#39;qk-text&#39;, // 组件名，与组件库名称一致\n    title: &#39;文字&#39;,\n    icon: &#39;iconfont iconwenben&#39;,\n    // 给每个组件配置默认显示样式\n    defaultStyle: {\n    height: 40\n    }\n    }\n    ]\n    },\n    {\n    title: &#39;表单组件&#39;,\n    components: []\n    },\n    {\n    title: &#39;功能组件&#39;,\n    components: []\n    },\n    {\n    title: &#39;业务组件&#39;,\n    components: []\n    }\n    ]\n</code></pre><p>公共方法中提供一个function 通过组件名和默认样式获取元素组件JSON，getElementConfigJson(elName, defaultStyle)方法</p>\n<h3 id=\"封装一个动画执行方法\"><a href=\"#封装一个动画执行方法\" class=\"headerlink\" title=\"封装一个动画执行方法\"></a>封装一个动画执行方法</h3><pre><code>    /**\n     * 动画方法， 将动画css加入到元素上，返回promise提供执行后续操作（将动画重置）\n     * @param $el 当前被执行动画的元素\n     * @param animationList 动画列表\n     * @param isDebugger 动画列表\n     * @returns {Promise&lt;void&gt;}\n     */\n    exportdefaultasyncfunction runAnimation($el, animationList = [], isDebug , callback){\n    let playFn = function (animation) {\n    returnnewPromise(resolve =&gt; {\n    $el.style.animationName =  animation.type\n    $el.style.animationDuration =  `${animation.duration}s`\n    // 如果是循环播放就将循环次数置为1，这样有效避免编辑时因为预览循环播放组件播放动画无法触发animationend来暂停组件动画\n    $el.style.animationIterationCount =  animation.infinite ? (isDebug ? 1 : &#39;infinite&#39;) : animation.interationCount\n    $el.style.animationDelay =  `${animation.delay}s`\n    $el.style.animationFillMode =  &#39;both&#39;let resolveFn = function(){\n    $el.removeEventListener(&#39;animationend&#39;, resolveFn, false);\n    $el.addEventListener(&#39;animationcancel&#39;, resolveFn, false);\n    resolve()\n    }\n    $el.addEventListener(&#39;animationend&#39;, resolveFn, false)\n    $el.addEventListener(&#39;animationcancel&#39;, resolveFn, false);\n    })\n    }\n    for(let i = 0, len = animationList.length; i &lt; len; i++){\n    await playFn(animationList[i])\n    }\n    if(callback){\n    callback()\n    }\n    }\n</code></pre><p>animationIterationCount 如果是编辑模式的化动画只执行一次，不然无法监听到动画结束animationend事件</p>\n<p>执行动画前先将元素样式style缓存起来，当动画执行完再将原样式赋值给元素</p>\n<pre><code>   let cssText = this.$el.style.cssText;\n    runAnimations(this.$el, animations, true, () =&gt; {\n       this.$el.style.cssText = cssText\n    })\n</code></pre><h3 id=\"psd设计图导入生成h5页面\"><a href=\"#psd设计图导入生成h5页面\" class=\"headerlink\" title=\"psd设计图导入生成h5页面\"></a>psd设计图导入生成h5页面</h3><p>将psd每个设计图中的每个图层导出成图片保存到静态资源服务器中，</p>\n<p>服务端安装psd依赖</p>\n<pre><code>    cnpm install psd --save\n</code></pre><h4 id=\"加入psd-js依赖，并且提供接口来处理数据\"><a href=\"#加入psd-js依赖，并且提供接口来处理数据\" class=\"headerlink\" title=\"加入psd.js依赖，并且提供接口来处理数据\"></a>加入psd.js依赖，并且提供接口来处理数据</h4><pre><code>var PSD = require(&#39;psd&#39;);\n    router.post(&#39;/psdPpload&#39;,async ctx=&gt;{\n    const file = ctx.request.files.file; // 获取上传文件\n    let psd = await PSD.open(file.path)\n    var timeStr = + newDate();\n    let descendantsList = psd.tree().descendants();\n    descendantsList.reverse();\n    let psdSourceList = []\n    let currentPathDir = `public/upload_static/psd_image/${timeStr}`\n    for (var i = 0; i &lt; descendantsList.length; i++){\n    if (descendantsList[i].isGroup()) continue;\n    if (!descendantsList[i].visible) continue;\n    try{\n    await descendantsList[i].saveAsPng(path.join(ctx.state.SERVER_PATH, currentPathDir + `/${i}.png`))\n    psdSourceList.push({\n    ...descendantsList[i].export(),\n    type: &#39;picture&#39;,\n    imageSrc: ctx.state.BASE_URL + `/upload_static/psd_image/${timeStr}/${i}.png`,\n    })\n    }catch (e) {\n    // 转换不出来的图层先忽略\n    continue;\n    }\n    }\n    ctx.body = {\n        elements: psdSourceList,\n        document: psd.tree().export().document\n    };\n})\n</code></pre><p>最后把获取的数据转义并返回给前端，前端获取到数据后使用系统统一方法，遍历添加统一图片组件</p>\n<h2 id=\"后端服务\"><a href=\"#后端服务\" class=\"headerlink\" title=\"后端服务\"></a>后端服务</h2><h3 id=\"初始化项目\"><a href=\"#初始化项目\" class=\"headerlink\" title=\"初始化项目\"></a>初始化项目</h3><p>工程目录上文已给出，也可以使用 koa-generator 脚手架工具生成</p>\n<h5 id=\"ejs-template-模板引擎配置\"><a href=\"#ejs-template-模板引擎配置\" class=\"headerlink\" title=\"ejs-template 模板引擎配置\"></a>ejs-template 模板引擎配置</h5><p>app.js</p>\n<pre><code>//配置ejs-template 模板引擎\nrender(app, {\n    root: path.join(__dirname, &#39;views&#39;),\n    layout: false,\n    viewExt: &#39;html&#39;,\n    cache: false,\n    debug: false\n});\n</code></pre><h3 id=\"koa-static静态资源服务\"><a href=\"#koa-static静态资源服务\" class=\"headerlink\" title=\"koa-static静态资源服务\"></a>koa-static静态资源服务</h3><p>因为html2canvas需要图片允许跨域，所以在静态资源服务中所有资源请求设置’Access-Control-Allow-Origin’:’*’</p>\n<p>app.js</p>\n<pre><code>//配置静态web\napp.use(koaStatic(__dirname + &#39;/public&#39;), { gzip: true, setHeaders: function(res){\n    res.header( &#39;Access-Control-Allow-Origin&#39;, &#39;*&#39;)\n}});\n</code></pre><h4 id=\"修改路由的注册方式，通过遍历routes文件夹读取文件\"><a href=\"#修改路由的注册方式，通过遍历routes文件夹读取文件\" class=\"headerlink\" title=\"修改路由的注册方式，通过遍历routes文件夹读取文件\"></a>修改路由的注册方式，通过遍历routes文件夹读取文件</h4><p>app.js</p>\n<pre><code>const fs =  require(&#39;fs&#39;)\nfs.readdirSync(&#39;./routes&#39;).forEach(route=&gt; {\n    let api = require(`./routes/${route}`)\n    app.use(api.routes(), api.allowedMethods())\n})\n</code></pre><h4 id=\"添加jwt认证，同时过滤不需要认证的路由，如获取token\"><a href=\"#添加jwt认证，同时过滤不需要认证的路由，如获取token\" class=\"headerlink\" title=\"添加jwt认证，同时过滤不需要认证的路由，如获取token\"></a>添加jwt认证，同时过滤不需要认证的路由，如获取token</h4><p>app.js</p>\n<pre><code>const jwt = require(&#39;koa-jwt&#39;)\napp.use(jwt({ secret: &#39;yourstr&#39; }).unless({\n    path: [\n        /^\\/$/, /\\/token/, /\\/wechat/,\n        { url: /\\/papers/, methods: [&#39;GET&#39;] }\n    ]\n}));\n</code></pre><h4 id=\"中间件实现统一接口返回数据格式，全局错误捕获并响应\"><a href=\"#中间件实现统一接口返回数据格式，全局错误捕获并响应\" class=\"headerlink\" title=\"中间件实现统一接口返回数据格式，全局错误捕获并响应\"></a>中间件实现统一接口返回数据格式，全局错误捕获并响应</h4><p>middleware/formatresponse.js</p>\n<pre><code>module.exports = async (ctx, next) =&gt; {\n    await next().then(() =&gt; {\n    if (ctx.status === 200) {\n        ctx.body = {\n            message: &#39;成功&#39;,\n            code: 200,\n            body: ctx.body,\n            status: true\n        }\n    } elseif (ctx.status === 201) { // 201处理模板引擎渲染\n\n    } else {\n        ctx.body = {\n            message: ctx.body || &#39;接口异常，请重试&#39;,\n            code: ctx.status,\n            body: &#39;接口请求失败&#39;,\n            status: false\n        }\n    }\n    }).catch((err) =&gt; {\n    if (err.status === 401) {\n        ctx.status = 401;\n        ctx.body = {\n        code: 401,\n        status: false,\n        message: &#39;登录过期，请重新登录&#39;\n    }\n    } else {\n        throw err\n    }\n    })\n    }\n</code></pre><h3 id=\"koa2-cors跨域处理\"><a href=\"#koa2-cors跨域处理\" class=\"headerlink\" title=\"koa2-cors跨域处理\"></a>koa2-cors跨域处理</h3><p>当接口发布到线上，前端通过ajax请求时，会报跨域的错误。koa2使用koa2-cors这个库非常方便的实现了跨域配置，使用起来也很简单</p>\n<pre><code>const cors = require(&#39;koa2-cors&#39;);\n    app.use(cors());\n</code></pre><h3 id=\"连接数据库\"><a href=\"#连接数据库\" class=\"headerlink\" title=\"连接数据库\"></a>连接数据库</h3><p>我们使用mongodb数据库，在koa2中使用mongoose这个库来管理整个数据库的操作。</p>\n<p>创建配置文件<br>根目录下新建config文件夹，新建mongo.js</p>\n<pre><code>   //config/mongo.js\n    const mongoose = require(&#39;mongoose&#39;).set(&#39;debug&#39;, true);\n    const options = {\n        autoReconnect: true\n    }\n\n    // username 数据库用户名\n    // password 数据库密码\n    // localhost 数据库ip\n    // dbname 数据库名称\n    const url = &#39;mongodb://username:password@localhost:27017/dbname&#39;\n\n    module.exports = {\n        connect: ()=&gt; {\n            mongoose.connect(url,options)\n            let db = mongoose.connection\n            db.on(&#39;error&#39;, console.error.bind(console, &#39;连接错误:&#39;));\n            db.once(&#39;open&#39;, ()=&gt; {\n                console.log(&#39;mongodb connect suucess&#39;);\n            })\n        }\n    }\n</code></pre><p>把mongodb配置信息放到config.json中统一管理</p>\n<p>然后在app.js中引入</p>\n<pre><code>const mongoConf = require(&#39;./config/mongo&#39;);\n    mongoConf.connect();\n</code></pre><h2 id=\"启动运行\"><a href=\"#启动运行\" class=\"headerlink\" title=\"启动运行\"></a>启动运行</h2><h4 id=\"启动前端\"><a href=\"#启动前端\" class=\"headerlink\" title=\"启动前端\"></a>启动前端</h4><pre><code>    npm run dev-client\n</code></pre><h4 id=\"启动服务端\"><a href=\"#启动服务端\" class=\"headerlink\" title=\"启动服务端\"></a>启动服务端</h4><pre><code>    npm run dev-server\n</code></pre><p>注意：如果没有生成过引擎模板js文件的，需要先编辑引擎模板，否则预览页面加载页面引擎.js 404报错</p>\n<h4 id=\"编译engine-js模板引擎\"><a href=\"#编译engine-js模板引擎\" class=\"headerlink\" title=\"编译engine.js模板引擎\"></a>编译engine.js模板引擎</h4><pre><code>    npm run lib:h5-swiper\n</code></pre>","updated":"2020-05-11T02:59:43.105Z","comments":true,"link":"","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://yoursite.com/categories/前端开发/"}],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"前端微服务框架qiankun项目实践","date":"2020-05-11T02:30:58.000Z","path":"2020/05/11/qiankun/","text":"导语最近在做微前端的项目 , 过程中真是踩了不少坑 , 在有限的资料中不断试错 , 默默无语两行泪 哈哈. 在此次将踩坑部分都记录下来, 让更多的人少走点弯路 , 此项目使用 蚂蚁金服qiankun 为基础作为开发 . 话不多说 开讲 !!! 什么是qiankun（乾坤）qiankun 是一个基于 single-spa 的微前端实现库，旨在帮助大家能更简单、无痛的构建一个生产可用微前端架构系统。 什么是微前端微前端架构具备以下几个核心价值： 技术栈无关 主框架不限制接入应用的技术栈，微应用具备完全自主权 独立开发、独立部署 微应用仓库独立，前后端可独立开发，部署完成后主框架自动完成同步更新 增量升级 在面对各种复杂场景时，我们通常很难对一个已经存在的系统做全量的技术栈升级或重构，而微前端是一种非常好的实施渐进式重构的手段和策略 独立运行时 每个微应用之间状态隔离，运行时状态不共享 主应用配置此次项目 主应用与 子应用均为 vue , 下载 qiankunnpm install qiankun 在主应用中注册微应用 // 导入乾坤函数 import { registerMicroApps, setDefaultMountApp, start } from &quot;qiankun&quot;; 封装 render 方法此方法在main.js 中要初始调用一次, 主要用来挂载主应用 , 之后子应用分别依次调用 ,所以故作判断. 传入的参数分别为 子应用 的 HTML 和 加载状态 content 字段 我们用 vuex 存储 起来,方便使用 let app = null; function render({ appContent, loading }) { if (!app) { app = new Vue({ router, store, render: h =&gt; h(App), }).$mount(&#39;#app&#39;); } else { store.commit(&#39;microApp/changeCenter&#39;, appContent); store.commit(&#39;microApp/changeLoading&#39;, loading); } } 微应用注册下文中的apps 可以为获取后数据 , 注册微应用 本文案例比较简单,方便大家理解 ,在注册自应用的参数 container 与 render 踩坑比较多,下边会着重讲解. function genActiveRule(routerPrefix) { return location =&gt; location.pathname.startsWith(routerPrefix); } //传递给子应用的数据 let msg = { ![](https://user-gold-cdn.xitu.io/2020/4/27/171bbc5de042ec98?w=1811&amp;h=959&amp;f=gif&amp;s=4951066) data:&#39;修炼爱情的辛酸,学会放好以前的渴望&#39; } let apps = [ { name: &#39;linjunjie&#39;, entry: &#39;//localhost:215&#39;, // 改成自己子应用的端口号 container:&#39;#subView&#39;, //节点 id // 沙盒模式 // render:render, // 普通模式 activeRule: genActiveRule(&#39;/star&#39;), props:msg } ] //注册的子应用 参数为数组 registerMicroApps(apps,{ beforeLoad: [ app =&gt; { console.log(app) console.log(&#39;[LifeCycle] before load %c%s&#39;, &#39;color: green;&#39;, app.name); }, ], beforeMount: [ app =&gt; { console.log(&#39;[LifeCycle] before mount %c%s&#39;, &#39;color: green;&#39;, app.name); }, ], afterUnmount: [ app =&gt; { console.log(&#39;[LifeCycle] after unmount %c%s&#39;, &#39;color: green;&#39;, app.name); }, ], }); setDefaultMountApp(&#39;/star/linjunjie&#39;) //开启沙盒模式 start({ sandbox :{strictStyleIsolation: true} }) 当微应用信息注册完之后，一旦浏览器的 url 发生变化，便会自动触发 qiankun 的匹配逻辑，所有 activeRule 规则匹配上的微应用就会被插入到指定的 container 中，同时依次调用微应用暴露出的生命周期钩子。 主应用为子应用准备的 展示元素&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;div id=&quot;nav&quot;&gt; &lt;!--//主应用 为子应用的跳转dom--&gt; &lt;div @click=&quot;onChangePage(&#39;/star/linjunjie&#39;)&quot; &gt;林俊杰&lt;/div&gt; &lt;div @click=&quot;onChangePage(&#39;/star/zhangyixin&#39;)&quot; &gt;张艺兴&lt;/div&gt; &lt;/div&gt; &lt;!--//用来展子应用的 内容区--&gt; &lt;div id=&quot;subView&quot; class=&quot;sub-content-wrap&quot; v-html=&quot;content&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import { mapState } from &#39;vuex&#39;; export default{ data(){ return { } }, computed:{ //获取子应用HTML 数据 ...mapState(&#39;microApp&#39;, [&#39;content&#39;]), ...mapState(&#39;microApp&#39;, [&#39;mircoAppLoading&#39;]), }, methods:{ //定义跳转方法 onChangePage(url){ console.log(url) this.routerGo(url, &#39;我喜爱的男明星&#39;) }, routerGo(href = &#39;/&#39;, title = null, stateObj = {}) { window.history.pushState(stateObj, title, href); }, } } &lt;/script&gt; 子应用配置关于子应用的配置相对较简单 , 不需要额外下载qiankun 主要将生命钩子 导出即可 导出响应的生命钩子导出 bootstrap、mount、unmount 三个生命周期钩子，以供主应用在适当的时机调用。注意，实例化路由时，判断当运行在qiankun环境时，路由要添加前缀，前缀与主应用注册子应用函数genActiveRule(“/subdemo”)内的参数一致 ‘star’ 值需要与主应用的值对应 genActiveRule(“/star”) 中的值需要商定好 主应用与微应用都要使用 如果 new VueRouter 不在main.js 中 配置 ,请将此配置移动到 main.js 方便管理 import routes from &#39;./router&#39; //将路由信息导出方便使用 let router = null; let instance = null; function render(props = {}) { const { container } = props; router = new VueRouter({ base: window.__POWERED_BY_QIANKUN__ ? &#39;/star&#39; : &#39;/&#39;, mode: &#39;history&#39;, routes, }); instance = new Vue({ router, store, render: h =&gt; h(App), }).$mount(container ? container.querySelector(&#39;#app&#39;) : &#39;#app&#39;); } if (!window.__POWERED_BY_QIANKUN__) { render(); } export async function bootstrap() { console.log(&#39;[vue] vue app bootstraped&#39;); } export async function mount(props) { //props 包含主应用传递的参数 也包括为子应用 创建的节点信息 console.log(props) render(props); } export async function unmount() { instance.$destroy(); instance = null; router = null; } 配置微应用的打包工具除了代码中暴露出相应的生命周期钩子之外，为了让主应用能正确识别微应用暴露出来的一些信息，微应用的打包工具需要在vue.config.js 中 增加如下配置: const packageName = require(&#39;./package.json&#39;).name; module.exports = { output: { library: `${packageName}-[name]`, libraryTarget: &#39;umd&#39;, jsonpFunction: `webpackJsonp_${packageName}`, }, }; 子应用判断子应用中新建 publicPath.js 在main.js 引入 if (window.__POWERED_BY_QIANKUN__) { //处理资源 __webpack_public_path__ = window.__INJECTED_PUBLIC_PATH_BY_QIANKUN__; } 处理 资源加载问题配置 vue.config.js module.exports = { publicPath:`//localhost:${port}`, } vue.config.js 完整配置const path = require(&#39;path&#39;); const packageName = require(&#39;./package&#39;).name; function resolve(dir) { return path.join(__dirname, dir); } const port = 7101; // dev port module.exports = { publicPath:`//localhost:${port}`, outputDir: &#39;dist&#39;, assetsDir: &#39;static&#39;, filenameHashing: true, devServer: { // host: &#39;0.0.0.0&#39;, hot: true, historyApiFallback: true,//添加 重点 port, overlay: { warnings: false, errors: true, }, headers: { &#39;Access-Control-Allow-Origin&#39;: &#39;*&#39;, }, }, configureWebpack: { resolve: { alias: { &#39;@&#39;: resolve(&#39;src&#39;), }, }, output: { library: `${packageName}-[name]`, libraryTarget: &#39;umd&#39;, jsonpFunction: `webpackJsonp_${packageName}`, }, }, }; 踩坑记录当前页面为子应用时, 刷新页面404以下方式均为主应用配置 方式一 删除 mode 配置项mode: &#39;history&#39;, // 将此配置代码删除 方式二 配置404 页面 如果没有注释掉mode: ‘history’ 此参数 将404 页面重新导向 home首页 { path: &#39;*&#39;, name: &#39;indexNotFound&#39;, component: resolve =&gt; require([&#39;@/components/home&#39;], resolve), children: HomeChild, }, 子应用 样式隔离 开始沙箱模式 遇到的问题 主应用配置sandbox :{strictStyleIsolation: true}渲染模式由 render 模式 改为 containercontainer:’#subView’, 此时 子应用的 挂载 dom 为 谨记主 container :#+id 子应用配置 上文有提到 主要代码 截取instance = new Vue({ router, store, render: h =&gt; h(App), }).$mount(container ? container.querySelector(&#39;#app&#39;) : &#39;#app&#39;); //重点 遇到的问题: 开启沙箱模式,如果是 采用 render 模式会报错 ,故选择container 模式 写到这里,项目已经构建完成了 这里是完整代码 方便大家学习 代码github地址:https://github.com/suchengyong/qiankun-vue 项目问题为啥我项目启动后看不到子应用的效果将master 主应用 main.js 中 注册的 子应用的端口号 改成自己项目的端口号即可 结语开发中还有其他坑 忘记记录了, 千万记得项目部署子应用资源跨域的问题 , 需要Nginx配置跨域问题","content":"<h2 id=\"导语\"><a href=\"#导语\" class=\"headerlink\" title=\"导语\"></a>导语</h2><p>最近在做微前端的项目 , 过程中真是踩了不少坑 , 在有限的资料中不断试错 , 默默无语两行泪 哈哈.  在此次将踩坑部分都记录下来, 让更多的人少走点弯路 ,   此项目使用 蚂蚁金服qiankun 为基础作为开发 . 话不多说 开讲 !!!</p>\n<h3 id=\"什么是qiankun（乾坤）\"><a href=\"#什么是qiankun（乾坤）\" class=\"headerlink\" title=\"什么是qiankun（乾坤）\"></a>什么是qiankun（乾坤）</h3><p>qiankun 是一个基于 single-spa 的微前端实现库，旨在帮助大家能更简单、无痛的构建一个生产可用微前端架构系统。</p>\n<h3 id=\"什么是微前端\"><a href=\"#什么是微前端\" class=\"headerlink\" title=\"什么是微前端\"></a>什么是微前端</h3><p>微前端架构具备以下几个核心价值：</p>\n<ul>\n<li>技术栈无关</li>\n</ul>\n<p>主框架不限制接入应用的技术栈，微应用具备完全自主权</p>\n<ul>\n<li>独立开发、独立部署</li>\n</ul>\n<p>微应用仓库独立，前后端可独立开发，部署完成后主框架自动完成同步更新</p>\n<ul>\n<li>增量升级</li>\n</ul>\n<p>在面对各种复杂场景时，我们通常很难对一个已经存在的系统做全量的技术栈升级或重构，而微前端是一种非常好的实施渐进式重构的手段和策略</p>\n<ul>\n<li>独立运行时</li>\n</ul>\n<p>每个微应用之间状态隔离，运行时状态不共享</p>\n<h3 id=\"主应用配置\"><a href=\"#主应用配置\" class=\"headerlink\" title=\"主应用配置\"></a>主应用配置</h3><p>此次项目 主应用与 子应用均为 vue ,</p>\n<h4 id=\"下载-qiankun\"><a href=\"#下载-qiankun\" class=\"headerlink\" title=\"下载 qiankun\"></a>下载 qiankun</h4><pre><code>npm install qiankun\n</code></pre><p>在主应用中注册微应用</p>\n<pre><code>// 导入乾坤函数\nimport {\n  registerMicroApps,\n  setDefaultMountApp,\n  start\n} from &quot;qiankun&quot;;\n</code></pre><h4 id=\"封装-render-方法\"><a href=\"#封装-render-方法\" class=\"headerlink\" title=\"封装 render 方法\"></a>封装 render 方法</h4><p>此方法在main.js 中要初始调用一次, 主要用来挂载主应用 , 之后子应用分别依次调用 ,所以故作判断. 传入的参数分别为 子应用 的 HTML 和 加载状态 content 字段 我们用 vuex 存储 起来,方便使用</p>\n<pre><code>let app = null;\n\nfunction render({ appContent, loading }) {\n  if (!app) {\n    app = new Vue({\n      router,\n      store,\n      render: h =&gt; h(App),\n    }).$mount(&#39;#app&#39;);\n\n  } else {\n    store.commit(&#39;microApp/changeCenter&#39;, appContent);\n    store.commit(&#39;microApp/changeLoading&#39;, loading);\n  }\n\n}\n</code></pre><h4 id=\"微应用注册\"><a href=\"#微应用注册\" class=\"headerlink\" title=\"微应用注册\"></a>微应用注册</h4><p>下文中的apps 可以为获取后数据 , 注册微应用 本文案例比较简单,方便大家理解 ,<br>在注册自应用的参数 <strong> container 与 render</strong> 踩坑比较多,下边会着重讲解.</p>\n<pre><code>function genActiveRule(routerPrefix) {\n  return location =&gt; location.pathname.startsWith(routerPrefix);\n}\n\n//传递给子应用的数据\nlet msg = {\n![](https://user-gold-cdn.xitu.io/2020/4/27/171bbc5de042ec98?w=1811&amp;h=959&amp;f=gif&amp;s=4951066)\n  data:&#39;修炼爱情的辛酸,学会放好以前的渴望&#39;\n}\n\nlet apps = [\n  {\n    name: &#39;linjunjie&#39;, \n    entry: &#39;//localhost:215&#39;,  // 改成自己子应用的端口号\n    container:&#39;#subView&#39;, //节点 id   //  沙盒模式 \n    // render:render,  // 普通模式   \n    activeRule: genActiveRule(&#39;/star&#39;),\n    props:msg\n  }\n]\n   //注册的子应用 参数为数组\nregisterMicroApps(apps,{\n  beforeLoad: [\n    app =&gt; {\n      console.log(app)\n      console.log(&#39;[LifeCycle] before load %c%s&#39;, &#39;color: green;&#39;, app.name);\n    },\n  ],\n  beforeMount: [\n    app =&gt; {\n      console.log(&#39;[LifeCycle] before mount %c%s&#39;, &#39;color: green;&#39;, app.name);\n    },\n  ],\n  afterUnmount: [\n    app =&gt; {\n      console.log(&#39;[LifeCycle] after unmount %c%s&#39;, &#39;color: green;&#39;, app.name);\n    },\n  ],\n});\n\n\nsetDefaultMountApp(&#39;/star/linjunjie&#39;)\n\n//开启沙盒模式\nstart({ \n   sandbox :{strictStyleIsolation: true}\n})\n</code></pre><p>当微应用信息注册完之后，一旦浏览器的 url 发生变化，便会自动触发 qiankun 的匹配逻辑，所有 activeRule 规则匹配上的微应用就会被插入到指定的 container 中，同时依次调用微应用暴露出的生命周期钩子。</p>\n<h4 id=\"主应用为子应用准备的-展示元素\"><a href=\"#主应用为子应用准备的-展示元素\" class=\"headerlink\" title=\"主应用为子应用准备的 展示元素\"></a>主应用为子应用准备的 展示元素</h4><pre><code>&lt;template&gt;\n  &lt;div id=&quot;app&quot;&gt;\n    &lt;div id=&quot;nav&quot;&gt;\n      &lt;!--//主应用 为子应用的跳转dom--&gt;\n      &lt;div @click=&quot;onChangePage(&#39;/star/linjunjie&#39;)&quot; &gt;林俊杰&lt;/div&gt;\n      &lt;div @click=&quot;onChangePage(&#39;/star/zhangyixin&#39;)&quot; &gt;张艺兴&lt;/div&gt;\n\n    &lt;/div&gt;\n&lt;!--//用来展子应用的 内容区--&gt;\n     &lt;div id=&quot;subView&quot; class=&quot;sub-content-wrap&quot; v-html=&quot;content&quot;&gt;&lt;/div&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\n\n  import { mapState } from &#39;vuex&#39;;\n  export default{\n    data(){\n      return {\n\n      }\n    },\n    computed:{\n    //获取子应用HTML 数据\n       ...mapState(&#39;microApp&#39;, [&#39;content&#39;]),\n       ...mapState(&#39;microApp&#39;, [&#39;mircoAppLoading&#39;]),\n    },\n\n    methods:{\n\n      //定义跳转方法\n      onChangePage(url){\n        console.log(url)\n\n        this.routerGo(url, &#39;我喜爱的男明星&#39;)\n      },\n\n      routerGo(href = &#39;/&#39;, title = null, stateObj = {}) {\n        window.history.pushState(stateObj, title, href); \n      },\n    }\n }\n&lt;/script&gt;\n</code></pre><h3 id=\"子应用配置\"><a href=\"#子应用配置\" class=\"headerlink\" title=\"子应用配置\"></a>子应用配置</h3><p>关于子应用的配置相对较简单 , 不需要额外下载qiankun 主要将生命钩子 导出即可</p>\n<h4 id=\"导出响应的生命钩子\"><a href=\"#导出响应的生命钩子\" class=\"headerlink\" title=\"导出响应的生命钩子\"></a>导出响应的生命钩子</h4><p>导出 bootstrap、mount、unmount 三个生命周期钩子，以供主应用在适当的时机调用。注意，实例化路由时，判断当运行在qiankun环境时，路由要添加前缀，前缀与主应用注册子应用函数genActiveRule(“/subdemo”)内的参数一致</p>\n<p>‘star’ 值需要与主应用的值对应 genActiveRule(“/star”) 中的值需要商定好 主应用与微应用都要使用</p>\n<p>如果 new VueRouter 不在main.js  中 配置 ,请将此配置移动到 main.js  方便管理</p>\n<pre><code>import routes from &#39;./router&#39; //将路由信息导出方便使用 \n\nlet router = null;\nlet instance = null;\n\nfunction render(props = {}) {\n  const { container } = props;\n  router = new VueRouter({\n    base: window.__POWERED_BY_QIANKUN__ ? &#39;/star&#39; : &#39;/&#39;,  \n    mode: &#39;history&#39;,\n    routes,\n  });\n\n  instance = new Vue({\n    router,\n    store,\n    render: h =&gt; h(App),\n  }).$mount(container ? container.querySelector(&#39;#app&#39;) : &#39;#app&#39;);\n}\n\nif (!window.__POWERED_BY_QIANKUN__) {\n  render();\n}\n\n\nexport async function bootstrap() {\n  console.log(&#39;[vue] vue app bootstraped&#39;);\n}\n\nexport async function mount(props) {\n //props 包含主应用传递的参数  也包括为子应用 创建的节点信息\n  console.log(props)\n  render(props);\n}\n\nexport async function unmount() {\n  instance.$destroy();\n  instance = null;\n  router = null;\n}\n</code></pre><h4 id=\"配置微应用的打包工具\"><a href=\"#配置微应用的打包工具\" class=\"headerlink\" title=\"配置微应用的打包工具\"></a>配置微应用的打包工具</h4><p>除了代码中暴露出相应的生命周期钩子之外，为了让主应用能正确识别微应用暴露出来的一些信息，微应用的打包工具需要在vue.config.js 中 增加如下配置:</p>\n<pre><code>const packageName = require(&#39;./package.json&#39;).name;\n\nmodule.exports = {\n  output: {\n    library: `${packageName}-[name]`,\n    libraryTarget: &#39;umd&#39;,\n    jsonpFunction: `webpackJsonp_${packageName}`,\n  },\n};\n</code></pre><h4 id=\"子应用判断\"><a href=\"#子应用判断\" class=\"headerlink\" title=\"子应用判断\"></a>子应用判断</h4><p>子应用中新建 publicPath.js  在main.js 引入</p>\n<pre><code>if (window.__POWERED_BY_QIANKUN__) { \n//处理资源\n __webpack_public_path__ = window.__INJECTED_PUBLIC_PATH_BY_QIANKUN__; \n}\n</code></pre><h4 id=\"处理-资源加载问题\"><a href=\"#处理-资源加载问题\" class=\"headerlink\" title=\"处理 资源加载问题\"></a>处理 资源加载问题</h4><p>配置 vue.config.js</p>\n<pre><code>module.exports = {\n  publicPath:`//localhost:${port}`,\n}\n</code></pre><h4 id=\"vue-config-js-完整配置\"><a href=\"#vue-config-js-完整配置\" class=\"headerlink\" title=\"vue.config.js 完整配置\"></a>vue.config.js 完整配置</h4><pre><code>const path = require(&#39;path&#39;);\nconst packageName = require(&#39;./package&#39;).name;\n\nfunction resolve(dir) {\n  return path.join(__dirname, dir);\n}\n\nconst port = 7101; // dev port\nmodule.exports = {\n\n  publicPath:`//localhost:${port}`,\n  outputDir: &#39;dist&#39;,\n  assetsDir: &#39;static&#39;,\n  filenameHashing: true,\n\n  devServer: {\n    // host: &#39;0.0.0.0&#39;,\n    hot: true,\n    historyApiFallback: true,//添加 重点\n    port,\n    overlay: {\n      warnings: false,\n      errors: true,\n    },\n    headers: {\n      &#39;Access-Control-Allow-Origin&#39;: &#39;*&#39;,\n    },\n  },\n\n  configureWebpack: {\n    resolve: {\n      alias: {\n        &#39;@&#39;: resolve(&#39;src&#39;),\n      },\n    },\n    output: {\n      library: `${packageName}-[name]`,\n      libraryTarget: &#39;umd&#39;,\n      jsonpFunction: `webpackJsonp_${packageName}`,\n    },\n  },\n};\n</code></pre><h3 id=\"踩坑记录\"><a href=\"#踩坑记录\" class=\"headerlink\" title=\"踩坑记录\"></a>踩坑记录</h3><h4 id=\"当前页面为子应用时-刷新页面404\"><a href=\"#当前页面为子应用时-刷新页面404\" class=\"headerlink\" title=\"当前页面为子应用时, 刷新页面404\"></a>当前页面为子应用时, 刷新页面404</h4><p>以下方式均为主应用配置</p>\n<ul>\n<li>方式一 删除 mode 配置项<pre><code>mode: &#39;history&#39;, //   将此配置代码删除\n</code></pre></li>\n<li>方式二 配置404  页面</li>\n</ul>\n<p>如果没有注释掉mode: ‘history’  此参数 将404 页面重新导向  home首页</p>\n<pre><code>{\n    path: &#39;*&#39;,\n    name: &#39;indexNotFound&#39;,\n    component: resolve =&gt; require([&#39;@/components/home&#39;], resolve),\n    children: HomeChild,\n},\n</code></pre><h4 id=\"子应用-样式隔离-开始沙箱模式-遇到的问题\"><a href=\"#子应用-样式隔离-开始沙箱模式-遇到的问题\" class=\"headerlink\" title=\"子应用 样式隔离 开始沙箱模式 遇到的问题\"></a>子应用 样式隔离 开始沙箱模式 遇到的问题</h4><ul>\n<li>主应用配置sandbox :{strictStyleIsolation: true}渲染模式由 render 模式 改为 containercontainer:’#subView’, 此时 子应用的 挂载 dom  为 <div id=\"subView\"> </div>   谨记主 container :#+id</li>\n<li>子应用配置 上文有提到  主要代码 截取<pre><code>instance = new Vue({\n  router,\n  store,\n  render: h =&gt; h(App),\n}).$mount(container ? container.querySelector(&#39;#app&#39;) : &#39;#app&#39;); //重点\n</code></pre>遇到的问题: 开启沙箱模式,如果是 采用 render 模式会报错 ,故选择container 模式</li>\n</ul>\n<p>写到这里,项目已经构建完成了 </p>\n<p>这里是完整代码 方便大家学习 代码github地址:<a href=\"https://github.com/suchengyong/qiankun-vue\">https://github.com/suchengyong/qiankun-vue</a></p>\n<h3 id=\"项目问题\"><a href=\"#项目问题\" class=\"headerlink\" title=\"项目问题\"></a>项目问题</h3><p>为啥我项目启动后看不到子应用的效果<br>将master 主应用 main.js 中 注册的 子应用的端口号 改成自己项目的端口号即可</p>\n<h3 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h3><p>开发中还有其他坑 忘记记录了, 千万记得项目部署子应用资源跨域的问题 , 需要Nginx配置跨域问题</p>\n","updated":"2020-05-11T02:55:28.014Z","comments":true,"link":"","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://yoursite.com/categories/前端开发/"}],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"H5 直播的疯狂点赞动画是如何实现的","date":"2020-05-11T02:30:58.000Z","path":"2020/05/11/H5_live/","text":"直播有一个很重要的互动：点赞。为了烘托直播间的氛围，直播相对于普通视频或者文本内容，点赞通常有两个特殊需求： 点赞动作无限次，引导用户疯狂点赞直播间的所有疯狂点赞，都需要在所有用户界面都动画展现出来(广播用户使用websocket消息)文章链接 https://mp.weixin.qq.com/s/E8MXKfNPn3nkVjGGXNESAA 两种方式渲染点赞动画都已经完成，完整源码，源码戳这里 https://github.com/antiter/praise-animation 。 这里还可以体验线上点赞动画，戳这里： https://wqs.jd.com/pglive/index.html","content":"<h4 id=\"直播有一个很重要的互动：点赞。\"><a href=\"#直播有一个很重要的互动：点赞。\" class=\"headerlink\" title=\"直播有一个很重要的互动：点赞。\"></a>直播有一个很重要的互动：点赞。</h4><p>为了烘托直播间的氛围，直播相对于普通视频或者文本内容，点赞通常有两个特殊需求：</p>\n<p>点赞动作无限次，引导用户疯狂点赞<br>直播间的所有疯狂点赞，都需要在所有用户界面都动画展现出来(广播用户使用websocket消息)<br>文章链接 <a href=\"https://mp.weixin.qq.com/s/E8MXKfNPn3nkVjGGXNESAA\">https://mp.weixin.qq.com/s/E8MXKfNPn3nkVjGGXNESAA</a></p>\n<p>两种方式渲染点赞动画都已经完成，完整源码，源码戳这里 <a href=\"https://github.com/antiter/praise-animation\">https://github.com/antiter/praise-animation</a> 。</p>\n<p>这里还可以体验线上点赞动画，戳这里： <a href=\"https://wqs.jd.com/pglive/index.html\">https://wqs.jd.com/pglive/index.html</a></p>\n","updated":"2020-05-11T03:17:18.978Z","comments":true,"link":"","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://yoursite.com/categories/前端开发/"}],"tags":[{"name":"htnl5","slug":"htnl5","permalink":"http://yoursite.com/tags/htnl5/"}]},{"title":"使用第三方库ts-node简化Ts编译流程","date":"2020-05-11T02:30:58.000Z","path":"2020/05/11/ts-node/","text":"1、ts-node: 将ts文件在内存中完成编译、同时完成运行1、全局安装ts-node和typescript两个模块 npm i -g ts-node typescript 使用： ts-node src/index.ts2、nodemon: 用于检测文件变化 cnpm i -g nodemon 3、使用： nodemon --exec ts-node src/index.ts 4、可以将检测文件变化添加到脚本、方便调用在package.json中添加： &quot;scripts&quot;: { &quot;dev&quot;: &quot;nodemon --watch src -e ts --exec ts-node src/index.ts&quot; } –watch src: 只检测src文件夹 -e ts: 只检.ts文件 5、使用时直接： npm run dev","content":"<h4 id=\"1、ts-node-将ts文件在内存中完成编译、同时完成运行\"><a href=\"#1、ts-node-将ts文件在内存中完成编译、同时完成运行\" class=\"headerlink\" title=\"1、ts-node: 将ts文件在内存中完成编译、同时完成运行\"></a>1、ts-node: 将ts文件在内存中完成编译、同时完成运行</h4><p>1、全局安装ts-node和typescript两个模块</p>\n<pre><code>npm i -g ts-node  typescript\n</code></pre><h4 id=\"使用：-ts-node-src-index-ts\"><a href=\"#使用：-ts-node-src-index-ts\" class=\"headerlink\" title=\"使用： ts-node src/index.ts\"></a>使用： ts-node src/index.ts</h4><p>2、nodemon: 用于检测文件变化</p>\n<pre><code>cnpm i -g nodemon\n</code></pre><p>3、使用：</p>\n<pre><code>nodemon --exec ts-node src/index.ts\n</code></pre><p>4、可以将检测文件变化添加到脚本、方便调用<br>在package.json中添加：</p>\n<pre><code>&quot;scripts&quot;: {\n    &quot;dev&quot;: &quot;nodemon --watch src -e ts --exec ts-node src/index.ts&quot;\n }\n</code></pre><ul>\n<li>–watch src: 只检测src文件夹</li>\n<li>-e ts: 只检.ts文件</li>\n</ul>\n<p>5、使用时直接：</p>\n<pre><code>npm run dev\n</code></pre>","updated":"2020-05-11T03:14:56.259Z","comments":true,"link":"","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://yoursite.com/categories/前端开发/"}],"tags":[{"name":"Ts","slug":"Ts","permalink":"http://yoursite.com/tags/Ts/"}]},{"title":"Hexo搭建记录","date":"2020-05-11T02:23:58.000Z","path":"2020/05/11/about/","text":"Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成完美的静态网页。 基础安装安装 Hexo 相当简单。然而在安装前，您必须检查电脑中是否已安装下列应用程序： node git如果您的电脑中已经安装上述必备程序，那么恭喜您！接下来只需要使用 npm 或者 yarn 即可完成 Hexo 的安装。$ npm install -g hexo-cli 安装 Node.js安装 Node.js 的最佳方式是使用 nvm。cURL: $ curl https://raw.github.com/creationix/nvm/master/install.sh | sh Wget: $ wget -qO- https://raw.github.com/creationix/nvm/master/install.sh | sh 安装完成后，重启终端并执行下列命令即可安装 Node.js。 $ nvm install stable 安装 Hexo所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。 $ npm install -g hexo-cli hexo系列相关插件 hexo脚手架$ npm install hexo-cli -g hexo-deployer-git (远程部署)$ npm install hexo-deployer-git --save hexo-asset-image (插入图片)$ npm install hexo-asset-image --save hexo-generator-json-content (用于全部文章获取)$ npm install hexo-generator-json-content --save yilia主题$ git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 建站 安装 Hexo 完成后，接下来就需要我们配置hexo,请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件. $ hexo init &lt;folder&gt; $ cd &lt;folder&gt; $ npm install 1.打开根目录_config.yml文件，设置网站内容:标题、描述等 2.配置deploy选项: type: 根据代码部署情况(我的是git)repo: 项目仓库地址branch: 项目所在分支 3.设置主题 theme: yilia 4.主题内容设置: 进入themes/yilia/_config.yml,根据自己要求设置即可。可参考Yilia 写作你可以执行下列命令来创建一篇新文章 $ hexo new [layout] &lt;title&gt; 本地启动测试$ hexo server 发布1.首先清除原来打包资源，首次不需要清除 $ hexo clean 2.生成静态资源 $ hexo generate 3.部署到远程服务器上 $ hexo deploy","content":"<p>Hexo 是一个快速、简洁且高效的博客框架。<a href=\"https://hexo.io/zh-cn/docs/\">Hexo</a> 使用 <a href=\"http://markdownpad.com/\">Markdown</a>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成完美的静态网页。</p>\n<h2 id=\"基础安装\"><a href=\"#基础安装\" class=\"headerlink\" title=\"基础安装\"></a>基础安装</h2><p>安装 Hexo 相当简单。然而在安装前，您必须检查电脑中是否已安装下列应用程序：</p>\n<ul>\n<li><a href=\"https://nodejs.org/zh-cn/\">node</a><br></li>\n<li><a href=\"https://git-scm.com/downloads\">git</a><br>如果您的电脑中已经安装上述必备程序，那么恭喜您！接下来只需要使用 npm 或者 yarn 即可完成 Hexo 的安装。<pre><code class=\"bash\">$ npm install -g hexo-cli\n</code></pre>\n</li>\n</ul>\n<h2 id=\"安装-Node-js\"><a href=\"#安装-Node-js\" class=\"headerlink\" title=\"安装 Node.js\"></a>安装 Node.js</h2><p>安装 Node.js 的最佳方式是使用 <a href=\"https://github.com/creationix/nvm\">nvm</a>。<br>cURL:</p>\n<pre><code class=\"bash\">$ curl https://raw.github.com/creationix/nvm/master/install.sh | sh\n</code></pre>\n<p>Wget:</p>\n<pre><code class=\"bash\">$ wget -qO- https://raw.github.com/creationix/nvm/master/install.sh | sh\n</code></pre>\n<p>安装完成后，重启终端并执行下列命令即可安装 Node.js。</p>\n<pre><code class=\"bash\">    $ nvm install stable\n</code></pre>\n<h2 id=\"安装-Hexo\"><a href=\"#安装-Hexo\" class=\"headerlink\" title=\"安装 Hexo\"></a>安装 Hexo</h2><p>所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。</p>\n<pre><code class=\"bash\">$ npm install -g hexo-cli\n</code></pre>\n<h2 id=\"hexo系列相关插件\"><a href=\"#hexo系列相关插件\" class=\"headerlink\" title=\"hexo系列相关插件\"></a>hexo系列相关插件</h2><ul>\n<li>hexo脚手架<pre><code class=\"bash\">$ npm install hexo-cli -g\n</code></pre>\n</li>\n<li>hexo-deployer-git (远程部署)<pre><code class=\"bash\">$ npm install hexo-deployer-git --save\n</code></pre>\n</li>\n<li>hexo-asset-image (插入图片)<pre><code class=\"bash\">$ npm install hexo-asset-image --save\n</code></pre>\n</li>\n<li>hexo-generator-json-content (用于全部文章获取)<pre><code class=\"bash\">$  npm install hexo-generator-json-content --save\n</code></pre>\n</li>\n<li>yilia主题<pre><code class=\"bash\">$  git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia\n</code></pre>\n<h2 id=\"建站\"><a href=\"#建站\" class=\"headerlink\" title=\"建站\"></a>建站</h2></li>\n</ul>\n<p>安装 Hexo 完成后，接下来就需要我们配置hexo,请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件.</p>\n<pre><code class=\"bash\">$ hexo init &lt;folder&gt;\n$ cd &lt;folder&gt;\n$ npm install\n</code></pre>\n<p>1.打开根目录_config.yml文件，设置网站内容:标题、描述等</p>\n<p>2.配置deploy选项:</p>\n<blockquote>\n<p>type: 根据代码部署情况(我的是git)<br>repo: 项目仓库地址<br>branch: 项目所在分支</p>\n</blockquote>\n<p>3.设置主题</p>\n<blockquote>\n<p>theme: yilia</p>\n</blockquote>\n<p>4.主题内容设置:</p>\n<blockquote>\n<p>进入themes/yilia/_config.yml,根据自己要求设置即可。<br>可参考<a href=\"https://github.com/litten/hexo-theme-yilia\">Yilia</a></p>\n</blockquote>\n<h2 id=\"写作\"><a href=\"#写作\" class=\"headerlink\" title=\"写作\"></a>写作</h2><p>你可以执行下列命令来创建一篇新文章</p>\n<pre><code class=\"bash\">$ hexo new [layout] &lt;title&gt;\n</code></pre>\n<h2 id=\"本地启动测试\"><a href=\"#本地启动测试\" class=\"headerlink\" title=\"本地启动测试\"></a>本地启动测试</h2><pre><code class=\"bash\">$ hexo server\n</code></pre>\n<h2 id=\"发布\"><a href=\"#发布\" class=\"headerlink\" title=\"发布\"></a>发布</h2><p>1.首先清除原来打包资源，首次不需要清除</p>\n<pre><code class=\"bash\">$ hexo clean\n</code></pre>\n<p>2.生成静态资源</p>\n<pre><code class=\"bash\">$  hexo generate\n</code></pre>\n<p>3.部署到远程服务器上</p>\n<pre><code class=\"bash\">$  hexo deploy\n</code></pre>\n","updated":"2020-05-11T03:08:46.317Z","comments":true,"link":"","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/categories/Hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]},{"title":"h5 总结及踩坑记录","date":"2020-05-11T02:20:59.000Z","path":"2020/05/11/h5zongjie/","text":"适配方案这个项目里用的是 rem 适配方案，通过计算 设备宽度/设计稿宽度 的比例，来设置 html 的 font-size 属性，达到适配的目的，代码如下： function setSize() { // 设备宽度 let deviceWidth = window.screen.width; // 设计稿宽度 const baseValue = 750; // html的字体大小 = (设备宽度 / 设计稿宽度) * 100 document.documentElement.style.fontSize = (deviceWidth / baseValue) * 100 + &#39;px&#39;; } // DOM树加载完执行 window.addEventListener(&quot;DOMContentLoaded&quot;, function () { setSize(); }) // 屏幕变化就执行 window.addEventListener(&quot;resize&quot;, function () { setSize(); }) setSize(); 资源的预加载资源的预加载用的是 preloadjs中文官网：www.createjs.cc/preloadjs用法也是极其简单： var queue = new window.createjs.LoadQueue(true); queue.on(&quot;complete&quot;, this.allLoadComplete); // 所有文件加载完成时触发 queue.on(&quot;fileload&quot;, this.aloneLoadComplete); // 单个文件加载完成时触发 queue.on(&quot;progress&quot;, this.fileProgress); // 加载进度 queue.loadManifest(allImg); // 需要加载的资源数组 queue.load() 如何解决需要引入很多图片的问题这里用到了 webpack 的 api: require.context，当项目需要引入很多资源时，这项技术是必须要掌握的可以阅读 使用require.context自动导入ES模块 - yeyan1996 这位大佬的文章，本文不做深入探讨 html2canvas 截取页面时图片模糊如果截取的区域里有涉及到图片，不要用 background 设置图片，全部替换成 img 标签这样可以大大提升图片的清晰度 ios 键盘会把页面顶上去 不会自动下来问题描述：移动端 ios 键盘弹起后，会把页面顶上去，输入完成后页面不会自动下来解决办法： document.body.addEventListener(&#39;focusout&#39;, function () { window.scrollTo(0,0); }); 当监听到 body 里有元素失去焦点时，就把页面滚上去 focusout: 当元素即将失去焦点时，focusout 事件被触发。focusout 事件和 blur 事件之间的主要区别在于后者不会冒泡—— MDN 滑动加载以及获取body实际高度的坑滑动加载的关键就是如果页面滑动到了底部，就进行数据的请求，要事先和后端沟通好数据怎么返回滑动到页面底部的条件：滚动条离顶部的距离（document.body.scrollTop）+ 窗口的文档显示区的高度（window.innerHeight）&gt;= 文档实际高度（document.body.scrollHeight）这里有个坑，关于获取文档实际高度的：document.body.scrollHeight 可以在手机上获取到实际文档高度，但在 chrome 里获取到的高度是 0document.documentElement.scrollHeight 在 chrome 里可以获取到正常的，但在手机上获取的高度是 0这样的话，还要判断当前设备是手机还是 pc 然后再去获取吗，No No No，有个优雅的写法： // 获取文档实际高度/移动端 var bodyHeight = Math.max( document.documentElement.scrollHeight, document.body.scrollHeight ); 去除 iphone x 的小尾巴大家管这玩意叫胡子，我比较喜欢叫小尾巴~，就是 iphone x 下面那一根玩意想要了解更多请点击：imweb.io/topic/5baa3…我在这里就说说我是怎么用的在 meta 标签里加上 viewport-fit=cover &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover&quot; /&gt; 然后在底部的样式里加上样式： bottom: env(safe-area-inset-bottom); bottom: 0; // 这一句也要加上 没有小尾巴的机型需要用到这个样式这里的 safe-area-inset-bottom 的意思是：在 Viewport底部的安全区域内设置量（CSS像素），更多方向看下图 ios 最新版系统 微信浏览器 html2canvas 生成图片失败这个项目里有个生成图片的功能，需要保存用户操作过的一些东西，其他设备都正常，唯独 ios 最新版的系统有问题debug 了一波后发现，这他瞄的根本没有执行这个函数，找一半天也没找到为什么，后来看 issues 发现有人说把版本换成 rc.4 的就可以了issues：github.com/niklasvh/ht… emoji 表情转码项目测试的时候，发现 textarea 标签里可以输入表情，紧接着，接口就报错了，一查看，虽然支持输入表情，但是不会自动对表情转码，所以提交接口的时候报错了，下面分享个 emoji 表情转字符的方法： // 表情转字符 utf16toEntities(str) { var patt = /[\\ud800-\\udbff][\\udc00-\\udfff]/g // 检测utf16字符正则 str = str.replace(patt, function(char) { var H, L, code if (char.length === 2) { H = char.charCodeAt(0) // 取出高位 L = char.charCodeAt(1) // 取出低位 code = (H - 0xd800) * 0x400 + 0x10000 + L - 0xdc00 // 转换算法 return &#39;&amp;#&#39; + code + &#39;;&#39; } else { return char } }) return str } iOS 的 webview 中 滑动不流畅解决方案1.在滚动容器上增加滚动 touch 方法 将-webkit-overflow-scrolling 值设置为 touch .wrapper { -webkit-overflow-scrolling: touch; } 设置滚动条隐藏： .container ::-webkit-scrollbar {display: none;} 可能会导致使用position:fixed; 固定定位的元素，随着页面一起滚动 2.设置 overflow 设置外部 overflow 为 hidden,设置内容元素 overflow 为 auto。内部元素超出 body 即产生滚动，超出的部分 body 隐藏。 body { overflow-y: hidden; } .wrapper { overflow-y: auto; } 两者结合使用更佳！ iOS 上拉边界下拉出现白色空白表现手指按住屏幕下拉，屏幕顶部会多出一块白色区域。手指按住屏幕上拉，底部多出一块白色区域。 产生原因在 iOS 中，手指按住屏幕上下拖动，会触发 touchmove 事件。这个事件触发的对象是整个 webview 容器，容器自然会被拖动，剩下的部分会成空白。 解决方案 监听事件禁止滑动 移动端触摸事件有三个，分别定义为 1. touchstart ：手指放在一个DOM元素上。 2. touchmove ：手指拖曳一个DOM元素。 3. touchend ：手指从一个DOM元素上移开。 touchmove 事件的速度是可以实现定义的，取决于硬件性能和其他实现细节 preventDefault 方法，阻止同一触点上所有默认行为，比如滚动。 由此我们找到解决方案，通过监听 touchmove，让需要滑动的地方滑动，不需要滑动的地方禁止滑动。 值得注意的是我们要过滤掉具有滚动容器的元素 实现如下：document.body.addEventListener(&#39;touchmove&#39;, function(e) { if(e._isScroller) return; // 阻止默认事件 e.preventDefault(); }, { passive: false }) click 点击事件延时与穿透表现监听元素 click 事件，点击元素触发时间延迟约 300ms。 点击蒙层，蒙层消失后，下层元素点击触发。 产生原因为什么会产生 click 延时？ iOS 中的 safari，为了实现双击缩放操作，在单击 300ms 之后，如果未进行第二次点击，则执行 click 单击操作。也就是说来判断用户行为是否为双击产生的。但是，在 App 中，无论是否需要双击缩放这种行为，click 单击都会产生 300ms 延迟。 为什么会产生 click 点击穿透？双层元素叠加时，在上层元素上绑定 touch 事件，下层元素绑定 click 事件。由于 click 发生在 touch 之后，点击上层元素，元素消失，下层元素会触发 click 事件，由此产生了点击穿透的效果。 原理与解决方案解决方案一：使用 touchstart 替换 click 前面已经介绍了，移动设备不仅支持点击，还支持几个触摸事件。那么我们现在基本思路就是用 touch 事件代替click 事件。 将 click 替换成 touchstart 不仅解决了 click 事件都延时问题，还解决了穿透问题。因为穿透问题是在 touch 和 click 混用时产生。 在原生中使用el.addEventListener(&quot;touchstart&quot;, () =&gt; { console.log(&quot;ok&quot;); }, false); 在 vue 中使用&lt;button @touchstart=&quot;handleTouchstart()&quot;&gt;点击&lt;/button&gt; 开源解决方案中，也是既提供了 click 事件，又提供了touchstart 事件。如 vant 中的 button 组件 那么，是否可以将 click 事件全部替换成 touchstart 呢？为什么开源框架还会给出 click 事件呢？ 我们想象一种情景，同时需要点击和滑动的场景下。如果将 click 替换成 touchstart 会怎样？ 事件触发顺序: touchstart, touchmove, touchend, click。很容易想象，在我需要touchmove滑动时候，优先触发了touchstart的点击事件，是不是已经产生了冲突呢？ 所以呢，在具有滚动的情况下，还是建议使用 click 处理。 在接下来的fastclick开源库中也做了如下处理。针对 touchstart 和 touchend，截取了部分源码。 scrollParent = targetElement.fastClickScrollParent; if (scrollParent &amp;&amp; scrollParent.fastClickLastScrollTop !== scrollParent.scrollTop) { return true; } 主要目的就是，在使用 touchstart 合成 click 事件时，保证其不在滚动的父元素之下。 解决方案二：使用 fastclick 库使用 npm/yarn 安装后使用 import FastClick from &#39;fastclick&#39;; FastClick.attach(document.body, options); 同样，使用fastclick库后，click 延时和穿透问题都没了 按照我的惯例，只要涉及开源库，那么我们一定要去了解它实现的原理。主要是将现有的原生事件集合封装合成一个兼容性较强的事件集合。 fastclick源码 核心代码不长， 1000 行不到。有兴趣可以了解一下! 软键盘将页面顶起来、收起未回落问题表现Android 手机中，点击 input 框时，键盘弹出，将页面顶起来，导致页面样式错乱。 移开焦点时，键盘收起，键盘区域空白，未回落。 产生原因我们在app 布局中会有个固定的底部。安卓一些版本中，输入弹窗出来，会将解压 absolute 和 fixed 定位的元素。导致可视区域变小，布局错乱。 原理与解决方案软键盘将页面顶起来的解决方案，主要是通过监听页面高度变化，强制恢复成弹出前的高度。 // 记录原有的视口高度 const originalHeight = document.body.clientHeight || document.documentElement.clientHeight; window.onresize = function(){ var resizeHeight = document.documentElement.clientHeight || document.body.clientHeight; if(resizeHeight &lt; originalHeight ){ // 恢复内容区域高度 // const container = document.getElementById(&quot;container&quot;) // 例如 container.style.height = originalHeight; } } 键盘不能回落问题出现在 iOS 12+ 和 wechat 6.7.4+ 中，而在微信 H5 开发中是比较常见的 Bug。 兼容原理，1.判断版本类型 2.更改滚动的可视区域const isWechat = window.navigator.userAgent.match(/MicroMessenger\\/([\\d\\.]+)/i); if (!isWechat) return; const wechatVersion = wechatInfo[1]; const version = (navigator.appVersion).match(/OS (\\d+)_(\\d+)_?(\\d+)?/); // 如果设备类型为iOS 12+ 和wechat 6.7.4+，恢复成原来的视口 if (+wechatVersion.replace(/\\./g, &#39;&#39;) &gt;= 674 &amp;&amp; +version[1] &gt;= 12) { window.scrollTo(0, Math.max(document.body.clientHeight, document.documentElement.clientHeight)); } window.scrollTo(x-coord, y-coord)，其中window.scrollTo(0, clientHeight)恢复成原来的视口 iPhone X系列安全区域适配问题表现头部刘海两侧区域或者底部区域，出现刘海遮挡文字，或者呈现黑底或白底空白区域。 产生原因iPhone X 以及它以上的系列，都采用刘海屏设计和全面屏手势。头部、底部、侧边都需要做特殊处理。才能适配 iPhone X 的特殊情况。 解决方案设置安全区域，填充危险区域，危险区域不做操作和内容展示。 危险区域指头部不规则区域，底部横条区域，左右触发区域。具体操作为：viewport-fit meta 标签设置为 cover，获取所有区域填充。判断设备是否属于 iPhone X，给头部底部增加适配层 viewport-fit 有 3 个值分别为： auto：此值不影响初始布局视图端口，并且整个web页面都是可查看的。 contain：视图端口按比例缩放，以适合显示内嵌的最大矩形。 cover：视图端口被缩放以填充设备显示。强烈建议使用 safe area inset 变量，以确保重要内容不会出现在显示之外 设置 viewport-fit 为 cover&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, user-scalable=yes, viewport-fit=cover&quot;&gt; 增加适配层 使用 safe area inset 变量 /* 适配 iPhone X 顶部填充*/ @supports (top: env(safe-area-inset-top)){ body, .header{ padding-top: constant(safe-area-inset-top, 40px); padding-top: env(safe-area-inset-top, 40px); padding-top: var(safe-area-inset-top, 40px); } } /* 判断iPhoneX 将 footer 的 padding-bottom 填充到最底部 */ @supports (bottom: env(safe-area-inset-bottom)){ body, .footer{ padding-bottom: constant(safe-area-inset-bottom, 20px); padding-bottom: env(safe-area-inset-bottom, 20px); padding-top: var(safe-area-inset-bottom, 20px); } } safe-area-inset-top, safe-area-inset-right, safe-area-inset-bottom, safe-area-inset-left safe-area-inset-*由四个定义了视口边缘内矩形的 top, right, bottom 和 left 的环境变量组成，这样可以安全地放入内容，而不会有被非矩形的显示切断的风险。对于矩形视口，例如普通的笔记本电脑显示器，其值等于零。对于非矩形显示器（如圆形表盘，iPhoneX 屏幕），在用户代理设置的四个值形成的矩形内，所有内容均可见。 其中 env() 用法为 env( , ? )，第一个参数为自定义的区域，第二个为备用值。 其中 var() 用法为 var( , ? )，作用是在 env() 不生效的情况下，给出一个备用值。 constant（） 被 css 2017-2018 年为草稿阶段，是否已被标准化未知。而其他iOS 浏览器版本中是否有此函数未知，作为兼容处理而添加进去。 页面生成为图片和二维码问题表现在工作中有需要将页面生成图片或者二维码的需求。可能我们第一想到的，交给后端来生成更简单。但是这样我们需要把页面代码全部传给后端，网络性能消耗太大。 解决方案生成二维码使用 QRCode 生成二维码 import QRCode from &#39;qrcode&#39;; // 使用 async 生成图片 const options = {}; const url = window.location.href; async url =&gt; { try { console.log(await QRCode.toDataURL(url, options)) } catch (err) { console.error(err); } } 将 await QRCode.toDataURL(url, options) 赋值给 图片 url 即可 生成图片主要是使用 htmlToCanvas 生成 canvas 画布 import html2canvas from &#39;html2canvas&#39;; html2canvas(document.body).then(function(canvas) { document.body.appendChild(canvas); }); 但是不单单在此处就完了，由于是 canvas 的原因。移动端生成出来的图片比较模糊。 我们使用一个新的 canvas 方法多倍生成，放入一倍容器里面，达到更加清晰的效果，通过超链接下载图片 下载文件简单实现，更完整的实现方式之后更新 const scaleSize = 2; const newCanvas = document.createElement(&quot;canvas&quot;); const target = document.querySelector(&#39;div&#39;); const width = parseInt(window.getComputedStyle(target).width); const height = parseInt(window.getComputedStyle(target).height); newCanvas.width = width * scaleSize; newCanvas.height = widthh * scaleSize; newCanvas.style.width = width + &quot;px&quot;; newCanvas.style.height =width + &quot;px&quot;; const context = newCanvas.getContext(&quot;2d&quot;); context.scale(scaleSize, scaleSize); html2canvas(document.querySelector(&#39;.demo&#39;), { canvas: newCanvas }).then(function(canvas) { // 简单的通过超链接设置下载功能 document.querySelector(&quot;.btn&quot;).setAttribute(&#39;href&#39;, canvas.toDataURL()); } 根据需要设置 scaleSize 大小 H5 调试相关方案策略表现调试代码一般就是为了查看数据和定位 bug。分为两种场景，一种是开发和测试时调试，一种是生产环境上调试。 为什么有生产环境上调试呢？有些时候测试环境上没法复现这个 bug，测试环境和生产环境不一致，此时就需要紧急生产调试。 在 PC 端开发时，我们可以直接掉出控制台，使用浏览器提供的工具操作devtools或者查看日志。但是在 App 内部我们怎么做呢？ 原理与解决方案1. vconsole 控制台插件使用方法也很简单 import Vconsole from &#39;vconsole&#39; new Vconsole() 有兴趣看看它实现的基本原理，我们关注的点应该在 vsconsole 如何打印出我们所有 log 的 腾讯开源vconsole 上述方法仅用于开发和测试。生产环境中不允许出现，所以，使用时需要对环境进行判断。 import Vconsole from &#39;vconsole&#39; if (process.env.NODE_ENV !== &#39;production&#39;) { new Vconsole() } 2. 代理 + spy-debugger操作稍微有点麻烦，不过我会详细写出，大致分为 4 个步骤 安装插件(全局安装)sudo npm install spy-debugger -g 手机与电脑置于同一 wifi 下，手机设置代理设置手机的 HTTP 代理，代理 IP 地址设置为 PC 的 IP 地址，端口为spy-debugger的启动端口 spy-debugger 默认端口：9888 Android ：设置 - WLAN - 长按选中网络 - 修改网络 - 高级 - 代理设置 - 手动 IOS ：设置 - Wi-Fi - 选中网络, 点击感叹号, HTTP 代理手动 手机打开浏览器或者 app 中 H5 页面打开桌面日志网站进行调试，点击 npm 控制台监听地址。查看抓包和 H5 页面结构这种方式可以调试生成环境的页面，不需要修改代码，可以应付大多数调试需求","content":"<h3 id=\"适配方案\"><a href=\"#适配方案\" class=\"headerlink\" title=\"适配方案\"></a>适配方案</h3><p>这个项目里用的是 rem 适配方案，通过计算 设备宽度/设计稿宽度 的比例，来设置 html 的 font-size 属性，达到适配的目的，代码如下：</p>\n<pre><code>function setSize() {\n  // 设备宽度\n  let deviceWidth = window.screen.width;\n  // 设计稿宽度\n  const baseValue = 750;\n  // html的字体大小 = (设备宽度 / 设计稿宽度) * 100\n  document.documentElement.style.fontSize = (deviceWidth / baseValue) * 100 + &#39;px&#39;;\n}\n\n// DOM树加载完执行\nwindow.addEventListener(&quot;DOMContentLoaded&quot;, function () {\n  setSize();\n})\n\n// 屏幕变化就执行\nwindow.addEventListener(&quot;resize&quot;, function () {\n  setSize();\n})\n\nsetSize();\n</code></pre><h3 id=\"资源的预加载\"><a href=\"#资源的预加载\" class=\"headerlink\" title=\"资源的预加载\"></a>资源的预加载</h3><p>资源的预加载用的是 preloadjs<br>中文官网：www.createjs.cc/preloadjs<br>用法也是极其简单：</p>\n<pre><code>var queue = new window.createjs.LoadQueue(true);\n  queue.on(&quot;complete&quot;, this.allLoadComplete);  // 所有文件加载完成时触发\n  queue.on(&quot;fileload&quot;, this.aloneLoadComplete);  // 单个文件加载完成时触发\n  queue.on(&quot;progress&quot;, this.fileProgress);  // 加载进度\n  queue.loadManifest(allImg);  // 需要加载的资源数组\n  queue.load()\n</code></pre><h3 id=\"如何解决需要引入很多图片的问题\"><a href=\"#如何解决需要引入很多图片的问题\" class=\"headerlink\" title=\"如何解决需要引入很多图片的问题\"></a>如何解决需要引入很多图片的问题</h3><p>这里用到了 webpack 的 api: require.context，当项目需要引入很多资源时，这项技术是必须要掌握的<br>可以阅读 使用require.context自动导入ES模块 - yeyan1996 这位大佬的文章，本文不做深入探讨</p>\n<h3 id=\"html2canvas-截取页面时图片模糊\"><a href=\"#html2canvas-截取页面时图片模糊\" class=\"headerlink\" title=\"html2canvas 截取页面时图片模糊\"></a>html2canvas 截取页面时图片模糊</h3><p>如果截取的区域里有涉及到图片，不要用 background 设置图片，全部替换成 img 标签<br>这样可以大大提升图片的清晰度</p>\n<h3 id=\"ios-键盘会把页面顶上去-不会自动下来\"><a href=\"#ios-键盘会把页面顶上去-不会自动下来\" class=\"headerlink\" title=\"ios 键盘会把页面顶上去 不会自动下来\"></a>ios 键盘会把页面顶上去 不会自动下来</h3><p>问题描述：移动端 ios 键盘弹起后，会把页面顶上去，输入完成后页面不会自动下来<br>解决办法：</p>\n<pre><code>document.body.addEventListener(&#39;focusout&#39;, function () {\n    window.scrollTo(0,0);\n});\n</code></pre><p>当监听到 body 里有元素失去焦点时，就把页面滚上去</p>\n<blockquote>\n<p>focusout: 当元素即将失去焦点时，focusout 事件被触发。focusout 事件和 blur 事件之间的主要区别在于后者不会冒泡<br>—— MDN</p>\n<h3 id=\"滑动加载以及获取body实际高度的坑\"><a href=\"#滑动加载以及获取body实际高度的坑\" class=\"headerlink\" title=\"滑动加载以及获取body实际高度的坑\"></a>滑动加载以及获取body实际高度的坑</h3><p>滑动加载的关键就是如果页面滑动到了底部，就进行数据的请求，要事先和后端沟通好数据怎么返回<br>滑动到页面底部的条件：滚动条离顶部的距离（document.body.scrollTop）+ 窗口的文档显示区的高度（window.innerHeight）&gt;= 文档实际高度（document.body.scrollHeight）<br>这里有个坑，关于获取文档实际高度的：<br>document.body.scrollHeight 可以在手机上获取到实际文档高度，但在 chrome 里获取到的高度是 0<br>document.documentElement.scrollHeight 在 chrome 里可以获取到正常的，但在手机上获取的高度是 0<br>这样的话，还要判断当前设备是手机还是 pc 然后再去获取吗，No No No，有个优雅的写法：</p>\n<pre><code>// 获取文档实际高度/移动端\nvar bodyHeight = Math.max(\n  document.documentElement.scrollHeight,\n  document.body.scrollHeight\n);\n</code></pre></blockquote>\n<h3 id=\"去除-iphone-x-的小尾巴\"><a href=\"#去除-iphone-x-的小尾巴\" class=\"headerlink\" title=\"去除 iphone x 的小尾巴\"></a>去除 iphone x 的小尾巴</h3><p>大家管这玩意叫胡子，我比较喜欢叫小尾巴~，就是 iphone x 下面那一根玩意<br>想要了解更多请点击：imweb.io/topic/5baa3…<br>我在这里就说说我是怎么用的<br>在 meta 标签里加上 viewport-fit=cover</p>\n<pre><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover&quot; /&gt;\n</code></pre><p>然后在底部的样式里加上样式：</p>\n<pre><code>bottom: env(safe-area-inset-bottom);\nbottom: 0;  // 这一句也要加上\n</code></pre><p>没有小尾巴的机型需要用到这个样式<br>这里的 safe-area-inset-bottom 的意思是：在 Viewport底部的安全区域内设置量（CSS像素），更多方向看下图</p>\n<h3 id=\"ios-最新版系统-微信浏览器-html2canvas-生成图片失败\"><a href=\"#ios-最新版系统-微信浏览器-html2canvas-生成图片失败\" class=\"headerlink\" title=\"ios 最新版系统 微信浏览器 html2canvas 生成图片失败\"></a>ios 最新版系统 微信浏览器 html2canvas 生成图片失败</h3><p>这个项目里有个生成图片的功能，需要保存用户操作过的一些东西，其他设备都正常，唯独 ios 最新版的系统有问题<br>debug 了一波后发现，这他瞄的根本没有执行这个函数，找一半天也没找到为什么，后来看 issues 发现有人说把版本换成 rc.4 的就可以了<br>issues：github.com/niklasvh/ht…</p>\n<h3 id=\"emoji-表情转码\"><a href=\"#emoji-表情转码\" class=\"headerlink\" title=\"emoji 表情转码\"></a>emoji 表情转码</h3><p>项目测试的时候，发现 textarea 标签里可以输入表情，紧接着，接口就报错了，一查看，虽然支持输入表情，但是不会自动对表情转码，所以提交接口的时候报错了，下面分享个 emoji 表情转字符的方法：</p>\n<pre><code>// 表情转字符\nutf16toEntities(str) {\n  var patt = /[\\ud800-\\udbff][\\udc00-\\udfff]/g // 检测utf16字符正则\n  str = str.replace(patt, function(char) {\n    var H, L, code\n    if (char.length === 2) {\n      H = char.charCodeAt(0) // 取出高位\n      L = char.charCodeAt(1) // 取出低位\n      code = (H - 0xd800) * 0x400 + 0x10000 + L - 0xdc00 // 转换算法\n      return &#39;&amp;#&#39; + code + &#39;;&#39;\n    } else {\n      return char\n    }\n  })\n  return str\n}\n</code></pre><h3 id=\"iOS-的-webview-中-滑动不流畅\"><a href=\"#iOS-的-webview-中-滑动不流畅\" class=\"headerlink\" title=\"iOS 的 webview 中 滑动不流畅\"></a>iOS 的 webview 中 滑动不流畅</h3><h4 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h4><p>1.在滚动容器上增加滚动 touch 方法</p>\n<p>将-webkit-overflow-scrolling 值设置为 touch</p>\n<pre><code>.wrapper {\n    -webkit-overflow-scrolling: touch;\n}\n</code></pre><p>设置滚动条隐藏： .container</p>\n<pre><code>::-webkit-scrollbar {display: none;}\n</code></pre><p>可能会导致使用position:fixed; 固定定位的元素，随着页面一起滚动</p>\n<p>2.设置 overflow</p>\n<p>设置外部 overflow 为 hidden,设置内容元素 overflow 为 auto。内部元素超出 body 即产生滚动，超出的部分 body 隐藏。</p>\n<pre><code>body {\n    overflow-y: hidden;\n}\n.wrapper {\n    overflow-y: auto;\n}\n</code></pre><blockquote>\n<p>两者结合使用更佳！</p>\n</blockquote>\n<h3 id=\"iOS-上拉边界下拉出现白色空白\"><a href=\"#iOS-上拉边界下拉出现白色空白\" class=\"headerlink\" title=\"iOS 上拉边界下拉出现白色空白\"></a>iOS 上拉边界下拉出现白色空白</h3><h4 id=\"表现\"><a href=\"#表现\" class=\"headerlink\" title=\"表现\"></a>表现</h4><p>手指按住屏幕下拉，屏幕顶部会多出一块白色区域。手指按住屏幕上拉，底部多出一块白色区域。</p>\n<h4 id=\"产生原因\"><a href=\"#产生原因\" class=\"headerlink\" title=\"产生原因\"></a>产生原因</h4><p>在 iOS 中，手指按住屏幕上下拖动，会触发 touchmove 事件。这个事件触发的对象是整个 webview 容器，容器自然会被拖动，剩下的部分会成空白。</p>\n<h4 id=\"解决方案-1\"><a href=\"#解决方案-1\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h4><ol>\n<li>监听事件禁止滑动</li>\n</ol>\n<p>移动端触摸事件有三个，分别定义为</p>\n<pre><code>1. touchstart ：手指放在一个DOM元素上。\n2. touchmove ：手指拖曳一个DOM元素。\n3. touchend ：手指从一个DOM元素上移开。\n</code></pre><p>touchmove 事件的速度是可以实现定义的，取决于硬件性能和其他实现细节</p>\n<p>preventDefault 方法，阻止同一触点上所有默认行为，比如滚动。</p>\n<p>由此我们找到解决方案，通过监听 touchmove，让需要滑动的地方滑动，不需要滑动的地方禁止滑动。</p>\n<p>值得注意的是我们要过滤掉具有滚动容器的元素</p>\n<h5 id=\"实现如下：\"><a href=\"#实现如下：\" class=\"headerlink\" title=\"实现如下：\"></a>实现如下：</h5><pre><code>document.body.addEventListener(&#39;touchmove&#39;, function(e) {\n    if(e._isScroller) return;\n    // 阻止默认事件\n    e.preventDefault();\n}, {\n    passive: false\n})\n</code></pre><h3 id=\"click-点击事件延时与穿透\"><a href=\"#click-点击事件延时与穿透\" class=\"headerlink\" title=\"click 点击事件延时与穿透\"></a>click 点击事件延时与穿透</h3><h4 id=\"表现-1\"><a href=\"#表现-1\" class=\"headerlink\" title=\"表现\"></a>表现</h4><p>监听元素 click 事件，点击元素触发时间延迟约 300ms。</p>\n<p>点击蒙层，蒙层消失后，下层元素点击触发。</p>\n<h4 id=\"产生原因-1\"><a href=\"#产生原因-1\" class=\"headerlink\" title=\"产生原因\"></a>产生原因</h4><p>为什么会产生 click 延时？</p>\n<p>iOS 中的 safari，为了实现双击缩放操作，在单击 300ms 之后，如果未进行第二次点击，则执行 click 单击操作。也就是说来判断用户行为是否为双击产生的。但是，在 App 中，无论是否需要双击缩放这种行为，click 单击都会产生 300ms 延迟。</p>\n<h4 id=\"为什么会产生-click-点击穿透？\"><a href=\"#为什么会产生-click-点击穿透？\" class=\"headerlink\" title=\"为什么会产生 click 点击穿透？\"></a>为什么会产生 click 点击穿透？</h4><p>双层元素叠加时，在上层元素上绑定 touch 事件，下层元素绑定 click 事件。由于 click 发生在 touch 之后，点击上层元素，元素消失，下层元素会触发 click 事件，由此产生了点击穿透的效果。</p>\n<h4 id=\"原理与解决方案\"><a href=\"#原理与解决方案\" class=\"headerlink\" title=\"原理与解决方案\"></a>原理与解决方案</h4><p>解决方案一：使用 touchstart 替换 click</p>\n<p>前面已经介绍了，移动设备不仅支持点击，还支持几个触摸事件。那么我们现在基本思路就是用 touch 事件代替click 事件。</p>\n<p>将 click 替换成 touchstart 不仅解决了 click 事件都延时问题，还解决了穿透问题。因为穿透问题是在 touch 和 click 混用时产生。</p>\n<h5 id=\"在原生中使用\"><a href=\"#在原生中使用\" class=\"headerlink\" title=\"在原生中使用\"></a>在原生中使用</h5><pre><code>el.addEventListener(&quot;touchstart&quot;, () =&gt; { console.log(&quot;ok&quot;); }, false);\n</code></pre><h5 id=\"在-vue-中使用\"><a href=\"#在-vue-中使用\" class=\"headerlink\" title=\"在 vue 中使用\"></a>在 vue 中使用</h5><pre><code>&lt;button @touchstart=&quot;handleTouchstart()&quot;&gt;点击&lt;/button&gt;\n</code></pre><p>开源解决方案中，也是既提供了 click 事件，又提供了touchstart 事件。如 vant 中的 button 组件</p>\n<p>那么，是否可以将 click 事件全部替换成 touchstart 呢？为什么开源框架还会给出 click 事件呢？</p>\n<p>我们想象一种情景，同时需要点击和滑动的场景下。如果将 click 替换成 touchstart 会怎样？</p>\n<p>事件触发顺序: touchstart, touchmove, touchend, click。<br>很容易想象，在我需要touchmove滑动时候，优先触发了touchstart的点击事件，是不是已经产生了冲突呢？</p>\n<p>所以呢，在具有滚动的情况下，还是建议使用 click 处理。</p>\n<p>在接下来的fastclick开源库中也做了如下处理。针对 touchstart 和 touchend，截取了部分源码。</p>\n<pre><code>scrollParent = targetElement.fastClickScrollParent;\nif (scrollParent &amp;&amp; scrollParent.fastClickLastScrollTop !== scrollParent.scrollTop) {\nreturn true;\n}\n</code></pre><p>主要目的就是，在使用 touchstart 合成 click 事件时，保证其不在滚动的父元素之下。</p>\n<h4 id=\"解决方案二：使用-fastclick-库\"><a href=\"#解决方案二：使用-fastclick-库\" class=\"headerlink\" title=\"解决方案二：使用 fastclick 库\"></a>解决方案二：使用 fastclick 库</h4><p>使用 npm/yarn 安装后使用</p>\n<pre><code>import FastClick from &#39;fastclick&#39;;\n\nFastClick.attach(document.body, options);\n</code></pre><p>同样，使用fastclick库后，click 延时和穿透问题都没了</p>\n<p>按照我的惯例，只要涉及开源库，那么我们一定要去了解它实现的原理。主要是将现有的原生事件集合封装合成一个兼容性较强的事件集合。</p>\n<p>fastclick源码 核心代码不长， 1000 行不到。有兴趣可以了解一下!</p>\n<h3 id=\"软键盘将页面顶起来、收起未回落问题\"><a href=\"#软键盘将页面顶起来、收起未回落问题\" class=\"headerlink\" title=\"软键盘将页面顶起来、收起未回落问题\"></a>软键盘将页面顶起来、收起未回落问题</h3><h4 id=\"表现-2\"><a href=\"#表现-2\" class=\"headerlink\" title=\"表现\"></a>表现</h4><p>Android 手机中，点击 input 框时，键盘弹出，将页面顶起来，导致页面样式错乱。</p>\n<p>移开焦点时，键盘收起，键盘区域空白，未回落。</p>\n<h4 id=\"产生原因-2\"><a href=\"#产生原因-2\" class=\"headerlink\" title=\"产生原因\"></a>产生原因</h4><p>我们在app 布局中会有个固定的底部。安卓一些版本中，输入弹窗出来，会将解压 absolute 和 fixed 定位的元素。导致可视区域变小，布局错乱。</p>\n<h4 id=\"原理与解决方案-1\"><a href=\"#原理与解决方案-1\" class=\"headerlink\" title=\"原理与解决方案\"></a>原理与解决方案</h4><p>软键盘将页面顶起来的解决方案，主要是通过监听页面高度变化，强制恢复成弹出前的高度。</p>\n<pre><code>// 记录原有的视口高度\nconst originalHeight = document.body.clientHeight || document.documentElement.clientHeight;\n\nwindow.onresize = function(){\n  var resizeHeight = document.documentElement.clientHeight || document.body.clientHeight;\n  if(resizeHeight &lt; originalHeight ){\n    // 恢复内容区域高度\n    // const container = document.getElementById(&quot;container&quot;)\n    // 例如 container.style.height = originalHeight;\n  }\n}\n</code></pre><p>键盘不能回落问题出现在 iOS 12+ 和 wechat 6.7.4+ 中，而在微信 H5 开发中是比较常见的 Bug。</p>\n<h4 id=\"兼容原理，1-判断版本类型-2-更改滚动的可视区域\"><a href=\"#兼容原理，1-判断版本类型-2-更改滚动的可视区域\" class=\"headerlink\" title=\"兼容原理，1.判断版本类型 2.更改滚动的可视区域\"></a>兼容原理，1.判断版本类型 2.更改滚动的可视区域</h4><pre><code>const isWechat = window.navigator.userAgent.match(/MicroMessenger\\/([\\d\\.]+)/i);\nif (!isWechat) return;\nconst wechatVersion = wechatInfo[1];\nconst version = (navigator.appVersion).match(/OS (\\d+)_(\\d+)_?(\\d+)?/);\n\n // 如果设备类型为iOS 12+ 和wechat 6.7.4+，恢复成原来的视口\nif (+wechatVersion.replace(/\\./g, &#39;&#39;) &gt;= 674 &amp;&amp; +version[1] &gt;= 12) {\n  window.scrollTo(0, Math.max(document.body.clientHeight, document.documentElement.clientHeight));\n}\n</code></pre><blockquote>\n<p>window.scrollTo(x-coord, y-coord)，其中window.scrollTo(0, clientHeight)恢复成原来的视口</p>\n</blockquote>\n<h3 id=\"iPhone-X系列安全区域适配问题\"><a href=\"#iPhone-X系列安全区域适配问题\" class=\"headerlink\" title=\"iPhone X系列安全区域适配问题\"></a>iPhone X系列安全区域适配问题</h3><h4 id=\"表现-3\"><a href=\"#表现-3\" class=\"headerlink\" title=\"表现\"></a>表现</h4><p>头部刘海两侧区域或者底部区域，出现刘海遮挡文字，或者呈现黑底或白底空白区域。</p>\n<h4 id=\"产生原因-3\"><a href=\"#产生原因-3\" class=\"headerlink\" title=\"产生原因\"></a>产生原因</h4><p>iPhone X 以及它以上的系列，都采用刘海屏设计和全面屏手势。头部、底部、侧边都需要做特殊处理。才能适配 iPhone X 的特殊情况。</p>\n<h4 id=\"解决方案-2\"><a href=\"#解决方案-2\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h4><p>设置安全区域，填充危险区域，危险区域不做操作和内容展示。</p>\n<blockquote>\n<p>危险区域指头部不规则区域，底部横条区域，左右触发区域。<br>具体操作为：viewport-fit meta 标签设置为 cover，获取所有区域填充。判断设备是否属于 iPhone X，给头部底部增加适配层</p>\n</blockquote>\n<h4 id=\"viewport-fit-有-3-个值分别为：\"><a href=\"#viewport-fit-有-3-个值分别为：\" class=\"headerlink\" title=\"viewport-fit 有 3 个值分别为：\"></a>viewport-fit 有 3 个值分别为：</h4><ul>\n<li>auto：此值不影响初始布局视图端口，并且整个web页面都是可查看的。</li>\n<li>contain：视图端口按比例缩放，以适合显示内嵌的最大矩形。</li>\n<li>cover：视图端口被缩放以填充设备显示。强烈建议使用 safe area inset 变量，以确保重要内容不会出现在显示之外</li>\n</ul>\n<h4 id=\"设置-viewport-fit-为-cover\"><a href=\"#设置-viewport-fit-为-cover\" class=\"headerlink\" title=\"设置 viewport-fit 为 cover\"></a>设置 viewport-fit 为 cover</h4><pre><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, user-scalable=yes, viewport-fit=cover&quot;&gt;\n</code></pre><p>增加适配层</p>\n<p>使用 safe area inset 变量</p>\n<pre><code>/* 适配 iPhone X 顶部填充*/\n@supports (top: env(safe-area-inset-top)){\n  body,\n  .header{\n      padding-top: constant(safe-area-inset-top, 40px);\n      padding-top: env(safe-area-inset-top, 40px);\n      padding-top: var(safe-area-inset-top, 40px);\n  }\n}\n/* 判断iPhoneX 将 footer 的 padding-bottom 填充到最底部 */\n@supports (bottom: env(safe-area-inset-bottom)){\n    body,\n    .footer{\n        padding-bottom: constant(safe-area-inset-bottom, 20px);\n        padding-bottom: env(safe-area-inset-bottom, 20px);\n        padding-top: var(safe-area-inset-bottom, 20px);\n    }\n}\n</code></pre><blockquote>\n<p>safe-area-inset-top, safe-area-inset-right, safe-area-inset-bottom, safe-area-inset-left safe-area-inset-*由四个定义了视口边缘内矩形的 top, right, bottom 和 left 的环境变量组成，这样可以安全地放入内容，而不会有被非矩形的显示切断的风险。对于矩形视口，例如普通的笔记本电脑显示器，其值等于零。对于非矩形显示器（如圆形表盘，iPhoneX 屏幕），在用户代理设置的四个值形成的矩形内，所有内容均可见。</p>\n</blockquote>\n<p>其中 env() 用法为 env( <custom-ident> , <declaration-value>? )，第一个参数为自定义的区域，第二个为备用值。</p>\n<p>其中 var() 用法为 var( <custom-property-name> , <declaration-value>? )，作用是在 env() 不生效的情况下，给出一个备用值。</p>\n<p>constant（） 被 css 2017-2018 年为草稿阶段，是否已被标准化未知。而其他iOS 浏览器版本中是否有此函数未知，作为兼容处理而添加进去。</p>\n<h3 id=\"页面生成为图片和二维码问题\"><a href=\"#页面生成为图片和二维码问题\" class=\"headerlink\" title=\"页面生成为图片和二维码问题\"></a>页面生成为图片和二维码问题</h3><h4 id=\"表现-4\"><a href=\"#表现-4\" class=\"headerlink\" title=\"表现\"></a>表现</h4><p>在工作中有需要将页面生成图片或者二维码的需求。可能我们第一想到的，交给后端来生成更简单。但是这样我们需要把页面代码全部传给后端，网络性能消耗太大。</p>\n<h4 id=\"解决方案-3\"><a href=\"#解决方案-3\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h4><h4 id=\"生成二维码\"><a href=\"#生成二维码\" class=\"headerlink\" title=\"生成二维码\"></a>生成二维码</h4><p>使用 QRCode 生成二维码</p>\n<pre><code>import QRCode from &#39;qrcode&#39;;\n// 使用 async 生成图片\nconst options = {};\nconst url = window.location.href;\nasync url =&gt; {\n  try {\n    console.log(await QRCode.toDataURL(url, options))\n  } catch (err) {\n    console.error(err);\n  }\n}\n</code></pre><p>将 await QRCode.toDataURL(url, options) 赋值给 图片 url 即可</p>\n<h4 id=\"生成图片\"><a href=\"#生成图片\" class=\"headerlink\" title=\"生成图片\"></a>生成图片</h4><p>主要是使用 htmlToCanvas 生成 canvas 画布</p>\n<pre><code>import html2canvas from &#39;html2canvas&#39;;\n\nhtml2canvas(document.body).then(function(canvas) {\n    document.body.appendChild(canvas);\n});\n</code></pre><p>但是不单单在此处就完了，由于是 canvas 的原因。移动端生成出来的图片比较模糊。</p>\n<p>我们使用一个新的 canvas 方法多倍生成，放入一倍容器里面，达到更加清晰的效果，通过超链接下载图片 下载文件简单实现，更完整的实现方式之后更新</p>\n<pre><code>const scaleSize = 2;\nconst newCanvas = document.createElement(&quot;canvas&quot;);\nconst target = document.querySelector(&#39;div&#39;);\nconst width = parseInt(window.getComputedStyle(target).width);\nconst height = parseInt(window.getComputedStyle(target).height);\nnewCanvas.width = width * scaleSize;\nnewCanvas.height = widthh * scaleSize;\nnewCanvas.style.width = width + &quot;px&quot;;\nnewCanvas.style.height =width + &quot;px&quot;;\nconst context = newCanvas.getContext(&quot;2d&quot;);\ncontext.scale(scaleSize, scaleSize);\nhtml2canvas(document.querySelector(&#39;.demo&#39;), { canvas: newCanvas }).then(function(canvas) {\n  // 简单的通过超链接设置下载功能\n  document.querySelector(&quot;.btn&quot;).setAttribute(&#39;href&#39;, canvas.toDataURL());\n}\n</code></pre><blockquote>\n<p>根据需要设置 scaleSize 大小</p>\n</blockquote>\n<h3 id=\"H5-调试相关方案策略\"><a href=\"#H5-调试相关方案策略\" class=\"headerlink\" title=\"H5 调试相关方案策略\"></a>H5 调试相关方案策略</h3><h4 id=\"表现-5\"><a href=\"#表现-5\" class=\"headerlink\" title=\"表现\"></a>表现</h4><p>调试代码一般就是为了查看数据和定位 bug。分为两种场景，一种是开发和测试时调试，一种是生产环境上调试。</p>\n<blockquote>\n<p>为什么有生产环境上调试呢？有些时候测试环境上没法复现这个 bug，测试环境和生产环境不一致，此时就需要紧急生产调试。</p>\n</blockquote>\n<p>在 PC 端开发时，我们可以直接掉出控制台，使用浏览器提供的工具操作devtools或者查看日志。但是在 App 内部我们怎么做呢？</p>\n<h4 id=\"原理与解决方案-2\"><a href=\"#原理与解决方案-2\" class=\"headerlink\" title=\"原理与解决方案\"></a>原理与解决方案</h4><h4 id=\"1-vconsole-控制台插件\"><a href=\"#1-vconsole-控制台插件\" class=\"headerlink\" title=\"1. vconsole 控制台插件\"></a>1. vconsole 控制台插件</h4><p>使用方法也很简单</p>\n<pre><code>import Vconsole from &#39;vconsole&#39;\n\nnew Vconsole()\n</code></pre><p>有兴趣看看它实现的基本原理，我们关注的点应该在 vsconsole 如何打印出我们所有 log 的 腾讯开源vconsole</p>\n<p>上述方法仅用于开发和测试。生产环境中不允许出现，所以，使用时需要对环境进行判断。</p>\n<pre><code>import Vconsole from &#39;vconsole&#39;\nif (process.env.NODE_ENV !== &#39;production&#39;) {\n    new Vconsole()\n}\n</code></pre><h4 id=\"2-代理-spy-debugger\"><a href=\"#2-代理-spy-debugger\" class=\"headerlink\" title=\"2. 代理 + spy-debugger\"></a>2. 代理 + spy-debugger</h4><p>操作稍微有点麻烦，不过我会详细写出，大致分为 4 个步骤</p>\n<h4 id=\"安装插件-全局安装\"><a href=\"#安装插件-全局安装\" class=\"headerlink\" title=\"安装插件(全局安装)\"></a>安装插件(全局安装)</h4><pre><code>sudo npm install spy-debugger -g\n</code></pre><h4 id=\"手机与电脑置于同一-wifi-下，手机设置代理\"><a href=\"#手机与电脑置于同一-wifi-下，手机设置代理\" class=\"headerlink\" title=\"手机与电脑置于同一 wifi 下，手机设置代理\"></a>手机与电脑置于同一 wifi 下，手机设置代理</h4><p>设置手机的 HTTP 代理，代理 IP 地址设置为 PC 的 IP 地址，端口为spy-debugger的启动端口</p>\n<blockquote>\n<p>spy-debugger 默认端口：9888</p>\n<p>Android ：设置 - WLAN - 长按选中网络 - 修改网络 - 高级 - 代理设置 - 手动</p>\n<p>IOS ：设置 - Wi-Fi - 选中网络, 点击感叹号, HTTP 代理手动</p>\n</blockquote>\n<h4 id=\"手机打开浏览器或者-app-中-H5-页面\"><a href=\"#手机打开浏览器或者-app-中-H5-页面\" class=\"headerlink\" title=\"手机打开浏览器或者 app 中 H5 页面\"></a>手机打开浏览器或者 app 中 H5 页面</h4><h4 id=\"打开桌面日志网站进行调试，点击-npm-控制台监听地址。查看抓包和-H5-页面结构\"><a href=\"#打开桌面日志网站进行调试，点击-npm-控制台监听地址。查看抓包和-H5-页面结构\" class=\"headerlink\" title=\"打开桌面日志网站进行调试，点击 npm 控制台监听地址。查看抓包和 H5 页面结构\"></a>打开桌面日志网站进行调试，点击 npm 控制台监听地址。查看抓包和 H5 页面结构</h4><p>这种方式可以调试生成环境的页面，不需要修改代码，可以应付大多数调试需求</p>\n","updated":"2020-05-11T03:01:58.689Z","comments":true,"link":"","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://yoursite.com/categories/前端开发/"}],"tags":[{"name":"js,htnl5","slug":"js-htnl5","permalink":"http://yoursite.com/tags/js-htnl5/"}]},{"title":"SVG绘画折线图","date":"2020-05-11T02:20:58.000Z","path":"2020/05/11/svg_line/","text":"代码如下：1.html代码： &lt;svg viewBox=&quot;0 0 200 100&quot; id=&quot;chart&quot;&gt; &lt;g transform=&quot;translate(0, 100) scale(1, -1)&quot; id=&quot;path-container&quot;&gt; &lt;path fill=&quot;none&quot; stroke-width=&quot;3&quot; stroke-linecap=&quot;round&quot; stroke-linejoin=&quot;round&quot; id=&quot;line&quot; /&gt; &lt;/g&gt; &lt;text text-anchor=&quot;middle&quot; alignment-baseline=&quot;middle&quot; x=&quot;100&quot; y=&quot;50&quot; class=&quot;loading&quot;&gt; Loading... &lt;/text&gt; &lt;/svg&gt; 2，css代码： body { display: flex; justify-content: center; align-items: center; min-height: 100vh; } #chart { background-color: #f6f6f6; width: 100%; max-width: 1000px; --stroke-length: 0; } #chart #line { stroke: #9F3AF0; stroke-dasharray: var(--stroke-length); stroke-dashoffset: var(--stroke-length); } .name, .caption { font-family: Helvetica; font-size: 4px; font-weight: bold; fill: #999; animation: .5s fade-in ease-in-out; animation-fill-mode: forwards; } .values { font-family: Helvetica; font-size: 3px; } @keyframes animate-line { from { stroke-dashoffset: var(--stroke-length); } to { stroke-dashoffset: 0; } } #chart.animate #line { animation: 3s animate-line linear; animation-fill-mode: forwards; animation-delay: .3s; } @keyframes zoom-in { from { transform: scale(0); } to { transform: scale(1); } } @keyframes fade-in { from { opacity: 0; } to { opacity: 1; } } #chart .point { opacity: 0; } #chart.animate .point { animation: .5s fade-in ease-in-out, .5s zoom-in ease-in-out; animation-fill-mode: forwards; animation-delay: var(--delay); } #chart .values { opacity: 0; } #chart.animate .values { animation: .5s fade-in ease-in-out; animation-fill-mode: forwards; animation-delay: var(--delay); } .loading { font-family: Helvetica; font-size: 5px; fill: #999; transition: .25s opacity ease-in-out; } #chart.animate .loading { opacity: 0; } 3,js代码： let padding = 15 let start_x = padding let svg_width = document.querySelector(&#39;#chart&#39;).viewBox.baseVal.width function loadData() { fetch(`https://codingstartup.com/assets/svg-chart/appl.php`) .then((response) =&gt; { return response.json() }) .then((data) =&gt; { console.log(`api data`, data) drawChart(data) }) .catch((err) =&gt; { console.log(err) }) } setTimeout(() =&gt; { loadData() }, 1000) function drawChart(api_data) { let name = document.createElementNS(&#39;http://www.w3.org/2000/svg&#39;, &#39;text&#39;) name.setAttribute(&#39;text-anchor&#39;, &#39;middle&#39;) name.setAttribute(&#39;alignment-baseline&#39;, &#39;middle&#39;) name.setAttribute(&#39;x&#39;, svg_width / 2) name.setAttribute(&#39;y&#39;, 6) name.classList.add(&#39;name&#39;) name.appendChild(document.createTextNode(api_data[&#39;stock_name&#39;])) document.querySelector(&#39;#chart&#39;).appendChild(name) let stock_data = api_data[&#39;data&#39;] let path_data = [] for (let i in stock_data) { path_data.push(`${start_x}, ${stock_data[i][&#39;normalized&#39;]}`) let caption = document.createElementNS(&#39;http://www.w3.org/2000/svg&#39;, &#39;text&#39;) caption.setAttribute(&#39;text-anchor&#39;, &#39;middle&#39;) caption.setAttribute(&#39;alignment-baseline&#39;, &#39;middle&#39;) caption.setAttribute(&#39;x&#39;, start_x) caption.setAttribute(&#39;y&#39;, 96) caption.classList.add(&#39;caption&#39;) caption.appendChild(document.createTextNode(stock_data[i][&#39;date&#39;])) document.querySelector(&#39;#chart&#39;).appendChild(caption) let circle = document.createElementNS(&#39;http://www.w3.org/2000/svg&#39;, &#39;circle&#39;) circle.setAttribute(&#39;cx&#39;, start_x) circle.setAttribute(&#39;cy&#39;, stock_data[i][&#39;normalized&#39;]) circle.setAttribute(&#39;r&#39;, 3) circle.setAttribute(&#39;stroke&#39;, &#39;#9F3AF0&#39;) circle.setAttribute(&#39;stroke-width&#39;, 2) circle.setAttribute(&#39;fill&#39;, &#39;white&#39;) circle.setAttribute(&#39;transform-origin&#39;, `${start_x} ${stock_data[i][&#39;normalized&#39;]}`) circle.style.setProperty(&#39;--delay&#39;, `${(3 * parseInt(i) / stock_data.length)}s`) circle.classList.add(&#39;point&#39;) document.querySelector(&#39;#path-container&#39;).appendChild(circle) let value = document.createElementNS(&#39;http://www.w3.org/2000/svg&#39;, &#39;text&#39;) value.setAttribute(&#39;text-anchor&#39;, &#39;middle&#39;) value.setAttribute(&#39;alignment-baseline&#39;, &#39;middle&#39;) value.setAttribute(&#39;x&#39;, start_x) value.setAttribute(&#39;y&#39;, stock_data[i][&#39;normalized&#39;]) value.setAttribute(&#39;transform&#39;, `translate(0, ${stock_data[i][&#39;normalized&#39;] * 2 - 8}) scale(1, -1)`) value.style.setProperty(&#39;--delay&#39;, `${(3 * parseInt(i) / stock_data.length)}s`) value.classList.add(&#39;values&#39;) value.appendChild(document.createTextNode(stock_data[i][&#39;index&#39;])) document.querySelector(&#39;#path-container&#39;).appendChild(value) start_x += (svg_width - padding * 2) / (stock_data.length - 1) } let line = document.querySelector(&#39;#line&#39;) line.setAttribute(&#39;d&#39;, `M${path_data.join(&#39; &#39;)}`) let strokeLength = Math.ceil(line.getTotalLength()) document.querySelector(&#39;#chart&#39;).style.setProperty(&#39;--stroke-length&#39;, strokeLength) document.querySelector(&#39;#chart&#39;).classList.add(&#39;animate&#39;) }","content":"<h3 id=\"代码如下：\"><a href=\"#代码如下：\" class=\"headerlink\" title=\"代码如下：\"></a>代码如下：</h3><p>1.html代码：</p>\n<pre><code>&lt;svg viewBox=&quot;0 0 200 100&quot; id=&quot;chart&quot;&gt;\n  &lt;g transform=&quot;translate(0, 100) scale(1, -1)&quot; id=&quot;path-container&quot;&gt;\n    &lt;path fill=&quot;none&quot; stroke-width=&quot;3&quot; stroke-linecap=&quot;round&quot; stroke-linejoin=&quot;round&quot; id=&quot;line&quot; /&gt;\n  &lt;/g&gt;\n  &lt;text text-anchor=&quot;middle&quot; alignment-baseline=&quot;middle&quot; x=&quot;100&quot; y=&quot;50&quot; class=&quot;loading&quot;&gt;\n    Loading...\n  &lt;/text&gt;\n&lt;/svg&gt;\n</code></pre><p>2，css代码：</p>\n<pre><code>body {\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  min-height: 100vh;\n}\n\n#chart {\n  background-color: #f6f6f6;\n  width: 100%;\n  max-width: 1000px;\n\n  --stroke-length: 0;\n}\n\n#chart #line {\n  stroke: #9F3AF0;\n  stroke-dasharray: var(--stroke-length);\n  stroke-dashoffset: var(--stroke-length);\n}\n\n.name, .caption {\n  font-family: Helvetica;\n  font-size: 4px;\n  font-weight: bold;\n  fill: #999;\n\n  animation: .5s fade-in ease-in-out;\n  animation-fill-mode: forwards;\n}\n\n.values {\n  font-family: Helvetica;\n  font-size: 3px;\n}\n\n@keyframes animate-line {\n  from {\n    stroke-dashoffset: var(--stroke-length);\n  }\n  to {\n    stroke-dashoffset: 0;\n  }\n}\n\n#chart.animate #line {\n  animation: 3s animate-line linear;\n  animation-fill-mode: forwards;\n  animation-delay: .3s;\n}\n\n@keyframes zoom-in {\n  from {\n    transform: scale(0);\n  }\n  to {\n    transform: scale(1);\n  }\n}\n\n@keyframes fade-in {\n  from {\n    opacity: 0;\n  }\n  to {\n    opacity: 1;\n  }\n}\n\n#chart .point {\n  opacity: 0;\n}\n\n#chart.animate .point {\n  animation: .5s fade-in ease-in-out, .5s zoom-in ease-in-out;\n  animation-fill-mode: forwards;\n  animation-delay: var(--delay);\n}\n\n#chart .values {\n  opacity: 0;\n}\n\n#chart.animate .values {\n  animation: .5s fade-in ease-in-out;\n  animation-fill-mode: forwards;\n  animation-delay: var(--delay);\n}\n\n.loading {\n  font-family: Helvetica;\n  font-size: 5px;\n  fill: #999;\n\n  transition: .25s opacity ease-in-out;\n}\n\n#chart.animate .loading {\n  opacity: 0;\n}\n</code></pre><p>3,js代码：</p>\n<pre><code>let padding = 15\nlet start_x = padding\nlet svg_width = document.querySelector(&#39;#chart&#39;).viewBox.baseVal.width\n\nfunction loadData() {\n  fetch(`https://codingstartup.com/assets/svg-chart/appl.php`)\n    .then((response) =&gt; {\n      return response.json()\n    })\n    .then((data) =&gt; {\n      console.log(`api data`, data)\n      drawChart(data)\n    })\n    .catch((err) =&gt; {\n      console.log(err)\n    })\n}\n\nsetTimeout(() =&gt; {\n  loadData()\n}, 1000)\n\nfunction drawChart(api_data) {\n  let name = document.createElementNS(&#39;http://www.w3.org/2000/svg&#39;, &#39;text&#39;)\n  name.setAttribute(&#39;text-anchor&#39;, &#39;middle&#39;)\n  name.setAttribute(&#39;alignment-baseline&#39;, &#39;middle&#39;)\n  name.setAttribute(&#39;x&#39;, svg_width / 2)\n  name.setAttribute(&#39;y&#39;, 6)\n  name.classList.add(&#39;name&#39;)\n  name.appendChild(document.createTextNode(api_data[&#39;stock_name&#39;]))\n  document.querySelector(&#39;#chart&#39;).appendChild(name)\n\n  let stock_data = api_data[&#39;data&#39;]\n  let path_data = []\n\n  for (let i in stock_data) {\n    path_data.push(`${start_x}, ${stock_data[i][&#39;normalized&#39;]}`)\n\n    let caption = document.createElementNS(&#39;http://www.w3.org/2000/svg&#39;, &#39;text&#39;)\n    caption.setAttribute(&#39;text-anchor&#39;, &#39;middle&#39;)\n    caption.setAttribute(&#39;alignment-baseline&#39;, &#39;middle&#39;)\n    caption.setAttribute(&#39;x&#39;, start_x)\n    caption.setAttribute(&#39;y&#39;, 96)\n    caption.classList.add(&#39;caption&#39;)\n    caption.appendChild(document.createTextNode(stock_data[i][&#39;date&#39;]))\n    document.querySelector(&#39;#chart&#39;).appendChild(caption)\n\n    let circle = document.createElementNS(&#39;http://www.w3.org/2000/svg&#39;, &#39;circle&#39;)\n    circle.setAttribute(&#39;cx&#39;, start_x)\n    circle.setAttribute(&#39;cy&#39;, stock_data[i][&#39;normalized&#39;])\n    circle.setAttribute(&#39;r&#39;, 3)\n    circle.setAttribute(&#39;stroke&#39;, &#39;#9F3AF0&#39;)\n    circle.setAttribute(&#39;stroke-width&#39;, 2)\n    circle.setAttribute(&#39;fill&#39;, &#39;white&#39;)\n    circle.setAttribute(&#39;transform-origin&#39;, `${start_x} ${stock_data[i][&#39;normalized&#39;]}`)\n    circle.style.setProperty(&#39;--delay&#39;, `${(3 * parseInt(i) / stock_data.length)}s`)\n    circle.classList.add(&#39;point&#39;)\n    document.querySelector(&#39;#path-container&#39;).appendChild(circle)\n\n    let value = document.createElementNS(&#39;http://www.w3.org/2000/svg&#39;, &#39;text&#39;)\n    value.setAttribute(&#39;text-anchor&#39;, &#39;middle&#39;)\n    value.setAttribute(&#39;alignment-baseline&#39;, &#39;middle&#39;)\n    value.setAttribute(&#39;x&#39;, start_x)\n    value.setAttribute(&#39;y&#39;, stock_data[i][&#39;normalized&#39;])\n    value.setAttribute(&#39;transform&#39;, `translate(0, ${stock_data[i][&#39;normalized&#39;] * 2 - 8}) scale(1, -1)`)\n    value.style.setProperty(&#39;--delay&#39;, `${(3 * parseInt(i) / stock_data.length)}s`)\n    value.classList.add(&#39;values&#39;)\n    value.appendChild(document.createTextNode(stock_data[i][&#39;index&#39;]))\n    document.querySelector(&#39;#path-container&#39;).appendChild(value)\n\n    start_x += (svg_width - padding * 2) / (stock_data.length - 1)\n  }\n\n  let line = document.querySelector(&#39;#line&#39;)\n  line.setAttribute(&#39;d&#39;, `M${path_data.join(&#39; &#39;)}`)\n  let strokeLength = Math.ceil(line.getTotalLength())\n  document.querySelector(&#39;#chart&#39;).style.setProperty(&#39;--stroke-length&#39;, strokeLength)\n\n  document.querySelector(&#39;#chart&#39;).classList.add(&#39;animate&#39;)\n}\n</code></pre>","updated":"2020-05-11T02:57:32.688Z","comments":true,"link":"","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://yoursite.com/categories/前端开发/"}],"tags":[{"name":"html5","slug":"html5","permalink":"http://yoursite.com/tags/html5/"}]},{"title":"10个Vue开发技巧","date":"2020-05-11T02:20:58.000Z","path":"2020/05/11/vue_user/","text":"1、路由参数解耦 一般在组件内使用路由参数，大多数人会这样做 export default { methods: { getParamsId() { return this.$route.params.id } } } 在组件中使用 $route 会使之与其对应路由形成高度耦合，从而使组件只能在某些特定的 URL 上使用，限制了其灵活性。 正确的做法是通过 props 解耦 const router = new VueRouter({ routes: [{ path: &#39;/user/:id&#39;, component: User, props: true }] }) 将路由的 props 属性设置为 true 后，组件内可通过 props 接收到 params 参数 export default { props: [&#39;id&#39;], methods: { getParamsId() { return this.id } } } 另外你还可以通过函数模式来返回 props const router = new VueRouter({ routes: [{ path: &#39;/user/:id&#39;, component: User, props: (route) =&gt; ({ id: route.query.id }) }] }) 2、函数式组件函数式组件是无状态，它无法实例化，没有任何的生命周期和方法。创建函数式组件也很简单，只需要在模板添加 functional 声明即可。一般适合只依赖于外部数据的变化而变化的组件，因其轻量，渲染性能也会有所提高。 组件需要的一切都是通过 context 参数传递。它是一个上下文对象，具体属性查看文档。这里 props 是一个包含所有绑定属性的对象。 函数式组件 &lt;template functional&gt; &lt;div class=&quot;list&quot;&gt; &lt;div class=&quot;item&quot; v-for=&quot;item in props.list&quot; :key=&quot;item.id&quot; @click=&quot;props.itemClick(item)&quot;&gt; &lt;p&gt;{{item.title}}&lt;/p&gt; &lt;p&gt;{{item.content}}&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; 父组件使用 &lt;template&gt; &lt;div&gt; &lt;List :list=&quot;list&quot; :itemClick=&quot;item =&gt; (currentItem = item)&quot; /&gt; &lt;/div&gt; &lt;/template&gt; import List from &#39;@/components/List.vue&#39; export default { components: { List }, data() { return { list: [{ title: &#39;title&#39;, content: &#39;content&#39; }], currentItem: &#39;&#39; } } } 3、样式穿透在开发中修改第三方组件样式是很常见，但由于 scoped 属性的样式隔离，可能需要去除 scoped 或是另起一个 style 。这些做法都会带来副作用（组件样式污染、不够优雅），样式穿透在css预处理器中使用才生效。 我们可以使用 &gt;&gt;&gt; 或 /deep/ 解决这一问题: &lt;style scoped&gt; 外层 &gt;&gt;&gt; .el-checkbox { display: block; font-size: 26px; .el-checkbox__label { font-size: 16px; } } &lt;/style&gt; &lt;style scoped&gt; /deep/ .el-checkbox { display: block; font-size: 26px; .el-checkbox__label { font-size: 16px; } } &lt;/style&gt; 4、watch高阶使用立即执行watch 是在监听属性改变时才会触发，有些时候，我们希望在组件创建后 watch 能够立即执行 可能想到的的方法就是在 create 生命周期中调用一次，但这样的写法不优雅，或许我们可以使用这样的方法 export default { data() { return { name: &#39;Joe&#39; } }, watch: { name: { handler: &#39;sayName&#39;, immediate: true } }, methods: { sayName() { console.log(this.name) } } } 深度监听在监听对象时，对象内部的属性被改变时无法触发 watch ，我们可以为其设置深度监听 export default { data: { studen: { name: &#39;Joe&#39;, skill: { run: { speed: &#39;fast&#39; } } } }, watch: { studen: { handler: &#39;sayName&#39;, deep: true } }, methods: { sayName() { console.log(this.studen) } } } 触发监听执行多个方法使用数组可以设置多项，形式包括字符串、函数、对象 export default { data: { name: &#39;Joe&#39; }, watch: { name: [ &#39;sayName1&#39;, function(newVal, oldVal) { this.sayName2() }, { handler: &#39;sayName3&#39;, immaediate: true } ] }, methods: { sayName1() { console.log(&#39;sayName1==&gt;&#39;, this.name) }, sayName2() { console.log(&#39;sayName2==&gt;&#39;, this.name) }, sayName3() { console.log(&#39;sayName3==&gt;&#39;, this.name) } } } watch监听多个变量watch本身无法监听多个变量。但我们可以将需要监听的多个变量通过计算属性返回对象，再监听这个对象来实现“监听多个变量” export default { data() { return { msg1: &#39;apple&#39;, msg2: &#39;banana&#39; } }, compouted: { msgObj() { const { msg1, msg2 } = this return { msg1, msg2 } } }, watch: { msgObj: { handler(newVal, oldVal) { if (newVal.msg1 != oldVal.msg1) { console.log(&#39;msg1 is change&#39;) } if (newVal.msg2 != oldVal.msg2) { console.log(&#39;msg2 is change&#39;) } }, deep: true } } } 5、事件参数$event$event 是事件对象的特殊变量，在一些场景能给我们实现复杂功能提供更多可用的参数 原生事件在原生事件中表现和默认的事件对象相同 &lt;template&gt; &lt;div&gt; &lt;input type=&quot;text&quot; @input=&quot;inputHandler(&#39;hello&#39;, $event)&quot; /&gt; &lt;/div&gt; &lt;/template&gt; export default { methods: { inputHandler(msg, e) { console.log(e.target.value) } } } 自定义事件在自定义事件中表现为捕获从子组件抛出的值 my-item.vue : export default { methods: { customEvent() { this.$emit(&#39;custom-event&#39;, &#39;some value&#39;) } } } App.vue: &lt;template&gt; &lt;div&gt; &lt;my-item v-for=&quot;(item, index) in list&quot; @custom-event=&quot;customEvent(index, $event)&quot;&gt; &lt;/my-list&gt; &lt;/div&gt; &lt;/template&gt; export default { methods: { customEvent(index, e) { console.log(e) // &#39;some value&#39; } } } 6、自定义组件双向绑定组件 model 选项: 允许一个自定义组件在使用 v-model 时定制 prop 和 event。默认情况下，一个组件上的 v-model 会把 value 用作 prop 且把 input 用作 event，但是一些输入类型比如单选框和复选框按钮可能想使用 value prop 来达到不同的目的。使用 model 选项可以回避这些情况产生的冲突。 input 默认作为双向绑定的更新事件，通过 $emit 可以更新绑定的值 &lt;my-switch v-model=&quot;val&quot;&gt;&lt;/my-switch&gt; export default { props: { value: { type: Boolean, default: false } }, methods: { switchChange(val) { this.$emit(&#39;input&#39;, val) } } } 修改组件的 model 选项，自定义绑定的变量和事件: &lt;my-switch v-model=&quot;num&quot; value=&quot;some value&quot;&gt;&lt;/my-switch&gt; export default { model: { prop: &#39;num&#39;, event: &#39;update&#39; }, props: { value: { type: String, default: &#39;&#39; }, num: { type: Number, default: 0 } }, methods: { numChange() { this.$emit(&#39;update&#39;, this.num++) } } } 如何正确使用vue中的sync修饰符vue父子通讯是单向数据流，也就是子组件不能修改父组件的值，但是在很多情况下是需要这样做的，比如在做功能编辑的时候，子组件需要带入父组件的原始值，而且子组件也需要修改这个值，到最后的保存值中，部分代码 // 父组件 &lt;step-two-other v-bind:stepTwoConfig.sync=&quot;monitorConfigStr&quot;&gt;&lt;/step-two-other&gt; // 子组件 &lt;el-input v-model=&quot;config&quot;&gt;&lt;/el-input&gt; props: { stepTwoConfig: String }, computed: { config: { get() { return this.stepTwoConfig }, set(val) { this.$emit(&#39;update:stepTwoConfig&#39;, val) } } } 以上代码是正确的通信方式。但是在使用的时候发现一些问题，如果父组件传入的值是简单数据类型（string、number）时必须要使用$emit去更新。如果父组件传入的值是引用类型时则不需要，甚至父组件不用带sync也可以，如下两种方式都不会报错，而且能挣钱传值： // 方式1： // 父组件 &lt;step-two-other v-bind:stepTwoConfig.sync=&quot;monitorConfigStr&quot;&gt;&lt;/step-two-other&gt; // 子组件 &lt;el-input v-model=&quot;stepTwoConfig.name&quot;&gt;&lt;/el-input&gt; props: { stepTwoConfig: Object } // 方式2: // 父组件 &lt;step-two-other :stepTwoConfig=&quot;monitorConfigStr&quot;&gt;&lt;/step-two-other&gt; // 子组件 &lt;el-input v-model=&quot;stepTwoConfig.name&quot;&gt;&lt;/el-input&gt; props: { stepTwoConfig: Object } 8、监听组件生命周期通常我们监听组件生命周期会使用 $emit ，父组件接收事件来进行通知 子组件: export default { mounted() { this.$emit(&#39;listenMounted&#39;) } } 父组件: &lt;template&gt; &lt;div&gt; &lt;List @listenMounted=&quot;listenMounted&quot; /&gt; &lt;/div&gt; &lt;/template&gt; 其实还有一种简洁的方法，使用 @hook 即可监听组件生命周期，组件内无需做任何改变。同样的， created 、 updated 等也可以使用此方法 &lt;template&gt; &lt;List @hook:mounted=&quot;listenMounted&quot; /&gt; &lt;/template&gt; 9、程序化的事件侦听器比如，在页面挂载时定义计时器，需要在页面销毁时清除定时器。这看起来没什么问题。但仔细一看 this.timer 唯一的作用只是为了能够在 beforeDestroy 内取到计时器序号，除此之外没有任何用处。 export default { mounted() { this.timer = setInterval(() =&gt; { console.log(Date.now()) }, 1000) }, beforeDestroy() { clearInterval(this.timer) } } 如果可以的话最好只有生命周期钩子可以访问到它。这并不算严重的问题，但是它可以被视为杂物。 我们可以通过 $on 或 $once 监听页面生命周期销毁来解决这个问题： export default { mounted() { this.creatInterval(&#39;hello&#39;) this.creatInterval(&#39;world&#39;) }, creatInterval(msg) { let timer = setInterval(() =&gt; { console.log(msg) }, 1000) this.$once(&#39;hook:beforeDestroy&#39;, function() { clearInterval(timer) }) } } 使用这个方法后，即使我们同时创建多个计时器，也不影响效果。因为它们会在页面销毁后程序化的自主清除。 10、手动挂载组件在一些需求中，手动挂载组件能够让我们实现起来更加优雅。比如一个弹窗组件，最理想的用法是通过命令式调用，就像 elementUI 的 this.$message 。而不是在模板中通过状态切换，这种实现真的很糟糕。 先来个最简单的例子： import Vue from &#39;vue&#39; import Message from &#39;./Message.vue&#39; // 构造子类 let MessageConstructor = Vue.extend(Message) // 实例化组件 let messageInstance = new MessageConstructor() // $mount可以传入选择器字符串，表示挂载到该选择器 // 如果不传入选择器，将渲染为文档之外的的元素，你可以想象成 document.createElement()在内存中生成dom messageInstance.$mount() // messageInstance.$el获取的是dom元素 document.body.appendChild(messageInstance.$el) 下面实现一个简易的 message 弹窗组件 Message/index.vue &lt;template&gt; &lt;div class=&quot;wrap&quot;&gt; &lt;div class=&quot;message&quot; :class=&quot;item.type&quot; v-for=&quot;item in notices&quot; :key=&quot;item._name&quot;&gt; &lt;div class=&quot;content&quot;&gt;{{item.content}}&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; // 默认选项 const DefaultOptions = { duration: 1500, type: &#39;info&#39;, content: &#39;这是一条提示信息！&#39;, } let mid = 0 export default { data() { return { notices: [] } }, methods: { add(notice = {}) { // name标识 用于移除弹窗 let _name = this.getName() // 合并选项 notice = Object.assign({ _name }, DefaultOptions, notice) this.notices.push(notice) setTimeout(() =&gt; { this.removeNotice(_name) }, notice.duration) }, getName() { return &#39;msg_&#39; + (mid++) }, removeNotice(_name) { let index = this.notices.findIndex(item =&gt; item._name === _name) this.notices.splice(index, 1) } } } .wrap { position: fixed; top: 50px; left: 50%; display: flex; flex-direction: column; align-items: center; transform: translateX(-50%); } .message { --borderWidth: 3px; min-width: 240px; max-width: 500px; margin-bottom: 10px; border-radius: 3px; box-shadow: 0 0 8px #ddd; overflow: hidden; } .content { padding: 8px; line-height: 1.3; } .message.info { border-left: var(--borderWidth) solid #909399; background: #F4F4F5; } .message.success { border-left: var(--borderWidth) solid #67C23A; background: #F0F9EB; } .message.error { border-left: var(--borderWidth) solid #F56C6C; background: #FEF0F0; } .message.warning { border-left: var(--borderWidth) solid #E6A23C; background: #FDF6EC; } Message/index.js import Vue from &#39;vue&#39; import Index from &#39;./index.vue&#39; let messageInstance = null let MessageConstructor = Vue.extend(Index) let init = () =&gt; { messageInstance = new MessageConstructor() messageInstance.$mount() document.body.appendChild(messageInstance.$el) } let caller = (options) =&gt; { if (!messageInstance) { init(options) } messageInstance.add(options) } export default { // 返回 install 函数 用于 Vue.use 注册 install(vue) { vue.prototype.$message = caller } } main.js import Message from &#39;@/components/Message/index.js&#39; Vue.use(Message) 使用: this.$message({ type: &#39;success&#39;, content: &#39;成功信息提示&#39;, duration: 3000 })","content":"<h2 id=\"1、路由参数解耦\"><a href=\"#1、路由参数解耦\" class=\"headerlink\" title=\"1、路由参数解耦\"></a>1、路由参数解耦</h2><p> 一般在组件内使用路由参数，大多数人会这样做</p>\n<pre><code> export default {\n    methods: {\n        getParamsId() {\n            return this.$route.params.id\n        }\n    }\n}\n</code></pre><p>在组件中使用 $route 会使之与其对应路由形成高度耦合，从而使组件只能在某些特定的 URL 上使用，限制了其灵活性。</p>\n<p>正确的做法是通过 props 解耦</p>\n<pre><code>const router = new VueRouter({\n    routes: [{\n        path: &#39;/user/:id&#39;,\n        component: User,\n        props: true\n    }]\n})\n</code></pre><p>将路由的 props 属性设置为 true 后，组件内可通过 props 接收到 params 参数</p>\n<pre><code>export default {\n    props: [&#39;id&#39;],\n    methods: {\n        getParamsId() {\n            return this.id\n        }\n    }\n}\n</code></pre><p>另外你还可以通过函数模式来返回 props</p>\n<pre><code>const router = new VueRouter({\n    routes: [{\n        path: &#39;/user/:id&#39;,\n        component: User,\n        props: (route) =&gt; ({\n            id: route.query.id\n        })\n    }]\n})\n</code></pre><h3 id=\"2、函数式组件\"><a href=\"#2、函数式组件\" class=\"headerlink\" title=\"2、函数式组件\"></a>2、函数式组件</h3><p>函数式组件是无状态，它无法实例化，没有任何的生命周期和方法。创建函数式组件也很简单，只需要在模板添加 functional 声明即可。一般适合只依赖于外部数据的变化而变化的组件，因其轻量，渲染性能也会有所提高。</p>\n<p>组件需要的一切都是通过 context 参数传递。它是一个上下文对象，具体属性查看文档。这里 props 是一个包含所有绑定属性的对象。</p>\n<p>函数式组件</p>\n<pre><code>&lt;template functional&gt;\n    &lt;div class=&quot;list&quot;&gt;\n        &lt;div class=&quot;item&quot; v-for=&quot;item in props.list&quot; :key=&quot;item.id&quot; @click=&quot;props.itemClick(item)&quot;&gt;\n            &lt;p&gt;{{item.title}}&lt;/p&gt;\n            &lt;p&gt;{{item.content}}&lt;/p&gt;\n        &lt;/div&gt;\n    &lt;/div&gt;\n&lt;/template&gt;\n</code></pre><p>父组件使用</p>\n<pre><code>&lt;template&gt;\n    &lt;div&gt;\n        &lt;List :list=&quot;list&quot; :itemClick=&quot;item =&gt; (currentItem = item)&quot; /&gt;\n    &lt;/div&gt;\n&lt;/template&gt;\n\nimport List from &#39;@/components/List.vue&#39;\nexport default {\n    components: {\n        List\n    },\n    data() {\n        return {\n            list: [{\n                title: &#39;title&#39;,\n                content: &#39;content&#39;\n            }],\n            currentItem: &#39;&#39;\n        }\n    }\n}\n</code></pre><h3 id=\"3、样式穿透\"><a href=\"#3、样式穿透\" class=\"headerlink\" title=\"3、样式穿透\"></a>3、样式穿透</h3><p>在开发中修改第三方组件样式是很常见，但由于 scoped 属性的样式隔离，可能需要去除 scoped 或是另起一个 style 。这些做法都会带来副作用（组件样式污染、不够优雅），样式穿透在css预处理器中使用才生效。</p>\n<p>我们可以使用 &gt;&gt;&gt; 或 /deep/ 解决这一问题:</p>\n<pre><code>&lt;style scoped&gt;\n外层 &gt;&gt;&gt; .el-checkbox {\n  display: block;\n  font-size: 26px;\n\n  .el-checkbox__label {\n    font-size: 16px;\n  }\n}\n&lt;/style&gt;\n\n&lt;style scoped&gt;\n/deep/ .el-checkbox {\n  display: block;\n  font-size: 26px;\n\n  .el-checkbox__label {\n    font-size: 16px;\n  }\n}\n&lt;/style&gt;\n</code></pre><h3 id=\"4、watch高阶使用\"><a href=\"#4、watch高阶使用\" class=\"headerlink\" title=\"4、watch高阶使用\"></a>4、watch高阶使用</h3><h4 id=\"立即执行\"><a href=\"#立即执行\" class=\"headerlink\" title=\"立即执行\"></a>立即执行</h4><p>watch 是在监听属性改变时才会触发，有些时候，我们希望在组件创建后 watch 能够立即执行</p>\n<p>可能想到的的方法就是在 create 生命周期中调用一次，但这样的写法不优雅，或许我们可以使用这样的方法</p>\n<pre><code>export default {\n    data() {\n        return {\n            name: &#39;Joe&#39;\n        }\n    },\n    watch: {\n        name: {\n            handler: &#39;sayName&#39;,\n            immediate: true\n        }\n    },\n    methods: {\n        sayName() {\n            console.log(this.name)\n        }\n    }\n}\n</code></pre><h4 id=\"深度监听\"><a href=\"#深度监听\" class=\"headerlink\" title=\"深度监听\"></a>深度监听</h4><p>在监听对象时，对象内部的属性被改变时无法触发 watch ，我们可以为其设置深度监听</p>\n<pre><code>export default {\n    data: {\n        studen: {\n            name: &#39;Joe&#39;,\n            skill: {\n                run: {\n                    speed: &#39;fast&#39;\n                }\n            }\n        }\n    },\n    watch: {\n        studen: {\n            handler: &#39;sayName&#39;,\n            deep: true\n        }\n    },\n    methods: {\n        sayName() {\n            console.log(this.studen)\n        }\n    }\n}\n</code></pre><h4 id=\"触发监听执行多个方法\"><a href=\"#触发监听执行多个方法\" class=\"headerlink\" title=\"触发监听执行多个方法\"></a>触发监听执行多个方法</h4><p>使用数组可以设置多项，形式包括字符串、函数、对象</p>\n<pre><code>export default {\n    data: {\n        name: &#39;Joe&#39;\n    },\n    watch: {\n        name: [\n            &#39;sayName1&#39;,\n            function(newVal, oldVal) {\n                this.sayName2()\n            },\n            {\n                handler: &#39;sayName3&#39;,\n                immaediate: true\n            }\n        ]\n    },\n    methods: {\n        sayName1() {\n            console.log(&#39;sayName1==&gt;&#39;, this.name)\n        },\n        sayName2() {\n            console.log(&#39;sayName2==&gt;&#39;, this.name)\n        },\n        sayName3() {\n            console.log(&#39;sayName3==&gt;&#39;, this.name)\n        }\n    }\n}\n</code></pre><h4 id=\"watch监听多个变量\"><a href=\"#watch监听多个变量\" class=\"headerlink\" title=\"watch监听多个变量\"></a>watch监听多个变量</h4><p>watch本身无法监听多个变量。但我们可以将需要监听的多个变量通过计算属性返回对象，再监听这个对象来实现“监听多个变量”</p>\n<pre><code>export default {\n    data() {\n        return {\n            msg1: &#39;apple&#39;,\n            msg2: &#39;banana&#39;\n        }\n    },\n    compouted: {\n        msgObj() {\n            const { msg1, msg2 } = this\n            return {\n                msg1,\n                msg2\n            }\n        }\n    },\n    watch: {\n        msgObj: {\n            handler(newVal, oldVal) {\n                if (newVal.msg1 != oldVal.msg1) {\n                    console.log(&#39;msg1 is change&#39;)\n                }\n                if (newVal.msg2 != oldVal.msg2) {\n                    console.log(&#39;msg2 is change&#39;)\n                }\n            },\n            deep: true\n        }\n    }\n}\n</code></pre><h3 id=\"5、事件参数-event\"><a href=\"#5、事件参数-event\" class=\"headerlink\" title=\"5、事件参数$event\"></a>5、事件参数$event</h3><p>$event 是事件对象的特殊变量，在一些场景能给我们实现复杂功能提供更多可用的参数</p>\n<h4 id=\"原生事件\"><a href=\"#原生事件\" class=\"headerlink\" title=\"原生事件\"></a>原生事件</h4><p>在原生事件中表现和默认的事件对象相同</p>\n<pre><code>&lt;template&gt;\n    &lt;div&gt;\n        &lt;input type=&quot;text&quot; @input=&quot;inputHandler(&#39;hello&#39;, $event)&quot; /&gt;\n    &lt;/div&gt;\n&lt;/template&gt;\n\nexport default {\n    methods: {\n        inputHandler(msg, e) {\n            console.log(e.target.value)\n        }\n    }\n}\n</code></pre><h4 id=\"自定义事件\"><a href=\"#自定义事件\" class=\"headerlink\" title=\"自定义事件\"></a>自定义事件</h4><p>在自定义事件中表现为捕获从子组件抛出的值</p>\n<p>my-item.vue :</p>\n<pre><code>export default {\n    methods: {\n        customEvent() {\n            this.$emit(&#39;custom-event&#39;, &#39;some value&#39;)\n        }\n    }\n}\n</code></pre><p>App.vue:</p>\n<pre><code>&lt;template&gt;\n    &lt;div&gt;\n        &lt;my-item v-for=&quot;(item, index) in list&quot; @custom-event=&quot;customEvent(index, $event)&quot;&gt;\n            &lt;/my-list&gt;\n    &lt;/div&gt;\n&lt;/template&gt;\n\nexport default {\n    methods: {\n        customEvent(index, e) {\n            console.log(e) // &#39;some value&#39;\n        }\n    }\n}\n</code></pre><h3 id=\"6、自定义组件双向绑定\"><a href=\"#6、自定义组件双向绑定\" class=\"headerlink\" title=\"6、自定义组件双向绑定\"></a>6、自定义组件双向绑定</h3><p>组件 model 选项:</p>\n<blockquote>\n<p>允许一个自定义组件在使用 v-model 时定制 prop 和 event。默认情况下，一个组件上的 v-model 会把 value 用作 prop 且把 input 用作 event，但是一些输入类型比如单选框和复选框按钮可能想使用 value prop 来达到不同的目的。使用 model 选项可以回避这些情况产生的冲突。</p>\n</blockquote>\n<p>input 默认作为双向绑定的更新事件，通过 $emit 可以更新绑定的值</p>\n<pre><code>&lt;my-switch v-model=&quot;val&quot;&gt;&lt;/my-switch&gt;\n\nexport default {\n    props: {\n        value: {\n            type: Boolean,\n            default: false\n        }\n    },\n    methods: {\n        switchChange(val) {\n            this.$emit(&#39;input&#39;, val)\n        }\n    }\n}\n</code></pre><p>修改组件的 model 选项，自定义绑定的变量和事件:</p>\n<pre><code>&lt;my-switch v-model=&quot;num&quot; value=&quot;some value&quot;&gt;&lt;/my-switch&gt;\n\nexport default {\n    model: {\n        prop: &#39;num&#39;,\n        event: &#39;update&#39;\n    },\n    props: {\n        value: {\n            type: String,\n            default: &#39;&#39;\n        },\n        num: {\n            type: Number,\n            default: 0\n        }\n    },\n    methods: {\n        numChange() {\n            this.$emit(&#39;update&#39;, this.num++)\n        }\n    }\n}\n</code></pre><h4 id=\"如何正确使用vue中的sync修饰符\"><a href=\"#如何正确使用vue中的sync修饰符\" class=\"headerlink\" title=\"如何正确使用vue中的sync修饰符\"></a>如何正确使用vue中的sync修饰符</h4><p>vue父子通讯是单向数据流，也就是子组件不能修改父组件的值，但是在很多情况下是需要这样做的，比如在做功能编辑的时候，子组件需要带入父组件的原始值，而且子组件也需要修改这个值，到最后的保存值中，部分代码</p>\n<pre><code>// 父组件\n&lt;step-two-other v-bind:stepTwoConfig.sync=&quot;monitorConfigStr&quot;&gt;&lt;/step-two-other&gt;\n\n// 子组件\n&lt;el-input v-model=&quot;config&quot;&gt;&lt;/el-input&gt;\nprops: {\n    stepTwoConfig: String\n},\ncomputed: {\n    config: {\n        get() {\n            return this.stepTwoConfig\n        },\n        set(val) {\n            this.$emit(&#39;update:stepTwoConfig&#39;, val)\n        }\n    }\n}\n</code></pre><h4 id=\"以上代码是正确的通信方式。\"><a href=\"#以上代码是正确的通信方式。\" class=\"headerlink\" title=\"以上代码是正确的通信方式。\"></a>以上代码是正确的通信方式。</h4><p>但是在使用的时候发现一些问题，如果父组件传入的值是简单数据类型（string、number）时必须要使用$emit去更新。<br>如果父组件传入的值是引用类型时则不需要，甚至父组件不用带sync也可以，如下两种方式都不会报错，而且能挣钱传值：</p>\n<pre><code>// 方式1：\n\n// 父组件\n&lt;step-two-other v-bind:stepTwoConfig.sync=&quot;monitorConfigStr&quot;&gt;&lt;/step-two-other&gt;\n\n// 子组件\n&lt;el-input v-model=&quot;stepTwoConfig.name&quot;&gt;&lt;/el-input&gt;\nprops: {\n    stepTwoConfig: Object\n}\n\n\n// 方式2:\n\n// 父组件\n&lt;step-two-other :stepTwoConfig=&quot;monitorConfigStr&quot;&gt;&lt;/step-two-other&gt;\n\n// 子组件\n&lt;el-input v-model=&quot;stepTwoConfig.name&quot;&gt;&lt;/el-input&gt;\nprops: {\n    stepTwoConfig: Object\n}\n</code></pre><h3 id=\"8、监听组件生命周期\"><a href=\"#8、监听组件生命周期\" class=\"headerlink\" title=\"8、监听组件生命周期\"></a>8、监听组件生命周期</h3><p>通常我们监听组件生命周期会使用 $emit ，父组件接收事件来进行通知</p>\n<pre><code>子组件:\nexport default {\n    mounted() {\n        this.$emit(&#39;listenMounted&#39;)\n    }\n}\n\n父组件:\n&lt;template&gt;\n    &lt;div&gt;\n        &lt;List @listenMounted=&quot;listenMounted&quot; /&gt;\n    &lt;/div&gt;\n&lt;/template&gt;\n</code></pre><p>其实还有一种简洁的方法，使用 @hook 即可监听组件生命周期，组件内无需做任何改变。同样的， created 、 updated 等也可以使用此方法</p>\n<pre><code>&lt;template&gt;\n    &lt;List @hook:mounted=&quot;listenMounted&quot; /&gt;\n&lt;/template&gt;\n</code></pre><h3 id=\"9、程序化的事件侦听器\"><a href=\"#9、程序化的事件侦听器\" class=\"headerlink\" title=\"9、程序化的事件侦听器\"></a>9、程序化的事件侦听器</h3><p>比如，在页面挂载时定义计时器，需要在页面销毁时清除定时器。这看起来没什么问题。但仔细一看 this.timer 唯一的作用只是为了能够在 beforeDestroy 内取到计时器序号，除此之外没有任何用处。</p>\n<pre><code>export default {\n    mounted() {\n        this.timer = setInterval(() =&gt; {\n            console.log(Date.now())\n        }, 1000)\n    },\n    beforeDestroy() {\n        clearInterval(this.timer)\n    }\n}\n</code></pre><p>如果可以的话最好只有生命周期钩子可以访问到它。这并不算严重的问题，但是它可以被视为杂物。</p>\n<p>我们可以通过 $on 或 $once 监听页面生命周期销毁来解决这个问题：</p>\n<pre><code>export default {\n    mounted() {\n        this.creatInterval(&#39;hello&#39;)\n        this.creatInterval(&#39;world&#39;)\n    },\n    creatInterval(msg) {\n        let timer = setInterval(() =&gt; {\n            console.log(msg)\n        }, 1000)\n        this.$once(&#39;hook:beforeDestroy&#39;, function() {\n            clearInterval(timer)\n        })\n    }\n}\n</code></pre><p>使用这个方法后，即使我们同时创建多个计时器，也不影响效果。因为它们会在页面销毁后程序化的自主清除。</p>\n<h3 id=\"10、手动挂载组件\"><a href=\"#10、手动挂载组件\" class=\"headerlink\" title=\"10、手动挂载组件\"></a>10、手动挂载组件</h3><p>在一些需求中，手动挂载组件能够让我们实现起来更加优雅。比如一个弹窗组件，最理想的用法是通过命令式调用，就像 elementUI 的 this.$message 。而不是在模板中通过状态切换，这种实现真的很糟糕。</p>\n<p>先来个最简单的例子：</p>\n<pre><code>import Vue from &#39;vue&#39;\nimport Message from &#39;./Message.vue&#39;\n\n// 构造子类\nlet MessageConstructor = Vue.extend(Message)\n// 实例化组件\nlet messageInstance = new MessageConstructor()\n// $mount可以传入选择器字符串，表示挂载到该选择器\n// 如果不传入选择器，将渲染为文档之外的的元素，你可以想象成 document.createElement()在内存中生成dom\nmessageInstance.$mount()\n// messageInstance.$el获取的是dom元素\ndocument.body.appendChild(messageInstance.$el)\n</code></pre><p>下面实现一个简易的 message 弹窗组件</p>\n<p>Message/index.vue</p>\n<pre><code>&lt;template&gt;\n    &lt;div class=&quot;wrap&quot;&gt;\n        &lt;div class=&quot;message&quot; :class=&quot;item.type&quot; v-for=&quot;item in notices&quot; :key=&quot;item._name&quot;&gt;\n            &lt;div class=&quot;content&quot;&gt;{{item.content}}&lt;/div&gt;\n        &lt;/div&gt;\n    &lt;/div&gt;\n&lt;/template&gt;\n\n// 默认选项\nconst DefaultOptions = {\n    duration: 1500,\n    type: &#39;info&#39;,\n    content: &#39;这是一条提示信息！&#39;,\n}\nlet mid = 0\nexport default {\n    data() {\n        return {\n            notices: []\n        }\n    },\n    methods: {\n        add(notice = {}) {\n            // name标识 用于移除弹窗\n            let _name = this.getName()\n            // 合并选项\n            notice = Object.assign({\n                _name\n            }, DefaultOptions, notice)\n\n            this.notices.push(notice)\n\n            setTimeout(() =&gt; {\n                this.removeNotice(_name)\n            }, notice.duration)\n        },\n        getName() {\n            return &#39;msg_&#39; + (mid++)\n        },\n        removeNotice(_name) {\n            let index = this.notices.findIndex(item =&gt; item._name === _name)\n            this.notices.splice(index, 1)\n        }\n    }\n}\n.wrap {\n    position: fixed;\n    top: 50px;\n    left: 50%;\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    transform: translateX(-50%);\n}\n\n.message {\n    --borderWidth: 3px;\n    min-width: 240px;\n    max-width: 500px;\n    margin-bottom: 10px;\n    border-radius: 3px;\n    box-shadow: 0 0 8px #ddd;\n    overflow: hidden;\n}\n\n.content {\n    padding: 8px;\n    line-height: 1.3;\n}\n\n.message.info {\n    border-left: var(--borderWidth) solid #909399;\n    background: #F4F4F5;\n}\n\n.message.success {\n    border-left: var(--borderWidth) solid #67C23A;\n    background: #F0F9EB;\n}\n\n.message.error {\n    border-left: var(--borderWidth) solid #F56C6C;\n    background: #FEF0F0;\n}\n\n.message.warning {\n    border-left: var(--borderWidth) solid #E6A23C;\n    background: #FDF6EC;\n}\n</code></pre><p>Message/index.js</p>\n<pre><code>import Vue from &#39;vue&#39;\nimport Index from &#39;./index.vue&#39;\n\nlet messageInstance = null\nlet MessageConstructor = Vue.extend(Index)\n\nlet init = () =&gt; {\n    messageInstance = new MessageConstructor()\n    messageInstance.$mount()\n    document.body.appendChild(messageInstance.$el)\n}\n\nlet caller = (options) =&gt; {\n    if (!messageInstance) {\n        init(options)\n    }\n    messageInstance.add(options)\n}\n\nexport default {\n    // 返回 install 函数 用于 Vue.use 注册\n    install(vue) {\n        vue.prototype.$message = caller\n    }\n}\n</code></pre><p>main.js</p>\n<pre><code>import Message from &#39;@/components/Message/index.js&#39;\n\nVue.use(Message)\n</code></pre><p>使用:</p>\n<pre><code>this.$message({\n    type: &#39;success&#39;,\n    content: &#39;成功信息提示&#39;,\n    duration: 3000\n})\n</code></pre>","updated":"2020-05-11T02:52:09.957Z","comments":true,"link":"","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://yoursite.com/categories/前端开发/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"很棒的Webpack插件","date":"2020-05-11T02:03:12.000Z","path":"2020/05/11/webpack_plugin/","text":"提高工作效率的很棒的Webpack插件1、Webpack Bundle Analyzer通过交互式的、可缩放的树状图来可视化webpack输出文件的大小。该插件将帮助你您执行以下操作： 了解你的包里真正有什么 找出哪些模块构成了捆绑软件的最大组成部分 查找错误到达的模块 优化你的Webpack捆绑包安装# NPM npm install --save-dev webpack-bundle-analyzer # Yarn yarn add -D webpack-bundle-analyzer 使用const BundleAnalyzerPlugin = require(&#39;webpack-bundle analyzer&#39;); module.exports = { plugins: [ new BundleAnalyzerPlugin() ] } 2、offline-pluginoffline-plugin 旨在为webpack项目提供离线体验。 该插件使用 ServiceWorker 和 AppCache 作为后台引擎。只需将这个插件包含在 webpack.config 中，并将随附的运行时包含在客户端脚本中，通过缓存所有（或一些）webpack输出资产，你的项目将变为离线状态。 安装npm install offline-plugin [--save-dev] 使用首先，在您的webpack.config中实例化插件： // webpack.config.js example var OfflinePlugin = require(&#39;offline-plugin&#39;); module.exports = { // ... plugins: [ // ... other plugins // 如果OfflinePlugin是最后添加的插件，那就更好了 new OfflinePlugin() ] // ... } 并且，您可以选择使用选项进行配置。然后，将运行时间添加到entry文件（通常是entry目）中： require(&#39;offline-plugin/runtime&#39;).install(); ES6/Babel/TypeScriptimport * as OfflinePluginRuntime from &#39;offline-plugin/runtime&#39;; OfflinePluginRuntime.install(); 有关 TypeScript 用法的更多详细信息，请参见此处。 3、webpack-pwa-manifestwebpack-pwa-manifest 将自己描述为“用于Webpack的渐进式Web App清单生成器，具有自动图标大小调整和指纹识别支持。” webpack-pwa-manifest 是一个webpack插件，可为您的渐进式Web应用程序生成 manifest.json。 如果您在配置上使用注入，请确保 HtmlWebpackPlugin 出现在plugins 数组中的 WebpackPwaManifest 之前。 特征 自动图标大小调整 图标指纹 清单指纹 HTML上的自动清单注入 热重载支持安装npm install --save-dev webpack-pwa-manifest 使用 在你的 webpack.config.js 中： import WebpackPwaManifest from &#39;webpack-pwa-manifest&#39; ... plugins: [ new WebpackPwaManifest({ name: &#39;My Progressive Web App&#39;, short_name: &#39;MyPWA&#39;, description: &#39;My awesome Progressive Web App!&#39;, background_color: &#39;#ffffff&#39;, crossorigin: &#39;use-credentials&#39;, // 可以是null、use-credentials还是anonymous icons: [ { src: path.resolve(&#39;src/assets/icon.png&#39;), sizes: [96, 128, 192, 256, 384, 512] // 多个大小 }, { src: path.resolve(&#39;src/assets/large-icon.png&#39;), size: &#39;1024x1024&#39; // 你还可以使用specification模式 } ] }) ] 4、imagemin-webpack-pluginimagemin-webpack-plugin 是一个webpack插件，用于使用imagemin压缩图像。 安装npm install imagemin-webpack-plugin 使用import ImageminPlugin from &#39;imagemin-webpack-plugin&#39; module.exports = { plugins: [ // 确保插件位于添加图像的插件之后 new ImageminPlugin({ disable: process.env.NODE_ENV !== &#39;production&#39;, // 在开发过程中禁用 pngquant: { quality: &#39;95-100&#39; } }) ] } 5、prerender-spa-pluginprerender-spa-plugin 将静态HTML预渲染到单页应用程序中 该插件的目的是提供一个简单的预渲染解决方案，该解决方案可轻松扩展并适用于任何使用webpack构建的网站或单页应用。 什么是预渲染？最近，服务器端渲染（SSR）席卷了JavaScript前端世界。事实上，你现在可以先在服务器上渲染你的网站和应用程序，然后再发送给你的客户，这绝对是一个革命性的想法（在JS客户端应用程序流行起来之前，每个人都在做的事情，这完全不是在JS客户端应用程序流行起来之前的事情）。 然而，过去对PHP、ASP、JSP（等等）网站的批评，现在对服务器端渲染也是一样的。它的速度很慢，相当容易崩溃，而且难以正确实现。 问题是，不管别人怎么说，你可能不需要SSR。你可以通过使用预分发来获得它几乎所有的优点(没有缺点)。预渲染基本上是启动一个无头浏览器，加载应用程序的路由，并将结果保存到一个静态HTML文件。然后，你可以将其与以前使用的任何静态文件服务解决方案一起使用。它仅适用于HTML5导航等。无需更改代码或添加服务器端渲染解决方法。 安装yarn add -D prerender-spa-plugin 基本使用const path = require(&#39;path&#39;) const PrerenderSPAPlugin = require(&#39;prerender-spa-plugin&#39;) module.exports = { plugins: [ ... new PrerenderSPAPlugin({ // 必需的——指向webpack输出应用程序的prerender路径。 staticDir: path.join(__dirname, &#39;dist&#39;), // 必需的 - Routes to render. routes: [ &#39;/&#39;, &#39;/about&#39;, &#39;/some/deep/nested/route&#39; ], }) ] } 6、duplicate-package-checker-webpack-plugin这是一个webpack插件，当你的捆绑包包含同一软件包的多个版本时，会发出警告。 为什么？由于不同的软件包版本，单个软件包可能多次包含在webpack捆绑软件中。这种情况可能会在没有任何警告的情况下发生，从而导致捆绑软件中出现额外的膨胀，并可能导致难以发现的错误。 该插件会在这种情况下警告你，以最大程度地减少捆绑包的大小，并避免由于意外的重复包装而导致的错误。 安装npm install duplicate-package-checker-webpack-plugin --save-dev 使用将插件添加到你的webpack配置中： const DuplicatePackageCheckerPlugin = require(&quot;duplicate-package-checker-webpack-plugin&quot;); module.exports = { plugins: [new DuplicatePackageCheckerPlugin()] };","content":"<h1 id=\"提高工作效率的很棒的Webpack插件\"><a href=\"#提高工作效率的很棒的Webpack插件\" class=\"headerlink\" title=\"提高工作效率的很棒的Webpack插件\"></a>提高工作效率的很棒的Webpack插件</h1><h3 id=\"1、Webpack-Bundle-Analyzer\"><a href=\"#1、Webpack-Bundle-Analyzer\" class=\"headerlink\" title=\"1、Webpack Bundle Analyzer\"></a>1、Webpack Bundle Analyzer</h3><p>通过交互式的、可缩放的树状图来可视化webpack输出文件的大小。<br>该插件将帮助你您执行以下操作：</p>\n<ul>\n<li>了解你的包里真正有什么</li>\n<li>找出哪些模块构成了捆绑软件的最大组成部分</li>\n<li>查找错误到达的模块</li>\n<li>优化你的Webpack捆绑包<h4 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h4><pre><code># NPM\nnpm install --save-dev webpack-bundle-analyzer\n# Yarn\nyarn add -D webpack-bundle-analyzer\n</code></pre><h4 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h4><pre><code>const BundleAnalyzerPlugin = require(&#39;webpack-bundle analyzer&#39;);\nmodule.exports = {\nplugins: [\n  new BundleAnalyzerPlugin()\n]\n}\n</code></pre><h3 id=\"2、offline-plugin\"><a href=\"#2、offline-plugin\" class=\"headerlink\" title=\"2、offline-plugin\"></a>2、offline-plugin</h3>offline-plugin 旨在为webpack项目提供离线体验。</li>\n</ul>\n<p>该插件使用 ServiceWorker 和 AppCache 作为后台引擎。只需将这个插件包含在 webpack.config 中，并将随附的运行时包含在客户端脚本中，通过缓存所有（或一些）webpack输出资产，你的项目将变为离线状态。</p>\n<h4 id=\"安装-1\"><a href=\"#安装-1\" class=\"headerlink\" title=\"安装\"></a>安装</h4><pre><code>npm install offline-plugin [--save-dev]\n</code></pre><h4 id=\"使用-1\"><a href=\"#使用-1\" class=\"headerlink\" title=\"使用\"></a>使用</h4><p>首先，在您的webpack.config中实例化插件：</p>\n<pre><code>// webpack.config.js example\nvar OfflinePlugin = require(&#39;offline-plugin&#39;);\nmodule.exports = {\n  // ...\n  plugins: [\n    // ... other plugins\n    // 如果OfflinePlugin是最后添加的插件，那就更好了\n    new OfflinePlugin()\n  ]\n  // ...\n}\n</code></pre><p>并且，您可以选择使用选项进行配置。然后，将运行时间添加到entry文件（通常是entry目）中：</p>\n<pre><code>require(&#39;offline-plugin/runtime&#39;).install();\n</code></pre><h4 id=\"ES6-Babel-TypeScript\"><a href=\"#ES6-Babel-TypeScript\" class=\"headerlink\" title=\"ES6/Babel/TypeScript\"></a>ES6/Babel/TypeScript</h4><pre><code>import * as OfflinePluginRuntime from &#39;offline-plugin/runtime&#39;;\nOfflinePluginRuntime.install();\n</code></pre><p>有关 TypeScript 用法的更多详细信息，请参见此处。</p>\n<h3 id=\"3、webpack-pwa-manifest\"><a href=\"#3、webpack-pwa-manifest\" class=\"headerlink\" title=\"3、webpack-pwa-manifest\"></a>3、webpack-pwa-manifest</h3><p>webpack-pwa-manifest 将自己描述为“用于Webpack的渐进式Web App清单生成器，具有自动图标大小调整和指纹识别支持。”</p>\n<p>webpack-pwa-manifest 是一个webpack插件，可为您的渐进式Web应用程序生成 manifest.json。</p>\n<p>如果您在配置上使用注入，请确保 HtmlWebpackPlugin 出现在plugins 数组中的 WebpackPwaManifest 之前。</p>\n<h4 id=\"特征\"><a href=\"#特征\" class=\"headerlink\" title=\"特征\"></a>特征</h4><ul>\n<li>自动图标大小调整</li>\n<li>图标指纹</li>\n<li>清单指纹</li>\n<li>HTML上的自动清单注入</li>\n<li>热重载支持<h4 id=\"安装-2\"><a href=\"#安装-2\" class=\"headerlink\" title=\"安装\"></a>安装</h4><pre><code>npm install --save-dev webpack-pwa-manifest\n</code></pre><h3 id=\"使用-2\"><a href=\"#使用-2\" class=\"headerlink\" title=\"使用\"></a>使用</h3></li>\n</ul>\n<p>在你的 webpack.config.js 中：</p>\n<pre><code>import WebpackPwaManifest from &#39;webpack-pwa-manifest&#39;\n...\nplugins: [\n  new WebpackPwaManifest({\n    name: &#39;My Progressive Web App&#39;,\n    short_name: &#39;MyPWA&#39;,\n    description: &#39;My awesome Progressive Web App!&#39;,\n    background_color: &#39;#ffffff&#39;,\n    crossorigin: &#39;use-credentials&#39;, // 可以是null、use-credentials还是anonymous\n    icons: [\n      {\n        src: path.resolve(&#39;src/assets/icon.png&#39;),\n        sizes: [96, 128, 192, 256, 384, 512] // 多个大小\n      },\n      {\n        src: path.resolve(&#39;src/assets/large-icon.png&#39;),\n        size: &#39;1024x1024&#39; // 你还可以使用specification模式\n      }\n    ]\n  })\n]\n</code></pre><h3 id=\"4、imagemin-webpack-plugin\"><a href=\"#4、imagemin-webpack-plugin\" class=\"headerlink\" title=\"4、imagemin-webpack-plugin\"></a>4、imagemin-webpack-plugin</h3><p>imagemin-webpack-plugin 是一个webpack插件，用于使用imagemin压缩图像。</p>\n<h4 id=\"安装-3\"><a href=\"#安装-3\" class=\"headerlink\" title=\"安装\"></a>安装</h4><pre><code>npm install imagemin-webpack-plugin\n</code></pre><h4 id=\"使用-3\"><a href=\"#使用-3\" class=\"headerlink\" title=\"使用\"></a>使用</h4><pre><code>import ImageminPlugin from &#39;imagemin-webpack-plugin&#39;\nmodule.exports = {\n  plugins: [\n    // 确保插件位于添加图像的插件之后\n    new ImageminPlugin({\n      disable: process.env.NODE_ENV !== &#39;production&#39;, // 在开发过程中禁用\n      pngquant: {\n        quality: &#39;95-100&#39;\n      }\n    })\n  ]\n}\n</code></pre><h3 id=\"5、prerender-spa-plugin\"><a href=\"#5、prerender-spa-plugin\" class=\"headerlink\" title=\"5、prerender-spa-plugin\"></a>5、prerender-spa-plugin</h3><p>prerender-spa-plugin 将静态HTML预渲染到单页应用程序中</p>\n<p>该插件的目的是提供一个简单的预渲染解决方案，该解决方案可轻松扩展并适用于任何使用webpack构建的网站或单页应用。</p>\n<h4 id=\"什么是预渲染？\"><a href=\"#什么是预渲染？\" class=\"headerlink\" title=\"什么是预渲染？\"></a>什么是预渲染？</h4><p>最近，服务器端渲染（SSR）席卷了JavaScript前端世界。事实上，你现在可以先在服务器上渲染你的网站和应用程序，然后再发送给你的客户，这绝对是一个革命性的想法（在JS客户端应用程序流行起来之前，每个人都在做的事情，这完全不是在JS客户端应用程序流行起来之前的事情）。</p>\n<p>然而，过去对PHP、ASP、JSP（等等）网站的批评，现在对服务器端渲染也是一样的。它的速度很慢，相当容易崩溃，而且难以正确实现。</p>\n<p>问题是，不管别人怎么说，你可能不需要SSR。你可以通过使用预分发来获得它几乎所有的优点(没有缺点)。预渲染基本上是启动一个无头浏览器，加载应用程序的路由，并将结果保存到一个静态HTML文件。然后，你可以将其与以前使用的任何静态文件服务解决方案一起使用。它仅适用于HTML5导航等。无需更改代码或添加服务器端渲染解决方法。</p>\n<h4 id=\"安装-4\"><a href=\"#安装-4\" class=\"headerlink\" title=\"安装\"></a>安装</h4><pre><code>yarn add -D prerender-spa-plugin\n</code></pre><h4 id=\"基本使用\"><a href=\"#基本使用\" class=\"headerlink\" title=\"基本使用\"></a>基本使用</h4><pre><code>const path = require(&#39;path&#39;)\nconst PrerenderSPAPlugin = require(&#39;prerender-spa-plugin&#39;)\nmodule.exports = {\n  plugins: [\n    ...\n    new PrerenderSPAPlugin({\n      // 必需的——指向webpack输出应用程序的prerender路径。\n      staticDir: path.join(__dirname, &#39;dist&#39;),\n      // 必需的 - Routes to render.\n      routes: [ &#39;/&#39;, &#39;/about&#39;, &#39;/some/deep/nested/route&#39; ],\n    })\n  ]\n}\n</code></pre><h3 id=\"6、duplicate-package-checker-webpack-plugin\"><a href=\"#6、duplicate-package-checker-webpack-plugin\" class=\"headerlink\" title=\"6、duplicate-package-checker-webpack-plugin\"></a>6、duplicate-package-checker-webpack-plugin</h3><p>这是一个webpack插件，当你的捆绑包包含同一软件包的多个版本时，会发出警告。</p>\n<h4 id=\"为什么？\"><a href=\"#为什么？\" class=\"headerlink\" title=\"为什么？\"></a>为什么？</h4><p>由于不同的软件包版本，单个软件包可能多次包含在webpack捆绑软件中。这种情况可能会在没有任何警告的情况下发生，从而导致捆绑软件中出现额外的膨胀，并可能导致难以发现的错误。</p>\n<p>该插件会在这种情况下警告你，以最大程度地减少捆绑包的大小，并避免由于意外的重复包装而导致的错误。</p>\n<h4 id=\"安装-5\"><a href=\"#安装-5\" class=\"headerlink\" title=\"安装\"></a>安装</h4><pre><code>npm install duplicate-package-checker-webpack-plugin --save-dev\n</code></pre><h4 id=\"使用-4\"><a href=\"#使用-4\" class=\"headerlink\" title=\"使用\"></a>使用</h4><p>将插件添加到你的webpack配置中：</p>\n<pre><code>const DuplicatePackageCheckerPlugin = require(&quot;duplicate-package-checker-webpack-plugin&quot;);\nmodule.exports = {\n  plugins: [new DuplicatePackageCheckerPlugin()]\n};\n</code></pre>","updated":"2020-05-11T02:32:34.912Z","comments":true,"link":"","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://yoursite.com/categories/前端开发/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"13个npm快速使用开发技巧","date":"2020-05-10T02:03:58.000Z","path":"2020/05/10/npm_plugin/","text":"1.学习基本快捷方式我们从最基本的开始,学习最常见的npm快捷方式从长远来将会节省很多时间。 安装 — 常规：npm install，简写：npm i。 测试 — 常规：npm test，简写：npm t。 帮助 — 常规：npm –help，简写：npm -h。 全局标志 — 常规： –global，简写：-g。 保存为开发依赖 - 常规： - save-dev，简写：-D。 npm init 默认值 - 常规：npm init –yes 或 npm init –force，简写：npm init -y 或 npm init -f 我们知道使用-save或-S来保存包，但现在这是个已经是默认值。要安装一个包而不保存它，可以使用 ——no-save标志。 不太常见的快捷键还有一些不常见的快捷方式，如下： 安装包信息将加入到optionalDependencies（可选阶段的依赖）- 常规：–save-optional， 简写：-O。 精确安装指定模块版本 - 常规：–save-optional， 简写：-O。如果需要在本地保存一个npm包，或者通过单个文件下载选择一组可用的包，可以使用–save-bundle或-B将它们捆绑在一起，并使用npm pack获得捆绑包 根的快捷方式 符号通常用于表示应用程序的根目录，npm术语中的应用程序入口点，即package.json中指定为“main”的值{ &quot;main&quot;: &quot;index.js&quot; } 这个快捷方式也可以用于像npx create-react-app . 这样的命令。因此，可以运行npx create-react-app .，而不是使用 npx create-react-app my-app 创建一个新的my-app目录 2. 设置默认npm init属性当运行npm init开始一个新项目时，你可能会发现自己一次又一次地输入配置细节。假如，你可能是项目的主要负责人。有时为了节省时间，可以为这些字段设置默认值，如下所示： npm config set init.author.name &quot;Joe Bloggs&quot; npm config set init.author.email &quot;JoebLoggs@gmail.com&quot; npm config set init.author.url &quot;Joebloggs.com&quot; npm config set init.license &quot;MIT&quot; 要检查是否正确添加了这些属性，在终端输入 npm config edit查看配置文件信息。当然也j可以通过直接在打开的配置文件编辑信息。 如果要编辑全局npm设置，使用npm config edit -g。要重新初始化默认设置，可以使用以下脚本。第一行用空字符串替换配置文件，第二行用默认设置重新填充配置文件。 echo &quot;&quot; &gt; $(npm config get userconfig) npm config edit 上面的脚本将重置用户默认值，下面的脚本将重置全局默认值 echo &quot;&quot; &gt; $(npm config get globalconfig) npm config --global edit 3. 让脚本跨平台兼容任何在命令行上运行的代码都有兼容性问题的风险，特别是在Windows和基于unix的系统(包括Mac和Linux)之间。如果你只处理特定的项目，那么这不是问题，但是在许多情况下，跨平台兼容性很有必要的:任何开放源码或协作项目，以及示例和教程项目，都应该能够工作，而不管操作系统是什么。谢天谢地，解决方案很简单。有几个选项可供选择，但效果最好的是cross-env。使用npm i -D cross-env将其作为开发依赖项安装。然后在任何环境变量之前包括关键字cross-env，就像这样： { &quot;scripts&quot;: { &quot;build&quot;: &quot;cross-env NODE_ENV=production webpack --config build/wepack.config.js&quot; } } cross-env是 实现跨平台兼容性的最无缝的方法，但还有其他两个流行的工具，它们可以帮助实现跨平台兼容性： rimraf 可以安装在全球运行跨平台脚本 ShellJS 是Unix shell命令在Node.js API上的可移植实现。4. 并行运行脚本可以使用&amp;&amp;来依次运行两个或多个进程。但是并行运行脚本呢?为此，我们可以从各种npm包中进行选择。concurrent 和 npm-run-all 是最流行的解决方案。首先通过 npm i -D concurrently 安装开发依赖。然后按照以下格式将其添加到脚本中：{ &quot;start&quot;: &quot;concurrently \\&quot;command1 arg\\&quot; \\&quot;command2 arg\\&quot;&quot; } 5. 在不同的目录中运行脚本有时，在不同的文件夹中拥有一个包含多个package.json文件的应用程序。 从根目录访问这些脚本会很方便，而不是每次要运行脚本时导航到不同的文件夹，有两种方法可以执行此操作。第一种是手动 cd 并运行对应的命令：cd folder &amp;&amp; npm start &amp;&amp; cd .. 但还有一个更优雅的解决方案，即使用–prefix标志指定路径npm start --prefix path/to/your/folder 下面是一个工作应用程序中此解决方案的示例，我们希望在前端(在客户机目录中)和后端(在服务器目录中)运行 npm start。 &quot;start&quot;: &quot;concurrently \\&quot;(npm start --prefix client)\\&quot; \\&quot;(npm start --prefix server)\\&quot;&quot;, 6. 延迟运行脚本直到端口准备就绪通常，在开发全堆栈应用程序期间，咱们可能希望同时启动服务器和客户端。wait-on 节点模块提供了一种方便的方法来确保进程只在某些进程就绪时发生:在我们的例子中，我们有一个特定的端口。例如，这是我在使用React前端的Electron项目中使用的dev脚本。 同时使用，脚本并行加载表示层和Electron窗口。 但是，使用wait-on，只有在 http://localhost:3000 启动好，才会打开Electron窗口。 &quot;dev&quot;: &quot;concurrently \\&quot;cross-env BROWSER=none npm run start\\&quot; \\&quot;wait-on http://localhost:3000 &amp;&amp; electron .\\&quot;&quot;, 此外，React默认情况下会打开一个浏览器窗口，但对于 Electron 开发来说，这是不必要的。咱们可以通过传递环境变量BROWSER=none来禁用此行为 7. 列出并选择可用脚本列出package.json文件中可用的脚本很简单：只需转到项目的根目录并在终端中输入npm run。但是有一种更方便的方法可以获得脚本列表，可以立即运行该列表:为此，全局安装 NTL (npm任务列表)模块: npm i -g ntl 然后在项目文件夹中运行ntl命令，可以获得一个可用脚本列表，并可以选择其中一个运行。 8. 运行前后脚本你可能熟悉prebuild和postbuild这样的脚本，它们允许你定义在构建脚本之前或之后运行的代码。但事实上，pre和post可以在任何脚本之前添加，包括自定义脚本。这不仅使你的代码更干净，而且还允许你单独运行pre和post脚本 9. 控制应用程序版本与手动更改应用程序的版本相比，npm 提供了一些有用的快捷方式来完成这一点。 要增加版本，请在运行 npm version加上major，minor或patch` // 1.0.0 npm version patch // 1.0.1 npm version minor // 1.1.0 npm version major // 2.0.0 根据更新应用程序的频率，可以通过在每次部署时增加版本号来节省时间，使用以下脚本: { &quot;predeploy&quot;: &quot;npm version patch&quot; } 10. 从命令行编辑 package.jsonpackage.json是一个常规的json文件，因此可以使用工具库json从命令行进行编辑。 这在修改package.json提供另外一种新的方式，允许w你q创建超出默认值的快捷方式。 全局安装： npm install -g json 然后，可以使用它来使用-I进行就地编辑。 例如，要添加值为“bar”的新脚本“foo”，这样写 json -I -f package.json -e &#39;this.scripts.foo=&quot;bar&quot;&#39; 11. 自动设置和打开你的github库如果package.json文件中有“repository”，则可以通过输入 npm repo在默认浏览器中打开它。如果你的项目已经连接到远程存储库，并且已经在命令行上安装了git，那您可以使用这个命令找到你的连接存储库 git config --get remote.origin.url 更好的是，如果你按照上面的提示并安装了json模块，可以使用下面的脚本自动将正确的存储库添加到 package.json json -I -f package.json -e &quot;this.repository=\\&quot;$(git config --get remote.origin.url)\\&quot;&quot; 13. 使用自定义npm init脚本将你的第一个 Commit 提交到 GitHub为了将git命令合并到.npm-init.js文件中，需要一种方法来控制命令行。为此，我们可以使用child_process 模块。在文件的顶部引入它，因为我们只需要execSync函数，所以可以使用析构赋值语法自己获取它： const { execSync } = require(&#39;child_process&#39;); 我还创建了一个helper函数，它将函数的结果打印到控制台： function run(func) { console.log(execSync(func).toString()) } 最后，我们将提示输入GitHub存储库URL，如果提供，我们将生README.md文件，并启动我们的第一次提交。 repository: prompt(&#39;github repository url&#39;, &#39;&#39;, function (url) { if (url) { run(&#39;touch README.md&#39;); run(&#39;git init&#39;); run(&#39;git add README.md&#39;); run(&#39;git commit -m &quot;first commit&quot;&#39;); run(`git remote add origin ${url}`); run(&#39;git push -u origin master&#39;); } return url; }) 总的来说，.npm-init.js文件大概如下： const { execSync } = require(&#39;child_process&#39;); function run(func) { console.log(execSync(func).toString()) } module.exports = { name: prompt(&#39;package name&#39;, basename || package.name), version: prompt(&#39;version&#39;, &#39;0.0.0&#39;), decription: prompt(&#39;description&#39;, &#39;&#39;), main: prompt(&#39;entry point&#39;, &#39;index.js&#39;), keywords: prompt(function (s) { return s.split(/\\s+/) }), author: prompt(&#39;author&#39;, &#39;Joe Bloggs &lt;joe.bloggs@gmail.com&gt; (joebloggs.com)&#39;), license: prompt(&#39;license&#39;, &#39;ISC&#39;), repository: prompt(&#39;github repository url&#39;, &#39;&#39;, function (url) { if (url) { run(&#39;touch README.md&#39;); run(&#39;git init&#39;); run(&#39;git add README.md&#39;); run(&#39;git commit -m &quot;first commit&quot;&#39;); run(`git remote add origin ${url}`); run(&#39;git push -u origin master&#39;); } return url; }), } package.json文件： { &quot;name&quot;: &quot;Custom npm init&quot;, &quot;version&quot;: &quot;0.0.0&quot;, &quot;decription&quot;: &quot;A test project, to demonstrate a custom npm init script.&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;keywords&quot;: [], &quot;author&quot;: &quot;Joe Bloggs &lt;joe.bloggs@gmail.com&gt; (joebloggs.com)&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;repository&quot;: { &quot;type&quot;: &quot;git&quot;, &quot;url&quot;: &quot;git+https://github.com/JoeBloggs/custom.git&quot; }, &quot;bugs&quot;: { &quot;url&quot;: &quot;https://github.com/JoeBloggs/custom/issues&quot; }, &quot;homepage&quot;: &quot;https://github.com/JoeBloggs/custom#readme&quot; } 你也可以通过合并GitHub API进一步实现这一点，这样就不需要创建一个新的存储库，这部分留给你们自己完成。总的来说，希望这篇文章能够让你了解npm可以实现的目标，并展示了一些提高工作效率的方法 - 无论是你知道常见的快捷方式，还是通过充分利用脚本 package.json，或编写自定义版本的npm init。","content":"<h2 id=\"1-学习基本快捷方式\"><a href=\"#1-学习基本快捷方式\" class=\"headerlink\" title=\"1.学习基本快捷方式\"></a>1.学习基本快捷方式</h2><p>我们从最基本的开始,学习最常见的npm快捷方式从长远来将会节省很多时间。</p>\n<ul>\n<li>安装  —  常规：npm install，简写：npm i。</li>\n<li>测试  —  常规：npm test，简写：npm t。</li>\n<li>帮助  —  常规：npm –help，简写：npm -h。</li>\n<li>全局标志 —  常规： –global，简写：-g。</li>\n<li>保存为开发依赖 - 常规： - save-dev，简写：-D。</li>\n<li>npm init 默认值 - 常规：npm init –yes 或 npm init –force，简写：npm init -y 或 npm init -f</li>\n</ul>\n<p>我们知道使用-save或-S来保存包，但现在这是个已经是默认值。要安装一个包而不保存它，可以使用 ——no-save标志。</p>\n<h4 id=\"不太常见的快捷键\"><a href=\"#不太常见的快捷键\" class=\"headerlink\" title=\"不太常见的快捷键\"></a>不太常见的快捷键</h4><p>还有一些不常见的快捷方式，如下：</p>\n<ul>\n<li>安装包信息将加入到optionalDependencies（可选阶段的依赖）- 常规：–save-optional， 简写：-O。</li>\n<li>精确安装指定模块版本 - 常规：–save-optional， 简写：-O。<br>如果需要在本地保存一个npm包，或者通过单个文件下载选择一组可用的包，可以使用–save-bundle或-B将它们捆绑在一起，并使用npm pack获得捆绑包</li>\n</ul>\n<h4 id=\"根的快捷方式\"><a href=\"#根的快捷方式\" class=\"headerlink\" title=\"根的快捷方式\"></a>根的快捷方式</h4><ul>\n<li>符号通常用于表示应用程序的根目录，npm术语中的应用程序入口点，即package.json中指定为“main”的值<pre><code>{\n&quot;main&quot;: &quot;index.js&quot;\n}\n</code></pre>这个快捷方式也可以用于像npx create-react-app . 这样的命令。因此，可以运行npx create-react-app .，而不是使用 npx create-react-app my-app 创建一个新的my-app目录</li>\n</ul>\n<h3 id=\"2-设置默认npm-init属性\"><a href=\"#2-设置默认npm-init属性\" class=\"headerlink\" title=\"2. 设置默认npm init属性\"></a>2. 设置默认npm init属性</h3><p>当运行npm init开始一个新项目时，你可能会发现自己一次又一次地输入配置细节。假如，你可能是项目的主要负责人。有时为了节省时间，可以为这些字段设置默认值，如下所示：</p>\n<pre><code>npm config set init.author.name &quot;Joe Bloggs&quot;\nnpm config set init.author.email &quot;JoebLoggs@gmail.com&quot;\nnpm config set init.author.url &quot;Joebloggs.com&quot;\nnpm config set init.license &quot;MIT&quot;\n</code></pre><p>要检查是否正确添加了这些属性，在终端输入 npm config edit查看配置文件信息。当然也j可以通过直接在打开的配置文件编辑信息。 如果要编辑全局npm设置，使用npm config edit -g。<br>要重新初始化默认设置，可以使用以下脚本。第一行用空字符串替换配置文件，第二行用默认设置重新填充配置文件。</p>\n<pre><code>echo &quot;&quot; &gt; $(npm config get userconfig)\nnpm config edit\n</code></pre><p>上面的脚本将重置用户默认值，下面的脚本将重置全局默认值</p>\n<pre><code>echo &quot;&quot; &gt; $(npm config get globalconfig)\nnpm config --global edit\n</code></pre><h3 id=\"3-让脚本跨平台兼容\"><a href=\"#3-让脚本跨平台兼容\" class=\"headerlink\" title=\"3. 让脚本跨平台兼容\"></a>3. 让脚本跨平台兼容</h3><p>任何在命令行上运行的代码都有兼容性问题的风险，特别是在Windows和基于unix的系统(包括Mac和Linux)之间。如果你只处理特定的项目，那么这不是问题，但是在许多情况下，跨平台兼容性很有必要的:任何开放源码或协作项目，以及示例和教程项目，都应该能够工作，而不管操作系统是什么。<br>谢天谢地，解决方案很简单。有几个选项可供选择，但效果最好的是cross-env。使用npm i -D cross-env将其作为开发依赖项安装。然后在任何环境变量之前包括关键字cross-env，就像这样：</p>\n<pre><code>{\n  &quot;scripts&quot;: {\n    &quot;build&quot;: &quot;cross-env NODE_ENV=production webpack --config build/wepack.config.js&quot;\n  }\n}\n</code></pre><p>cross-env是 实现跨平台兼容性的最无缝的方法，但还有其他两个流行的工具，它们可以帮助实现跨平台兼容性：</p>\n<ul>\n<li>rimraf 可以安装在全球运行跨平台脚本</li>\n<li>ShellJS 是Unix shell命令在Node.js API上的可移植实现。<h3 id=\"4-并行运行脚本\"><a href=\"#4-并行运行脚本\" class=\"headerlink\" title=\"4. 并行运行脚本\"></a>4. 并行运行脚本</h3>可以使用&amp;&amp;来依次运行两个或多个进程。但是并行运行脚本呢?为此，我们可以从各种npm包中进行选择。concurrent 和 npm-run-all 是最流行的解决方案。<br>首先通过 npm i -D concurrently 安装开发依赖。然后按照以下格式将其添加到脚本中：<pre><code>{\n&quot;start&quot;: &quot;concurrently \\&quot;command1 arg\\&quot; \\&quot;command2 arg\\&quot;&quot;\n}\n</code></pre><h3 id=\"5-在不同的目录中运行脚本\"><a href=\"#5-在不同的目录中运行脚本\" class=\"headerlink\" title=\"5. 在不同的目录中运行脚本\"></a>5. 在不同的目录中运行脚本</h3>有时，在不同的文件夹中拥有一个包含多个package.json文件的应用程序。 从根目录访问这些脚本会很方便，而不是每次要运行脚本时导航到不同的文件夹，有两种方法可以执行此操作。<br>第一种是手动 cd 并运行对应的命令：<pre><code>cd folder &amp;&amp; npm start &amp;&amp; cd ..\n</code></pre>但还有一个更优雅的解决方案，即使用–prefix标志指定路径<pre><code>npm start --prefix path/to/your/folder\n</code></pre>下面是一个工作应用程序中此解决方案的示例，我们希望在前端(在客户机目录中)和后端(在服务器目录中)运行 npm start。</li>\n</ul>\n<pre><code>&quot;start&quot;: &quot;concurrently \\&quot;(npm start --prefix client)\\&quot; \\&quot;(npm start --prefix server)\\&quot;&quot;,\n</code></pre><h3 id=\"6-延迟运行脚本直到端口准备就绪\"><a href=\"#6-延迟运行脚本直到端口准备就绪\" class=\"headerlink\" title=\"6. 延迟运行脚本直到端口准备就绪\"></a>6. 延迟运行脚本直到端口准备就绪</h3><p>通常，在开发全堆栈应用程序期间，咱们可能希望同时启动服务器和客户端。wait-on 节点模块提供了一种方便的方法来确保进程只在某些进程就绪时发生:在我们的例子中，我们有一个特定的端口。<br>例如，这是我在使用React前端的Electron项目中使用的dev脚本。 同时使用，脚本并行加载表示层和Electron窗口。 但是，使用wait-on，只有在 <a href=\"http://localhost:3000\">http://localhost:3000</a> 启动好，才会打开Electron窗口。</p>\n<pre><code>&quot;dev&quot;: &quot;concurrently \\&quot;cross-env BROWSER=none npm run start\\&quot; \\&quot;wait-on http://localhost:3000 &amp;&amp; electron .\\&quot;&quot;,\n</code></pre><p>此外，React默认情况下会打开一个浏览器窗口，但对于 Electron 开发来说，这是不必要的。咱们可以通过传递环境变量BROWSER=none来禁用此行为</p>\n<h3 id=\"7-列出并选择可用脚本\"><a href=\"#7-列出并选择可用脚本\" class=\"headerlink\" title=\"7. 列出并选择可用脚本\"></a>7. 列出并选择可用脚本</h3><p>列出package.json文件中可用的脚本很简单：只需转到项目的根目录并在终端中输入npm run。<br>但是有一种更方便的方法可以获得脚本列表，可以立即运行该列表:为此，全局安装 NTL (npm任务列表)模块:</p>\n<pre><code>npm i -g ntl\n</code></pre><p>然后在项目文件夹中运行ntl命令，可以获得一个可用脚本列表，并可以选择其中一个运行。</p>\n<h3 id=\"8-运行前后脚本\"><a href=\"#8-运行前后脚本\" class=\"headerlink\" title=\"8. 运行前后脚本\"></a>8. 运行前后脚本</h3><p>你可能熟悉prebuild和postbuild这样的脚本，它们允许你定义在构建脚本之前或之后运行的代码。但事实上，pre和post可以在任何脚本之前添加，包括自定义脚本。<br>这不仅使你的代码更干净，而且还允许你单独运行pre和post脚本</p>\n<h3 id=\"9-控制应用程序版本\"><a href=\"#9-控制应用程序版本\" class=\"headerlink\" title=\"9. 控制应用程序版本\"></a>9. 控制应用程序版本</h3><p>与手动更改应用程序的版本相比，npm 提供了一些有用的快捷方式来完成这一点。 要增加版本，请在运行 npm version加上major，minor或patch`</p>\n<pre><code>// 1.0.0\nnpm version patch\n// 1.0.1\nnpm version minor\n// 1.1.0\nnpm version major\n// 2.0.0\n</code></pre><p>根据更新应用程序的频率，可以通过在每次部署时增加版本号来节省时间，使用以下脚本:</p>\n<pre><code>{\n  &quot;predeploy&quot;: &quot;npm version patch&quot;\n}\n</code></pre><h3 id=\"10-从命令行编辑-package-json\"><a href=\"#10-从命令行编辑-package-json\" class=\"headerlink\" title=\"10. 从命令行编辑 package.json\"></a>10. 从命令行编辑 package.json</h3><p>package.json是一个常规的json文件，因此可以使用工具库json从命令行进行编辑。 这在修改package.json提供另外一种新的方式，允许w你q创建超出默认值的快捷方式。 全局安装：</p>\n<pre><code>npm install -g json\n</code></pre><p>然后，可以使用它来使用-I进行就地编辑。 例如，要添加值为“bar”的新脚本“foo”，这样写</p>\n<pre><code>json -I -f package.json -e &#39;this.scripts.foo=&quot;bar&quot;&#39;\n</code></pre><h3 id=\"11-自动设置和打开你的github库\"><a href=\"#11-自动设置和打开你的github库\" class=\"headerlink\" title=\"11. 自动设置和打开你的github库\"></a>11. 自动设置和打开你的github库</h3><p>如果package.json文件中有“repository”，则可以通过输入 npm repo在默认浏览器中打开它。<br>如果你的项目已经连接到远程存储库，并且已经在命令行上安装了git，那您可以使用这个命令找到你的连接存储库</p>\n<pre><code>git config --get remote.origin.url\n</code></pre><p>更好的是，如果你按照上面的提示并安装了json模块，可以使用下面的脚本自动将正确的存储库添加到 package.json</p>\n<pre><code>json -I -f package.json -e &quot;this.repository=\\&quot;$(git config --get remote.origin.url)\\&quot;&quot;\n</code></pre><h3 id=\"13-使用自定义npm-init脚本将你的第一个-Commit-提交到-GitHub\"><a href=\"#13-使用自定义npm-init脚本将你的第一个-Commit-提交到-GitHub\" class=\"headerlink\" title=\"13. 使用自定义npm init脚本将你的第一个 Commit 提交到 GitHub\"></a>13. 使用自定义npm init脚本将你的第一个 Commit 提交到 GitHub</h3><p>为了将git命令合并到.npm-init.js文件中，需要一种方法来控制命令行。为此，我们可以使用child_process 模块。在文件的顶部引入它，因为我们只需要execSync函数，所以可以使用析构赋值语法自己获取它：</p>\n<pre><code>const { execSync } = require(&#39;child_process&#39;);\n</code></pre><p>我还创建了一个helper函数，它将函数的结果打印到控制台：</p>\n<pre><code>function run(func) {\n  console.log(execSync(func).toString())\n}\n</code></pre><p>最后，我们将提示输入GitHub存储库URL，如果提供，我们将生README.md文件，并启动我们的第一次提交。</p>\n<pre><code>repository: prompt(&#39;github repository url&#39;, &#39;&#39;, function (url) {\n  if (url) {\n    run(&#39;touch README.md&#39;);\n    run(&#39;git init&#39;);\n    run(&#39;git add README.md&#39;);\n    run(&#39;git commit -m &quot;first commit&quot;&#39;);\n    run(`git remote add origin ${url}`);\n    run(&#39;git push -u origin master&#39;);\n  }\n  return url;\n})\n</code></pre><p>总的来说，.npm-init.js文件大概如下：</p>\n<pre><code>const { execSync } = require(&#39;child_process&#39;);\n\nfunction run(func) {\n  console.log(execSync(func).toString())\n}\n\nmodule.exports = {\n  name: prompt(&#39;package name&#39;, basename || package.name),\n  version: prompt(&#39;version&#39;, &#39;0.0.0&#39;),\n  decription: prompt(&#39;description&#39;, &#39;&#39;),\n  main: prompt(&#39;entry point&#39;, &#39;index.js&#39;),\n  keywords: prompt(function (s) { return s.split(/\\s+/) }),\n  author: prompt(&#39;author&#39;, &#39;Joe Bloggs &lt;joe.bloggs@gmail.com&gt; (joebloggs.com)&#39;),\n  license: prompt(&#39;license&#39;, &#39;ISC&#39;),\n  repository: prompt(&#39;github repository url&#39;, &#39;&#39;, function (url) {\n    if (url) {\n      run(&#39;touch README.md&#39;);\n      run(&#39;git init&#39;);\n      run(&#39;git add README.md&#39;);\n      run(&#39;git commit -m &quot;first commit&quot;&#39;);\n      run(`git remote add origin ${url}`);\n      run(&#39;git push -u origin master&#39;);\n    }\n    return url;\n  }),\n}\n</code></pre><p>package.json文件：</p>\n<pre><code>{\n  &quot;name&quot;: &quot;Custom npm init&quot;,\n  &quot;version&quot;: &quot;0.0.0&quot;,\n  &quot;decription&quot;: &quot;A test project, to demonstrate a custom npm init script.&quot;,\n  &quot;main&quot;: &quot;index.js&quot;,\n  &quot;keywords&quot;: [],\n  &quot;author&quot;: &quot;Joe Bloggs &lt;joe.bloggs@gmail.com&gt; (joebloggs.com)&quot;,\n  &quot;license&quot;: &quot;ISC&quot;,\n  &quot;repository&quot;: {\n    &quot;type&quot;: &quot;git&quot;,\n    &quot;url&quot;: &quot;git+https://github.com/JoeBloggs/custom.git&quot;\n  },\n  &quot;bugs&quot;: {\n    &quot;url&quot;: &quot;https://github.com/JoeBloggs/custom/issues&quot;\n  },\n  &quot;homepage&quot;: &quot;https://github.com/JoeBloggs/custom#readme&quot;\n}\n</code></pre><p>你也可以通过合并GitHub API进一步实现这一点，这样就不需要创建一个新的存储库，这部分留给你们自己完成。<br>总的来说，希望这篇文章能够让你了解npm可以实现的目标，并展示了一些提高工作效率的方法 - 无论是你知道常见的快捷方式，还是通过充分利用脚本 package.json，或编写自定义版本的npm init。</p>\n","updated":"2020-05-11T02:48:40.292Z","comments":true,"link":"","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://yoursite.com/categories/前端开发/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"60个非常有用的css片段（一）","date":"2020-04-28T07:03:58.000Z","path":"2020/04/28/usercss/","text":"1.花式连字符 这个类应该在span元素里使用，并且里面包括&amp;字符。它使用经典的serif字体和斜体来增强&amp;符号 .amp { font-family: Baskerville, &#39;Goudy Old Style&#39;, Palatino, &#39;Book Antiqua&#39;, serif; font-style: italic; font-weight: normal; } 2.段落首字符下沉 通常，这种效果会出现在印刷媒体上，如报纸或书籍。同样，如果网页布局合理，它也可以使用在Web页面上，它仅针对段落使用，但你也可以与单个元素绑定 p:first-letter{ display: block; margin: 5px 0 0 5px; float: left; color: #ff3366; font-size: 5.4em; font-family: Georgia, Times New Roman, serif; } 3.内层CSS3盒阴影 盒阴影（box shadow）属性几乎可以运用在任何元素上，它们看起来都非常好看。下面这段代码主要聚焦内层阴影的设计。 #mydiv { -moz-box-shadow: inset 2px 0 4px #000; -webkit-box-shadow: inset 2px 0 4px #000; box-shadow: inset 2px 0 4px #000; } 4.外层CSS3盒阴影 下面介绍一段外层阴影代码设计，注意，代码里的第三个参数表示模糊距离（blur distance），而第四个参数表示铺开的（spread）距离。关于这些值的设计，你可以前往 W3Schools学习。 #mydiv { -webkit-box-shadow: 0 2px 2px -2px rgba(0, 0, 0, 0.52); -moz-box-shadow: 0 2px 2px -2px rgba(0, 0, 0, 0.52); box-shadow: 0 2px 2px -2px rgba(0, 0, 0, 0.52); } 5.三角形列表符号 该符号只能在CSS3里生成，在主流浏览器中，这是一项非常酷的技术。而其唯一的潜在问题是缺乏对后退方法的支持。 ul { margin: 0.75em 0; padding: 0 1em; list-style: none; } li:before { content: &quot;&quot;; border-color: transparent #111; border-style: solid; border-width: 0.35em 0 0.35em 0.45em; display: block; height: 0; width: 0; left: -1em; top: 0.9em; position: relative; } 6.居中对齐并设置固定宽度 效果： 居中对齐并设置固定宽度 #page-wrap { width: 800px; margin: 0 auto; } 7.CSS3列文本 效果： CSS3列文本 #columns-3 { text-align: justify; -moz-column-count: 3; -moz-column-gap: 12px; -moz-column-rule: 1px solid #c4c8cc; -webkit-column-count: 3; -webkit-column-gap: 12px; -webkit-column-rule: 1px solid #c4c8cc; } 8.固定页脚 在网页里添加固定的页脚其实非常简单，并且也很实用。有些网站的页脚 设计得很漂亮，可以给网站呈现出一个完美的结尾。 #footer { position: fixed; left: 0px; bottom: 0px; height: 30px; width: 100%; background: #444; } /* IE 6 */ * html #footer { position: absolute; top: expression((0-(footer.offsetHeight)+(document.documentElement.clientHeight ? document.documentElement.clientHeight : document.body.clientHeight)+(ignoreMe = document.documentElement.scrollTop ? document.documentElement.scrollTop : document.body.scrollTop))+&#39;px&#39;); } 9.IE 6下修复PNG格式的透明度 在网站里使用透明的图像已成为一种很普遍的做法，其始于.gif图片格式，但现在也涉及到.png图片格式。而一些老版本的IE不支持透明度，下面这段代码会很好地解决这一问题。 .bg { width:200px; height:100px; background: url(/folder/yourimage.png) no-repeat; _background:none; _filter:progid:DXImageTransform.Microsoft.AlphaImageLoader(src=&#39;/folder/yourimage.png&#39;,sizingMethod=&#39;crop&#39;); } /* 1px gif method */ img, .png { position: relative; behavior: expression((this.runtimeStyle.behavior=&quot;none&quot;)&amp;&amp;(this.pngSet?this.pngSet=true:(this.nodeName == &quot;IMG&quot; &amp;&amp; this.src.toLowerCase().indexOf(&#39;.png&#39;)&gt;-1?(this.runtimeStyle.backgroundImage = &quot;none&quot;, this.runtimeStyle.filter = &quot;progid:DXImageTransform.Microsoft.AlphaImageLoader(src=&#39;&quot; + this.src + &quot;&#39;, sizingMethod=&#39;image&#39;)&quot;, this.src = &quot;images/transparent.gif&quot;):(this.origBg = this.origBg? this.origBg :this.currentStyle.backgroundImage.toString().replace(&#39;url(&quot;&#39;,&#39;&#39;).replace(&#39;&quot;)&#39;,&#39;&#39;), this.runtimeStyle.filter = &quot;progid:DXImageTransform.Microsoft.AlphaImageLoader(src=&#39;&quot; + this.origBg + &quot;&#39;, sizingMethod=&#39;crop&#39;)&quot;, this.runtimeStyle.backgroundImage = &quot;none&quot;)),this.pngSet=true)); } 10.跨浏览器设置最小高度 有时开发者需要对HTML元素设置最小高度，然而，这个效果却无法兼容IE和老版本的Firefox，下面这段代码可以修复这个问题。 #container { min-height: 550px; height: auto !important; height: 550px; } 11. CSS3发光输入框 下面的这段代码重写了浏览器的默认行为，可以让Chrome和Safari浏览器下普通的表单输入框产生发光效果。 input[type=text], textarea { -webkit-transition: all 0.30s ease-in-out; -moz-transition: all 0.30s ease-in-out; -ms-transition: all 0.30s ease-in-out; -o-transition: all 0.30s ease-in-out; outline: none; padding: 3px 0px 3px 3px; margin: 5px 1px 3px 0px; border: 1px solid #ddd; } input[type=text]:focus, textarea:focus { box-shadow: 0 0 5px rgba(81, 203, 238, 1); padding: 3px 0px 3px 3px; margin: 5px 1px 3px 0px; border: 1px solid rgba(81, 203, 238, 1); } 12.基于文件类型来创建链接样式 下面这段代码通过使用CSS选择器和图像图标来实现各种类型的链接样式，可能会用到各种协议（HTTP、FTP、IRC,mailto），或者是文件本身的类型（mp3、avi、pdf）。 /* external links */ a[href^=&quot;http://&quot;] { padding-right: 13px; background: url(&#39;external.gif&#39;) no-repeat center right; } /* emails */ a[href^=&quot;mailto:&quot;] { padding-right: 20px; background: url(&#39;email.png&#39;) no-repeat center right; } /* pdfs */ a[href$=&quot;.pdf&quot;] { padding-right: 18px; background: url(&#39;acrobat.png&#39;) no-repeat center right; } 13.pre标签封装代码 pre标签常用来对代码进行布局，可以解决因为行太多带来的滚动条问题。下面这段代码就使用pre来封装代码，让内容直接显示在页面中。 pre { white-space: pre-wrap; /* css-3 */ white-space: -moz-pre-wrap; /* Mozilla, since 1999 */ white-space: -pre-wrap; /* Opera 4-6 */ white-space: -o-pre-wrap; /* Opera 7 */ word-wrap: break-word; /* Internet Explorer 5.5+ */ } 14.鼠标指向时变成手型 网页中有许多item在点击时，鼠标不会变成小手的形状。这套CSS选择器会强迫鼠标越过一些关键元素和其他对象一起来使用.pointer这个类。 a[href], input[type=&#39;submit&#39;], input[type=&#39;image&#39;], label[for], select, button, .pointer { cursor: pointer; } 15.页面顶部阴影 简单地把下面这段代码拷贝到页面里，它会在body元素之前产生黑色的，渐渐变淡的阴影。这种效果通常用来给一个文本框或网页元素加阴影。 body:before { content: &quot;&quot;; position: fixed; top: -10px; left: 0; width: 100%; height: 10px; -webkit-box-shadow: 0px 0px 10px rgba(0,0,0,.8); -moz-box-shadow: 0px 0px 10px rgba(0,0,0,.8); box-shadow: 0px 0px 10px rgba(0,0,0,.8); z-index: 100; } 16.气泡引用效果 这种效果常出现在论坛、创建公告牌或者是文本引用上。你只需把下面这段代码拷贝到样式表文件即可。 这里（需翻墙）提供了许多关于语音泡泡的代码片段和使用技巧，欢迎去围观。 .chat-bubble { background-color: #ededed; border: 2px solid #666; font-size: 35px; line-height: 1.3em; margin: 10px auto; padding: 10px; position: relative; text-align: center; width: 300px; -moz-border-radius: 20px; -webkit-border-radius: 20px; -moz-box-shadow: 0 0 5px #888; -webkit-box-shadow: 0 0 5px #888; font-family: &#39;Bangers&#39;, arial, serif; } .chat-bubble-arrow-border { border-color: #666 transparent transparent transparent; border-style: solid; border-width: 20px; height: 0; width: 0; position: absolute; bottom: -42px; left: 30px; } .chat-bubble-arrow { border-color: #ededed transparent transparent transparent; border-style: solid; border-width: 20px; height: 0; width: 0; position: absolute; bottom: -39px; left: 30px; } 17.指定标题样式 该模板提供了所有头元素的主要样式，从H1到H5。 h1,h2,h3,h4,h5{ color: #005a9c; } h1{ font-size: 2.6em; line-height: 2.45em; } h2{ font-size: 2.1em; line-height: 1.9em; } h3{ font-size: 1.8em; line-height: 1.65em; } h4{ font-size: 1.65em; line-height: 1.4em; } h5{ font-size: 1.4em; line-height: 1.25em; } 18.利用CSS生成纹理图案背景 通过CSS来为背景图片添加噪点，从而形成漂亮的纹理图案。你可以使用 NoiseTextureGenerator生成器自定义噪点的纹理图案。 body { background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAMAAAAp4XiDAAAAUVBMVEWFhYWDg4N3d3dtbW17e3t1dXWBgYGHh4d5eXlzc3OLi4ubm5uVlZWPj4+NjY19fX2JiYl/f39ra2uRkZGZmZlpaWmXl5dvb29xcXGTk5NnZ2c8TV1mAAAAG3RSTlNAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAvEOwtAAAFVklEQVR4XpWWB67c2BUFb3g557T/hRo9/WUMZHlgr4Bg8Z4qQgQJlHI4A8SzFVrapvmTF9O7dmYRFZ60YiBhJRCgh1FYhiLAmdvX0CzTOpNE77ME0Zty/nWWzchDtiqrmQDeuv3powQ5ta2eN0FY0InkqDD73lT9c9lEzwUNqgFHs9VQce3TVClFCQrSTfOiYkVJQBmpbq2L6iZavPnAPcoU0dSw0SUTqz/GtrGuXfbyyBniKykOWQWGqwwMA7QiYAxi+IlPdqo+hYHnUt5ZPfnsHJyNiDtnpJyayNBkF6cWoYGAMY92U2hXHF/C1M8uP/ZtYdiuj26UdAdQQSXQErwSOMzt/XWRWAz5GuSBIkwG1H3FabJ2OsUOUhGC6tK4EMtJO0ttC6IBD3kM0ve0tJwMdSfjZo+EEISaeTr9P3wYrGjXqyC1krcKdhMpxEnt5JetoulscpyzhXN5FRpuPHvbeQaKxFAEB6EN+cYN6xD7RYGpXpNndMmZgM5Dcs3YSNFDHUo2LGfZuukSWyUYirJAdYbF3MfqEKmjM+I2EfhA94iG3L7uKrR+GdWD73ydlIB+6hgref1QTlmgmbM3/LeX5GI1Ux1RWpgxpLuZ2+I+IjzZ8wqE4nilvQdkUdfhzI5QDWy+kw5Wgg2pGpeEVeCCA7b85BO3F9DzxB3cdqvBzWcmzbyMiqhzuYqtHRVG2y4x+KOlnyqla8AoWWpuBoYRxzXrfKuILl6SfiWCbjxoZJUaCBj1CjH7GIaDbc9kqBY3W/Rgjda1iqQcOJu2WW+76pZC9QG7M00dffe9hNnseupFL53r8F7YHSwJWUKP2q+k7RdsxyOB11n0xtOvnW4irMMFNV4H0uqwS5ExsmP9AxbDTc9JwgneAT5vTiUSm1E7BSflSt3bfa1tv8Di3R8n3Af7MNWzs49hmauE2wP+ttrq+AsWpFG2awvsuOqbipWHgtuvuaAE+A1Z/7gC9hesnr+7wqCwG8c5yAg3AL1fm8T9AZtp/bbJGwl1pNrE7RuOX7PeMRUERVaPpEs+yqeoSmuOlokqw49pgomjLeh7icHNlG19yjs6XXOMedYm5xH2YxpV2tc0Ro2jJfxC50ApuxGob7lMsxfTbeUv07TyYxpeLucEH1gNd4IKH2LAg5TdVhlCafZvpskfncCfx8pOhJzd76bJWeYFnFciwcYfubRc12Ip/ppIhA1/mSZ/RxjFDrJC5xifFjJpY2Xl5zXdguFqYyTR1zSp1Y9p+tktDYYSNflcxI0iyO4TPBdlRcpeqjK/piF5bklq77VSEaA+z8qmJTFzIWiitbnzR794USKBUaT0NTEsVjZqLaFVqJoPN9ODG70IPbfBHKK+/q/AWR0tJzYHRULOa4MP+W/HfGadZUbfw177G7j/OGbIs8TahLyynl4X4RinF793Oz+BU0saXtUHrVBFT/DnA3ctNPoGbs4hRIjTok8i+algT1lTHi4SxFvONKNrgQFAq2/gFnWMXgwffgYMJpiKYkmW3tTg3ZQ9Jq+f8XN+A5eeUKHWvJWJ2sgJ1Sop+wwhqFVijqWaJhwtD8MNlSBeWNNWTa5Z5kPZw5+LbVT99wqTdx29lMUH4OIG/D86ruKEauBjvH5xy6um/Sfj7ei6UUVk4AIl3MyD4MSSTOFgSwsH/QJWaQ5as7ZcmgBZkzjjU1UrQ74ci1gWBCSGHtuV1H2mhSnO3Wp/3fEV5a+4wz//6qy8JxjZsmxxy5+4w9CDNJY09T072iKG0EnOS0arEYgXqYnXcYHwjTtUNAcMelOd4xpkoqiTYICWFq0JSiPfPDQdnt+4/wuqcXY47QILbgAAAABJRU5ErkJggg==); background-color: #0094d0; } 19.List Ordering 你可能会遇到这种列表情况，需要把这个列表拆分成两个UL元素，你不妨看看下面这段代码。 ol.chapters { list-style: none; margin-left: 0; } ol.chapters &gt; li:before { content: counter(chapter) &quot;. &quot;; counter-increment: chapter; font-weight: bold; float: left; width: 40px; } ol.chapters li { clear: left; } ol.start { counter-reset: chapter; } ol.continue { counter-reset: chapter 11; } 20.为文本添加悬停提示框 把这段代码拷贝到样式表中，使用新的HTML5数据属性，通过使用data-tooltip你就可以给文本添加悬停提示框了。 a { border-bottom:1px solid #bbb; color:#666; display:inline-block; position:relative; text-decoration:none; } a:hover, a:focus { color:#36c; } a:active { top:1px; } /* Tooltip styling */ a[data-tooltip]:after { border-top: 8px solid #222; border-top: 8px solid hsla(0,0%,0%,.85); border-left: 8px solid transparent; border-right: 8px solid transparent; content: &quot;&quot;; display: none; height: 0; width: 0; left: 25%; position: absolute; } a[data-tooltip]:before { background: #222; background: hsla(0,0%,0%,.85); color: #f6f6f6; content: attr(data-tooltip); display: none; font-family: sans-serif; font-size: 14px; height: 32px; left: 0; line-height: 32px; padding: 0 15px; position: absolute; text-shadow: 0 1px 1px hsla(0,0%,0%,1); white-space: nowrap; -webkit-border-radius: 5px; -moz-border-radius: 5px; -o-border-radius: 5px; border-radius: 5px; } a[data-tooltip]:hover:after { display: block; top: -9px; } a[data-tooltip]:hover:before { display: block; top: -41px; } a[data-tooltip]:active:after { top: -10px; } a[data-tooltip]:active:before { top: -42px; } 21.创建暗灰色的按钮样式 下面这段代码创建了CSS3按钮类，并根据按钮颜色命名为.graybtn。当然你也可以根据自己的网站风格对颜色进行更改。 .graybtn { -moz-box-shadow:inset 0px 1px 0px 0px #ffffff; -webkit-box-shadow:inset 0px 1px 0px 0px #ffffff; box-shadow:inset 0px 1px 0px 0px #ffffff; background:-webkit-gradient( linear, left top, left bottom, color-stop(0.05, #ffffff), color-stop(1, #d1d1d1) ); background:-moz-linear-gradient( center top, #ffffff 5%, #d1d1d1 100% ); filter:progid:DXImageTransform.Microsoft.gradient(startColorstr=&#39;#ffffff&#39;, endColorstr=&#39;#d1d1d1&#39;); background-color:#ffffff; -moz-border-radius:6px; -webkit-border-radius:6px; border-radius:6px; border:1px solid #dcdcdc; display:inline-block; color:#777777; font-family:arial; font-size:15px; font-weight:bold; padding:6px 24px; text-decoration:none; text-shadow:1px 1px 0px #ffffff; } .graybtn:hover { background:-webkit-gradient( linear, left top, left bottom, color-stop(0.05, #d1d1d1), color-stop(1, #ffffff) ); background:-moz-linear-gradient( center top, #d1d1d1 5%, #ffffff 100% ); filter:progid:DXImageTransform.Microsoft.gradient(startColorstr=&#39;#d1d1d1&#39;, endColorstr=&#39;#ffffff&#39;); background-color:#d1d1d1; } .graybtn:active { position:relative; top:1px; } 22.打印的页面上显示URL 这条规则会使打印出来的页面在超链接文字后面加上URL，URL会被放在一组括号里面,前后各留一个空格。 @media print { a:after { content: &quot; [&quot; attr(href) &quot;] &quot;; } } 23.屏蔽Webkit移动浏览器中元素高亮效果 在访问移动网站时，你会发现，在选中的元素周围会出现一些灰色的框框，而下面这段代码即可屏蔽这种样式。 body { -webkit-touch-callout: none; -webkit-user-select: none; -khtml-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; } 24.利用CSS生成小圆点图案 通过下面的代码，可以让你的网站背景上产生一些小圆点装饰图案。默认情况下，它是使用在body元素上，但你也可以把它使用在网页里的其他容器上。 body { background: radial-gradient(circle, white 10%, transparent 10%), radial-gradient(circle, white 10%, black 10%) 50px 50px; background-size: 100px 100px; } 25.CSS3棋盘格效果 和上面的小圆点设计一样，这个效果需要一些额外的语法才可以工作，它需要在支持CSS3的浏览器上运行，效果很艳丽。当然，你可以根据需要自定义颜色。 body { background-color: white; background-image: linear-gradient(45deg, black 25%, transparent 25%, transparent 75%, black 75%, black), linear-gradient(45deg, black 25%, transparent 25%, transparent 75%, black 75%, black); background-size: 100px 100px; background-position: 0 0, 50px 50px; } 26.Github Fork红丝带 下面这段代码是利用CSS3的transform属性生成Fork me on Github红丝带效果。 .ribbon { background-color: #a00; overflow: hidden; /* top left corner */ position: absolute; left: -3em; top: 2.5em; /* 45 deg ccw rotation */ -moz-transform: rotate(-45deg); -webkit-transform: rotate(-45deg); /* shadow */ -moz-box-shadow: 0 0 1em #888; -webkit-box-shadow: 0 0 1em #888; } .ribbon a { border: 1px solid #faa; color: #fff; display: block; font: bold 81.25% &#39;Helvetiva Neue&#39;, Helvetica, Arial, sans-serif; margin: 0.05em 0 0.075em 0; padding: 0.5em 3.5em; text-align: center; text-decoration: none; /* shadow */ text-shadow: 0 0 0.5em #444; } 27.字体压缩 在样式表里使用如下代码能够帮你节省许多网页空间。 p { font: italic small-caps bold 1.2em/1.0em Arial, Tahoma, Helvetica; } 28.纸页面卷曲效果 这种效果可以被广泛的使用在多种容器中，查看 demo page页面来更好地掌握该函数的使用吧。 ul.box { position: relative; z-index: 1; /*prevent shadows falling behind containers with backgrounds*/ overflow: hidden; list-style: none; margin: 0; padding: 0; } ul.box li { position: relative; float: left; width: 250px; height: 150px; padding: 0; border: 1px solid #efefef; margin: 0 30px 30px 0; background: #fff; -webkit-box-shadow: 0 1px 4px rgba(0, 0, 0, 0.27), 0 0 40px rgba(0, 0, 0, 0.06) inset; -moz-box-shadow: 0 1px 4px rgba(0, 0, 0, 0.27), 0 0 40px rgba(0, 0, 0, 0.06) inset; box-shadow: 0 1px 4px rgba(0, 0, 0, 0.27), 0 0 40px rgba(0, 0, 0, 0.06) inset; } ul.box li:before, ul.box li:after { content: &#39;&#39;; z-index: -1; position: absolute; left: 10px; bottom: 10px; width: 70%; max-width: 300px; /*avoid rotation causing ugly appearance at large container widths*/ max-height: 100px; height: 55%; -webkit-box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3); -moz-box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3); box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3); -webkit-transform: skew(-15deg) rotate(-6deg); -moz-transform: skew(-15deg) rotate(-6deg); -ms-transform: skew(-15deg) rotate(-6deg); -o-transform: skew(-15deg) rotate(-6deg); transform: skew(-15deg) rotate(-6deg); } ul.box li:after { left: auto; right: 10px; -webkit-transform: skew(15deg) rotate(6deg); -moz-transform: skew(15deg) rotate(6deg); -ms-transform: skew(15deg) rotate(6deg); -o-transform: skew(15deg) rotate(6deg); transform: skew(15deg) rotate(6deg); } 29.发光的锚链接 下面这段代码可以创建自定义的锚链接，鼠标悬浮在上面会发光。 a { color: #00e; } a:visited { color: #551a8b; } a:hover { color: #06e; } a:focus { outline: thin dotted; } a:hover, a:active { outline: 0; } a, a:visited, a:active { text-decoration: none; color: #fff; -webkit-transition: all .3s ease-in-out; } a:hover, .glow { color: #ff0; text-shadow: 0 0 10px #ff0; } 30.创建CSS3 Banner 在支持CSS3的浏览器中，下面的代码可以生成漂亮的纯CSS图案。这种效果常见于电子商务网站的产品图片、缩略图、视频预览等。 .featureBanner { position: relative; margin: 20px } .featureBanner:before { content: &quot;Featured&quot;; position: absolute; top: 5px; left: -8px; padding-right: 10px; color: #232323; font-weight: bold; height: 0px; border: 15px solid #ffa200; border-right-color: transparent; line-height: 0px; box-shadow: -0px 5px 5px -5px #000; z-index: 1; } .featureBanner:after { content: &quot;&quot;; position: absolute; top: 35px; left: -8px; border: 4px solid #89540c; border-left-color: transparent; border-bottom-color: transparent; }","content":"<h2 id=\"1-花式连字符\"><a href=\"#1-花式连字符\" class=\"headerlink\" title=\"1.花式连字符\"></a>1.花式连字符</h2><ul>\n<li>这个类应该在span元素里使用，并且里面包括&amp;字符。它使用经典的serif字体和斜体来增强&amp;符号</li>\n</ul>\n<pre><code>.amp {\n    font-family: Baskerville, &#39;Goudy Old Style&#39;, Palatino, &#39;Book Antiqua&#39;, serif;\n    font-style: italic;\n    font-weight: normal;\n}\n</code></pre><h2 id=\"2-段落首字符下沉\"><a href=\"#2-段落首字符下沉\" class=\"headerlink\" title=\"2.段落首字符下沉\"></a>2.段落首字符下沉</h2><ul>\n<li>通常，这种效果会出现在印刷媒体上，如报纸或书籍。同样，如果网页布局合理，它也可以使用在Web页面上，它仅针对段落使用，但你也可以与单个元素绑定</li>\n</ul>\n<pre><code>p:first-letter{\n    display: block;\n    margin: 5px 0 0 5px;\n    float: left;\n    color: #ff3366;\n    font-size: 5.4em;\n    font-family: Georgia, Times New Roman, serif;\n}\n</code></pre><h2 id=\"3-内层CSS3盒阴影\"><a href=\"#3-内层CSS3盒阴影\" class=\"headerlink\" title=\"3.内层CSS3盒阴影\"></a>3.内层CSS3盒阴影</h2><ul>\n<li>盒阴影（box shadow）属性几乎可以运用在任何元素上，它们看起来都非常好看。下面这段代码主要聚焦内层阴影的设计。</li>\n</ul>\n<pre><code>#mydiv {\n    -moz-box-shadow: inset 2px 0 4px #000;\n    -webkit-box-shadow: inset 2px 0 4px #000;\n    box-shadow: inset 2px 0 4px #000;\n}\n</code></pre><h2 id=\"4-外层CSS3盒阴影\"><a href=\"#4-外层CSS3盒阴影\" class=\"headerlink\" title=\"4.外层CSS3盒阴影\"></a>4.外层CSS3盒阴影</h2><ul>\n<li>下面介绍一段外层阴影代码设计，注意，代码里的第三个参数表示模糊距离（blur distance），而第四个参数表示铺开的（spread）距离。关于这些值的设计，你可以前往 W3Schools学习。</li>\n</ul>\n<pre><code>#mydiv {\n    -webkit-box-shadow: 0 2px 2px -2px rgba(0, 0, 0, 0.52);\n    -moz-box-shadow: 0 2px 2px -2px rgba(0, 0, 0, 0.52);\n    box-shadow: 0 2px 2px -2px rgba(0, 0, 0, 0.52);\n}\n</code></pre><h2 id=\"5-三角形列表符号\"><a href=\"#5-三角形列表符号\" class=\"headerlink\" title=\"5.三角形列表符号\"></a>5.三角形列表符号</h2><ul>\n<li>该符号只能在CSS3里生成，在主流浏览器中，这是一项非常酷的技术。而其唯一的潜在问题是缺乏对后退方法的支持。</li>\n</ul>\n<pre><code>ul {\n    margin: 0.75em 0;\n    padding: 0 1em;\n    list-style: none;\n}\nli:before {\n    content: &quot;&quot;;\n    border-color: transparent #111;\n    border-style: solid;\n    border-width: 0.35em 0 0.35em 0.45em;\n    display: block;\n    height: 0;\n    width: 0;\n    left: -1em;\n    top: 0.9em;\n    position: relative;\n}\n</code></pre><h2 id=\"6-居中对齐并设置固定宽度\"><a href=\"#6-居中对齐并设置固定宽度\" class=\"headerlink\" title=\"6.居中对齐并设置固定宽度\"></a>6.居中对齐并设置固定宽度</h2><ul>\n<li>效果： 居中对齐并设置固定宽度</li>\n</ul>\n<pre><code>#page-wrap {\n    width: 800px;\n    margin: 0 auto;\n}\n</code></pre><h2 id=\"7-CSS3列文本\"><a href=\"#7-CSS3列文本\" class=\"headerlink\" title=\"7.CSS3列文本\"></a>7.CSS3列文本</h2><ul>\n<li>效果： CSS3列文本</li>\n</ul>\n<pre><code>#columns-3 {\n    text-align: justify;\n    -moz-column-count: 3;\n    -moz-column-gap: 12px;\n    -moz-column-rule: 1px solid #c4c8cc;\n    -webkit-column-count: 3;\n    -webkit-column-gap: 12px;\n    -webkit-column-rule: 1px solid #c4c8cc;\n}\n</code></pre><h2 id=\"8-固定页脚\"><a href=\"#8-固定页脚\" class=\"headerlink\" title=\"8.固定页脚\"></a>8.固定页脚</h2><ul>\n<li>在网页里添加固定的页脚其实非常简单，并且也很实用。有些网站的页脚 设计得很漂亮，可以给网站呈现出一个完美的结尾。</li>\n</ul>\n<pre><code>#footer {\n    position: fixed;\n    left: 0px;\n    bottom: 0px;\n    height: 30px;\n    width: 100%;\n    background: #444;\n}\n/* IE 6 */\n* html #footer {\n    position: absolute;\n    top: expression((0-(footer.offsetHeight)+(document.documentElement.clientHeight ? document.documentElement.clientHeight : document.body.clientHeight)+(ignoreMe = document.documentElement.scrollTop ? document.documentElement.scrollTop : document.body.scrollTop))+&#39;px&#39;);\n}\n</code></pre><h2 id=\"9-IE-6下修复PNG格式的透明度\"><a href=\"#9-IE-6下修复PNG格式的透明度\" class=\"headerlink\" title=\"9.IE 6下修复PNG格式的透明度\"></a>9.IE 6下修复PNG格式的透明度</h2><ul>\n<li>在网站里使用透明的图像已成为一种很普遍的做法，其始于.gif图片格式，但现在也涉及到.png图片格式。而一些老版本的IE不支持透明度，下面这段代码会很好地解决这一问题。</li>\n</ul>\n<pre><code>.bg {\n    width:200px;\n    height:100px;\n    background: url(/folder/yourimage.png) no-repeat;\n    _background:none;\n    _filter:progid:DXImageTransform.Microsoft.AlphaImageLoader(src=&#39;/folder/yourimage.png&#39;,sizingMethod=&#39;crop&#39;);\n}\n/* 1px gif method */\nimg, .png {\n    position: relative;\n    behavior: expression((this.runtimeStyle.behavior=&quot;none&quot;)&amp;&amp;(this.pngSet?this.pngSet=true:(this.nodeName == &quot;IMG&quot; &amp;&amp; this.src.toLowerCase().indexOf(&#39;.png&#39;)&gt;-1?(this.runtimeStyle.backgroundImage = &quot;none&quot;,\n       this.runtimeStyle.filter = &quot;progid:DXImageTransform.Microsoft.AlphaImageLoader(src=&#39;&quot; + this.src + &quot;&#39;, sizingMethod=&#39;image&#39;)&quot;,\n       this.src = &quot;images/transparent.gif&quot;):(this.origBg = this.origBg? this.origBg :this.currentStyle.backgroundImage.toString().replace(&#39;url(&quot;&#39;,&#39;&#39;).replace(&#39;&quot;)&#39;,&#39;&#39;),\n       this.runtimeStyle.filter = &quot;progid:DXImageTransform.Microsoft.AlphaImageLoader(src=&#39;&quot; + this.origBg + &quot;&#39;, sizingMethod=&#39;crop&#39;)&quot;,\n       this.runtimeStyle.backgroundImage = &quot;none&quot;)),this.pngSet=true));\n}\n</code></pre><h2 id=\"10-跨浏览器设置最小高度\"><a href=\"#10-跨浏览器设置最小高度\" class=\"headerlink\" title=\"10.跨浏览器设置最小高度\"></a>10.跨浏览器设置最小高度</h2><ul>\n<li>有时开发者需要对HTML元素设置最小高度，然而，这个效果却无法兼容IE和老版本的Firefox，下面这段代码可以修复这个问题。</li>\n</ul>\n<pre><code>#container {\n    min-height: 550px;\n    height: auto !important;\n    height: 550px;\n}\n</code></pre><h2 id=\"11-CSS3发光输入框\"><a href=\"#11-CSS3发光输入框\" class=\"headerlink\" title=\"11. CSS3发光输入框\"></a>11. CSS3发光输入框</h2><ul>\n<li>下面的这段代码重写了浏览器的默认行为，可以让Chrome和Safari浏览器下普通的表单输入框产生发光效果。</li>\n</ul>\n<pre><code>input[type=text], textarea {\n    -webkit-transition: all 0.30s ease-in-out;\n    -moz-transition: all 0.30s ease-in-out;\n    -ms-transition: all 0.30s ease-in-out;\n    -o-transition: all 0.30s ease-in-out;\n    outline: none;\n    padding: 3px 0px 3px 3px;\n    margin: 5px 1px 3px 0px;\n    border: 1px solid #ddd;\n}\ninput[type=text]:focus, textarea:focus {\n    box-shadow: 0 0 5px rgba(81, 203, 238, 1);\n    padding: 3px 0px 3px 3px;\n    margin: 5px 1px 3px 0px;\n    border: 1px solid rgba(81, 203, 238, 1);\n}\n</code></pre><h2 id=\"12-基于文件类型来创建链接样式\"><a href=\"#12-基于文件类型来创建链接样式\" class=\"headerlink\" title=\"12.基于文件类型来创建链接样式\"></a>12.基于文件类型来创建链接样式</h2><ul>\n<li>下面这段代码通过使用CSS选择器和图像图标来实现各种类型的链接样式，可能会用到各种协议（HTTP、FTP、IRC,mailto），或者是文件本身的类型（mp3、avi、pdf）。</li>\n</ul>\n<pre><code>/* external links */\na[href^=&quot;http://&quot;] {\n    padding-right: 13px;\n    background: url(&#39;external.gif&#39;) no-repeat center right;\n}\n/* emails */\na[href^=&quot;mailto:&quot;] {\n    padding-right: 20px;\n    background: url(&#39;email.png&#39;) no-repeat center right;\n}\n/* pdfs */\na[href$=&quot;.pdf&quot;] {\n    padding-right: 18px;\n    background: url(&#39;acrobat.png&#39;) no-repeat center right;\n}\n</code></pre><h2 id=\"13-pre标签封装代码\"><a href=\"#13-pre标签封装代码\" class=\"headerlink\" title=\"13.pre标签封装代码\"></a>13.pre标签封装代码</h2><ul>\n<li>pre标签常用来对代码进行布局，可以解决因为行太多带来的滚动条问题。下面这段代码就使用pre来封装代码，让内容直接显示在页面中。</li>\n</ul>\n<pre><code>pre {\n    white-space: pre-wrap;       /* css-3 */\n    white-space: -moz-pre-wrap;  /* Mozilla, since 1999 */\n    white-space: -pre-wrap;      /* Opera 4-6 */\n    white-space: -o-pre-wrap;    /* Opera 7 */\n    word-wrap: break-word;       /* Internet Explorer 5.5+ */\n}\n</code></pre><h2 id=\"14-鼠标指向时变成手型\"><a href=\"#14-鼠标指向时变成手型\" class=\"headerlink\" title=\"14.鼠标指向时变成手型\"></a>14.鼠标指向时变成手型</h2><ul>\n<li>网页中有许多item在点击时，鼠标不会变成小手的形状。这套CSS选择器会强迫鼠标越过一些关键元素和其他对象一起来使用.pointer这个类。</li>\n</ul>\n<pre><code>a[href], input[type=&#39;submit&#39;], input[type=&#39;image&#39;], label[for], select, button, .pointer {\n    cursor: pointer;\n}\n</code></pre><h2 id=\"15-页面顶部阴影\"><a href=\"#15-页面顶部阴影\" class=\"headerlink\" title=\"15.页面顶部阴影\"></a>15.页面顶部阴影</h2><ul>\n<li>简单地把下面这段代码拷贝到页面里，它会在body元素之前产生黑色的，渐渐变淡的阴影。这种效果通常用来给一个文本框或网页元素加阴影。</li>\n</ul>\n<pre><code>body:before {\n    content: &quot;&quot;;\n    position: fixed;\n    top: -10px;\n    left: 0;\n    width: 100%;\n    height: 10px;\n    -webkit-box-shadow: 0px 0px 10px rgba(0,0,0,.8);\n    -moz-box-shadow: 0px 0px 10px rgba(0,0,0,.8);\n    box-shadow: 0px 0px 10px rgba(0,0,0,.8);\n    z-index: 100;\n}\n</code></pre><h2 id=\"16-气泡引用效果\"><a href=\"#16-气泡引用效果\" class=\"headerlink\" title=\"16.气泡引用效果\"></a>16.气泡引用效果</h2><ul>\n<li>这种效果常出现在论坛、创建公告牌或者是文本引用上。你只需把下面这段代码拷贝到样式表文件即可。 这里（需翻墙）提供了许多关于语音泡泡的代码片段和使用技巧，欢迎去围观。</li>\n</ul>\n<pre><code>.chat-bubble {\n    background-color: #ededed;\n    border: 2px solid #666;\n    font-size: 35px;\n    line-height: 1.3em;\n    margin: 10px auto;\n    padding: 10px;\n    position: relative;\n    text-align: center;\n    width: 300px;\n    -moz-border-radius: 20px;\n    -webkit-border-radius: 20px;\n    -moz-box-shadow: 0 0 5px #888;\n    -webkit-box-shadow: 0 0 5px #888;\n    font-family: &#39;Bangers&#39;, arial, serif;\n}\n.chat-bubble-arrow-border {\n    border-color: #666 transparent transparent transparent;\n    border-style: solid;\n    border-width: 20px;\n    height: 0;\n    width: 0;\n    position: absolute;\n    bottom: -42px;\n    left: 30px;\n}\n.chat-bubble-arrow {\n    border-color: #ededed transparent transparent transparent;\n    border-style: solid;\n    border-width: 20px;\n    height: 0;\n    width: 0;\n    position: absolute;\n    bottom: -39px;\n    left: 30px;\n}\n</code></pre><h2 id=\"17-指定标题样式\"><a href=\"#17-指定标题样式\" class=\"headerlink\" title=\"17.指定标题样式\"></a>17.指定标题样式</h2><ul>\n<li>该模板提供了所有头元素的主要样式，从H1到H5。</li>\n</ul>\n<pre><code>h1,h2,h3,h4,h5{\n    color: #005a9c;\n}\nh1{\n    font-size: 2.6em;\n    line-height: 2.45em;\n}\nh2{\n    font-size: 2.1em;\n    line-height: 1.9em;\n}\nh3{\n    font-size: 1.8em;\n    line-height: 1.65em;\n}\nh4{\n    font-size: 1.65em;\n    line-height: 1.4em;\n}\nh5{\n    font-size: 1.4em;\n    line-height: 1.25em;\n}\n</code></pre><h2 id=\"18-利用CSS生成纹理图案背景\"><a href=\"#18-利用CSS生成纹理图案背景\" class=\"headerlink\" title=\"18.利用CSS生成纹理图案背景\"></a>18.利用CSS生成纹理图案背景</h2><ul>\n<li>通过CSS来为背景图片添加噪点，从而形成漂亮的纹理图案。你可以使用 NoiseTextureGenerator生成器自定义噪点的纹理图案。</li>\n</ul>\n<pre><code>body {\n    background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAMAAAAp4XiDAAAAUVBMVEWFhYWDg4N3d3dtbW17e3t1dXWBgYGHh4d5eXlzc3OLi4ubm5uVlZWPj4+NjY19fX2JiYl/f39ra2uRkZGZmZlpaWmXl5dvb29xcXGTk5NnZ2c8TV1mAAAAG3RSTlNAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAvEOwtAAAFVklEQVR4XpWWB67c2BUFb3g557T/hRo9/WUMZHlgr4Bg8Z4qQgQJlHI4A8SzFVrapvmTF9O7dmYRFZ60YiBhJRCgh1FYhiLAmdvX0CzTOpNE77ME0Zty/nWWzchDtiqrmQDeuv3powQ5ta2eN0FY0InkqDD73lT9c9lEzwUNqgFHs9VQce3TVClFCQrSTfOiYkVJQBmpbq2L6iZavPnAPcoU0dSw0SUTqz/GtrGuXfbyyBniKykOWQWGqwwMA7QiYAxi+IlPdqo+hYHnUt5ZPfnsHJyNiDtnpJyayNBkF6cWoYGAMY92U2hXHF/C1M8uP/ZtYdiuj26UdAdQQSXQErwSOMzt/XWRWAz5GuSBIkwG1H3FabJ2OsUOUhGC6tK4EMtJO0ttC6IBD3kM0ve0tJwMdSfjZo+EEISaeTr9P3wYrGjXqyC1krcKdhMpxEnt5JetoulscpyzhXN5FRpuPHvbeQaKxFAEB6EN+cYN6xD7RYGpXpNndMmZgM5Dcs3YSNFDHUo2LGfZuukSWyUYirJAdYbF3MfqEKmjM+I2EfhA94iG3L7uKrR+GdWD73ydlIB+6hgref1QTlmgmbM3/LeX5GI1Ux1RWpgxpLuZ2+I+IjzZ8wqE4nilvQdkUdfhzI5QDWy+kw5Wgg2pGpeEVeCCA7b85BO3F9DzxB3cdqvBzWcmzbyMiqhzuYqtHRVG2y4x+KOlnyqla8AoWWpuBoYRxzXrfKuILl6SfiWCbjxoZJUaCBj1CjH7GIaDbc9kqBY3W/Rgjda1iqQcOJu2WW+76pZC9QG7M00dffe9hNnseupFL53r8F7YHSwJWUKP2q+k7RdsxyOB11n0xtOvnW4irMMFNV4H0uqwS5ExsmP9AxbDTc9JwgneAT5vTiUSm1E7BSflSt3bfa1tv8Di3R8n3Af7MNWzs49hmauE2wP+ttrq+AsWpFG2awvsuOqbipWHgtuvuaAE+A1Z/7gC9hesnr+7wqCwG8c5yAg3AL1fm8T9AZtp/bbJGwl1pNrE7RuOX7PeMRUERVaPpEs+yqeoSmuOlokqw49pgomjLeh7icHNlG19yjs6XXOMedYm5xH2YxpV2tc0Ro2jJfxC50ApuxGob7lMsxfTbeUv07TyYxpeLucEH1gNd4IKH2LAg5TdVhlCafZvpskfncCfx8pOhJzd76bJWeYFnFciwcYfubRc12Ip/ppIhA1/mSZ/RxjFDrJC5xifFjJpY2Xl5zXdguFqYyTR1zSp1Y9p+tktDYYSNflcxI0iyO4TPBdlRcpeqjK/piF5bklq77VSEaA+z8qmJTFzIWiitbnzR794USKBUaT0NTEsVjZqLaFVqJoPN9ODG70IPbfBHKK+/q/AWR0tJzYHRULOa4MP+W/HfGadZUbfw177G7j/OGbIs8TahLyynl4X4RinF793Oz+BU0saXtUHrVBFT/DnA3ctNPoGbs4hRIjTok8i+algT1lTHi4SxFvONKNrgQFAq2/gFnWMXgwffgYMJpiKYkmW3tTg3ZQ9Jq+f8XN+A5eeUKHWvJWJ2sgJ1Sop+wwhqFVijqWaJhwtD8MNlSBeWNNWTa5Z5kPZw5+LbVT99wqTdx29lMUH4OIG/D86ruKEauBjvH5xy6um/Sfj7ei6UUVk4AIl3MyD4MSSTOFgSwsH/QJWaQ5as7ZcmgBZkzjjU1UrQ74ci1gWBCSGHtuV1H2mhSnO3Wp/3fEV5a+4wz//6qy8JxjZsmxxy5+4w9CDNJY09T072iKG0EnOS0arEYgXqYnXcYHwjTtUNAcMelOd4xpkoqiTYICWFq0JSiPfPDQdnt+4/wuqcXY47QILbgAAAABJRU5ErkJggg==);\n    background-color: #0094d0;\n}\n</code></pre><h2 id=\"19-List-Ordering\"><a href=\"#19-List-Ordering\" class=\"headerlink\" title=\"19.List Ordering\"></a>19.List Ordering</h2><ul>\n<li>你可能会遇到这种列表情况，需要把这个列表拆分成两个UL元素，你不妨看看下面这段代码。</li>\n</ul>\n<pre><code>ol.chapters {\n    list-style: none;\n    margin-left: 0;\n}\nol.chapters &gt; li:before {\n    content: counter(chapter) &quot;. &quot;;\n    counter-increment: chapter;\n    font-weight: bold;\n    float: left;\n    width: 40px;\n}\nol.chapters li {\n    clear: left;\n}\nol.start {\n    counter-reset: chapter;\n}\nol.continue {\n    counter-reset: chapter 11;\n}\n</code></pre><h2 id=\"20-为文本添加悬停提示框\"><a href=\"#20-为文本添加悬停提示框\" class=\"headerlink\" title=\"20.为文本添加悬停提示框\"></a>20.为文本添加悬停提示框</h2><ul>\n<li>把这段代码拷贝到样式表中，使用新的HTML5数据属性，通过使用data-tooltip你就可以给文本添加悬停提示框了。</li>\n</ul>\n<pre><code>a {\n    border-bottom:1px solid #bbb;\n    color:#666;\n    display:inline-block;\n    position:relative;\n    text-decoration:none;\n}\na:hover,\na:focus {\n    color:#36c;\n}\na:active {\n    top:1px;\n}\n/* Tooltip styling */\na[data-tooltip]:after {\n    border-top: 8px solid #222;\n    border-top: 8px solid hsla(0,0%,0%,.85);\n    border-left: 8px solid transparent;\n    border-right: 8px solid transparent;\n    content: &quot;&quot;;\n    display: none;\n    height: 0;\n    width: 0;\n    left: 25%;\n    position: absolute;\n}\na[data-tooltip]:before {\n    background: #222;\n    background: hsla(0,0%,0%,.85);\n    color: #f6f6f6;\n    content: attr(data-tooltip);\n    display: none;\n    font-family: sans-serif;\n    font-size: 14px;\n    height: 32px;\n    left: 0;\n    line-height: 32px;\n    padding: 0 15px;\n    position: absolute;\n    text-shadow: 0 1px 1px hsla(0,0%,0%,1);\n    white-space: nowrap;\n    -webkit-border-radius: 5px;\n    -moz-border-radius: 5px;\n    -o-border-radius: 5px;\n    border-radius: 5px;\n}\na[data-tooltip]:hover:after {\n    display: block;\n    top: -9px;\n}\na[data-tooltip]:hover:before {\n    display: block;\n    top: -41px;\n}\na[data-tooltip]:active:after {\n    top: -10px;\n}\na[data-tooltip]:active:before {\n    top: -42px;\n}\n</code></pre><h2 id=\"21-创建暗灰色的按钮样式\"><a href=\"#21-创建暗灰色的按钮样式\" class=\"headerlink\" title=\"21.创建暗灰色的按钮样式\"></a>21.创建暗灰色的按钮样式</h2><ul>\n<li>下面这段代码创建了CSS3按钮类，并根据按钮颜色命名为.graybtn。当然你也可以根据自己的网站风格对颜色进行更改。</li>\n</ul>\n<pre><code>.graybtn {\n    -moz-box-shadow:inset 0px 1px 0px 0px #ffffff;\n    -webkit-box-shadow:inset 0px 1px 0px 0px #ffffff;\n    box-shadow:inset 0px 1px 0px 0px #ffffff;\n    background:-webkit-gradient( linear, left top, left bottom, color-stop(0.05, #ffffff), color-stop(1, #d1d1d1) );\n    background:-moz-linear-gradient( center top, #ffffff 5%, #d1d1d1 100% );\nfilter:progid:DXImageTransform.Microsoft.gradient(startColorstr=&#39;#ffffff&#39;, endColorstr=&#39;#d1d1d1&#39;);\n    background-color:#ffffff;\n    -moz-border-radius:6px;\n    -webkit-border-radius:6px;\n    border-radius:6px;\n    border:1px solid #dcdcdc;\n    display:inline-block;\n    color:#777777;\n    font-family:arial;\n    font-size:15px;\n    font-weight:bold;\n    padding:6px 24px;\n    text-decoration:none;\n    text-shadow:1px 1px 0px #ffffff;\n}\n.graybtn:hover {\n    background:-webkit-gradient( linear, left top, left bottom, color-stop(0.05, #d1d1d1), color-stop(1, #ffffff) );\n    background:-moz-linear-gradient( center top, #d1d1d1 5%, #ffffff 100% );\n    filter:progid:DXImageTransform.Microsoft.gradient(startColorstr=&#39;#d1d1d1&#39;, endColorstr=&#39;#ffffff&#39;);\n    background-color:#d1d1d1;\n}\n.graybtn:active {\n    position:relative;\n    top:1px;\n}\n</code></pre><h2 id=\"22-打印的页面上显示URL\"><a href=\"#22-打印的页面上显示URL\" class=\"headerlink\" title=\"22.打印的页面上显示URL\"></a>22.打印的页面上显示URL</h2><ul>\n<li>这条规则会使打印出来的页面在超链接文字后面加上URL，URL会被放在一组括号里面,前后各留一个空格。</li>\n</ul>\n<pre><code>@media print   {\n  a:after {\n    content: &quot; [&quot; attr(href) &quot;] &quot;;\n  }\n}\n</code></pre><h2 id=\"23-屏蔽Webkit移动浏览器中元素高亮效果\"><a href=\"#23-屏蔽Webkit移动浏览器中元素高亮效果\" class=\"headerlink\" title=\"23.屏蔽Webkit移动浏览器中元素高亮效果\"></a>23.屏蔽Webkit移动浏览器中元素高亮效果</h2><ul>\n<li>在访问移动网站时，你会发现，在选中的元素周围会出现一些灰色的框框，而下面这段代码即可屏蔽这种样式。</li>\n</ul>\n<pre><code>body {\n    -webkit-touch-callout: none;\n    -webkit-user-select: none;\n    -khtml-user-select: none;\n    -moz-user-select: none;\n    -ms-user-select: none;\n    user-select: none;\n}\n</code></pre><h2 id=\"24-利用CSS生成小圆点图案\"><a href=\"#24-利用CSS生成小圆点图案\" class=\"headerlink\" title=\"24.利用CSS生成小圆点图案\"></a>24.利用CSS生成小圆点图案</h2><ul>\n<li>通过下面的代码，可以让你的网站背景上产生一些小圆点装饰图案。默认情况下，它是使用在body元素上，但你也可以把它使用在网页里的其他容器上。</li>\n</ul>\n<pre><code>body {\n    background: radial-gradient(circle, white 10%, transparent 10%),\n    radial-gradient(circle, white 10%, black 10%) 50px 50px;\n    background-size: 100px 100px;\n}\n</code></pre><h2 id=\"25-CSS3棋盘格效果\"><a href=\"#25-CSS3棋盘格效果\" class=\"headerlink\" title=\"25.CSS3棋盘格效果\"></a>25.CSS3棋盘格效果</h2><ul>\n<li>和上面的小圆点设计一样，这个效果需要一些额外的语法才可以工作，它需要在支持CSS3的浏览器上运行，效果很艳丽。当然，你可以根据需要自定义颜色。</li>\n</ul>\n<pre><code>body {\n    background-color: white;\n    background-image: linear-gradient(45deg, black 25%, transparent 25%, transparent 75%, black 75%, black),\n    linear-gradient(45deg, black 25%, transparent 25%, transparent 75%, black 75%, black);\n    background-size: 100px 100px;\n    background-position: 0 0, 50px 50px;\n}\n</code></pre><h2 id=\"26-Github-Fork红丝带\"><a href=\"#26-Github-Fork红丝带\" class=\"headerlink\" title=\"26.Github Fork红丝带\"></a>26.Github Fork红丝带</h2><ul>\n<li>下面这段代码是利用CSS3的transform属性生成Fork me on Github红丝带效果。</li>\n</ul>\n<pre><code>.ribbon {\n    background-color: #a00;\n    overflow: hidden;\n    /* top left corner */\n    position: absolute;\n    left: -3em;\n    top: 2.5em;\n    /* 45 deg ccw rotation */\n    -moz-transform: rotate(-45deg);\n    -webkit-transform: rotate(-45deg);\n    /* shadow */\n    -moz-box-shadow: 0 0 1em #888;\n    -webkit-box-shadow: 0 0 1em #888;\n}\n.ribbon a {\n    border: 1px solid #faa;\n    color: #fff;\n    display: block;\n    font: bold 81.25% &#39;Helvetiva Neue&#39;, Helvetica, Arial, sans-serif;\n    margin: 0.05em 0 0.075em 0;\n    padding: 0.5em 3.5em;\n    text-align: center;\n    text-decoration: none;\n    /* shadow */\n    text-shadow: 0 0 0.5em #444;\n}\n</code></pre><h2 id=\"27-字体压缩\"><a href=\"#27-字体压缩\" class=\"headerlink\" title=\"27.字体压缩\"></a>27.字体压缩</h2><ul>\n<li>在样式表里使用如下代码能够帮你节省许多网页空间。</li>\n</ul>\n<pre><code>p {\n  font: italic small-caps bold 1.2em/1.0em Arial, Tahoma, Helvetica;\n}\n</code></pre><h2 id=\"28-纸页面卷曲效果\"><a href=\"#28-纸页面卷曲效果\" class=\"headerlink\" title=\"28.纸页面卷曲效果\"></a>28.纸页面卷曲效果</h2><ul>\n<li>这种效果可以被广泛的使用在多种容器中，查看 demo page页面来更好地掌握该函数的使用吧。</li>\n</ul>\n<pre><code>ul.box {\n    position: relative;\n    z-index: 1; /*prevent shadows falling behind containers with backgrounds*/\n    overflow: hidden;\n    list-style: none;\n    margin: 0;\n    padding: 0;\n}\nul.box li {\n    position: relative;\n    float: left;\n    width: 250px;\n    height: 150px;\n    padding: 0;\n    border: 1px solid #efefef;\n    margin: 0 30px 30px 0;\n    background: #fff;\n    -webkit-box-shadow: 0 1px 4px rgba(0, 0, 0, 0.27), 0 0 40px rgba(0, 0, 0, 0.06) inset;\n    -moz-box-shadow: 0 1px 4px rgba(0, 0, 0, 0.27), 0 0 40px rgba(0, 0, 0, 0.06) inset;\n    box-shadow: 0 1px 4px rgba(0, 0, 0, 0.27), 0 0 40px rgba(0, 0, 0, 0.06) inset;\n}\nul.box li:before,\nul.box li:after {\n    content: &#39;&#39;;\n    z-index: -1;\n    position: absolute;\n    left: 10px;\n    bottom: 10px;\n    width: 70%;\n    max-width: 300px; /*avoid rotation causing ugly appearance at large container widths*/\n    max-height: 100px;\n    height: 55%;\n    -webkit-box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);\n    -moz-box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);\n    box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);\n    -webkit-transform: skew(-15deg) rotate(-6deg);\n    -moz-transform: skew(-15deg) rotate(-6deg);\n    -ms-transform: skew(-15deg) rotate(-6deg);\n    -o-transform: skew(-15deg) rotate(-6deg);\n    transform: skew(-15deg) rotate(-6deg);\n}\nul.box li:after {\n    left: auto;\n    right: 10px;\n    -webkit-transform: skew(15deg) rotate(6deg);\n    -moz-transform: skew(15deg) rotate(6deg);\n    -ms-transform: skew(15deg) rotate(6deg);\n    -o-transform: skew(15deg) rotate(6deg);\n    transform: skew(15deg) rotate(6deg);\n}\n</code></pre><h2 id=\"29-发光的锚链接\"><a href=\"#29-发光的锚链接\" class=\"headerlink\" title=\"29.发光的锚链接\"></a>29.发光的锚链接</h2><ul>\n<li>下面这段代码可以创建自定义的锚链接，鼠标悬浮在上面会发光。</li>\n</ul>\n<pre><code>a {\n    color: #00e;\n}\na:visited {\n    color: #551a8b;\n}\na:hover {\n    color: #06e;\n}\na:focus {\n    outline: thin dotted;\n}\na:hover, a:active {\n    outline: 0;\n}\na, a:visited, a:active {\n    text-decoration: none;\n    color: #fff;\n    -webkit-transition: all .3s ease-in-out;\n}\na:hover, .glow {\n    color: #ff0;\n    text-shadow: 0 0 10px #ff0;\n}\n</code></pre><h2 id=\"30-创建CSS3-Banner\"><a href=\"#30-创建CSS3-Banner\" class=\"headerlink\" title=\"30.创建CSS3 Banner\"></a>30.创建CSS3 Banner</h2><ul>\n<li>在支持CSS3的浏览器中，下面的代码可以生成漂亮的纯CSS图案。这种效果常见于电子商务网站的产品图片、缩略图、视频预览等。</li>\n</ul>\n<pre><code>.featureBanner {\n    position: relative;\n    margin: 20px\n}\n.featureBanner:before {\n    content: &quot;Featured&quot;;\n    position: absolute;\n    top: 5px;\n    left: -8px;\n    padding-right: 10px;\n    color: #232323;\n    font-weight: bold;\n    height: 0px;\n    border: 15px solid #ffa200;\n    border-right-color: transparent;\n    line-height: 0px;\n    box-shadow: -0px 5px 5px -5px #000;\n    z-index: 1;\n}\n.featureBanner:after {\n    content: &quot;&quot;;\n    position: absolute;\n    top: 35px;\n    left: -8px;\n    border: 4px solid #89540c;\n    border-left-color: transparent;\n    border-bottom-color: transparent;\n}\n</code></pre>","updated":"2020-04-30T06:47:11.785Z","comments":true,"link":"","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://yoursite.com/categories/前端开发/"}],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"webpack指南","date":"2018-04-26T07:03:58.000Z","path":"2018/04/26/webpack/","text":"从 webpack v4.0.0 开始，可以不用引入一个配置文件。然而，webpack 仍然还是高度可配置的。在开始前你需要先理解四个核心概念： 入口(entry)输出(output)loader插件(plugins) 1.入口(entry) 入口起点(entry point)指示 webpack 应该使用哪个模块，来作为构建其内部依赖图的开始。进入入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的。每个依赖项随即被处理，最后输出到称之为 bundles 的文件中可以通过在 webpack 配置中配置 entry 属性，来指定一个入口起点（或多个入口起点）。默认值为 ./src。 接下来我们看一个 entry 配置的最简单例子：webpack.config.js module.exports = { entry: &#39;./path/to/my/entry/file.js&#39; }; 2.出口(output) output 属性告诉 webpack 在哪里输出它所创建的 bundles，以及如何命名这些文件，默认值为 ./dist。基本上，整个应用程序结构，都会被编译到你指定的输出路径的文件夹中。你可以通过在配置中指定一个 output 字段，来配置这些处理过程：webpack.config.js const path = require(&#39;path&#39;); module.exports = { entry: &#39;./path/to/my/entry/file.js&#39;, output: { path: path.resolve(__dirname, &#39;dist&#39;), filename: &#39;my-first-webpack.bundle.js&#39; } }; 3.loader loader 让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript）。loader 可以将所有类型的文件转换为 webpack 能够处理的有效模块，然后你就可以利用 webpack 的打包能力，对它们进行处理。本质上，webpack loader 将所有类型的文件，转换为应用程序的依赖图（和最终的 bundle）可以直接引用的模块。 注意，loader 能够 import 导入任何类型的模块（例如 .css 文件），这是 webpack 特有的功能，其他打包程序或任务执行器的可能并不支持。我们认为这种语言扩展是有很必要的，因为这可以使开发人员创建出更准确的依赖关系图。 在更高层面，在 webpack 的配置中 loader 有两个目标： 1.test 属性，用于标识出应该被对应的 loader 进行转换的某个或某些文件。2.use 属性，表示进行转换时，应该使用哪个 loader。 例如：webpack.config.js const path = require(&#39;path&#39;); const config = { output: { filename: &#39;my-first-webpack.bundle.js&#39; }, module: { rules: [ { test: /\\.txt$/, use: &#39;raw-loader&#39; } ] } }; module.exports = config; 以上配置中，对一个单独的 module 对象定义了 rules 属性，里面包含两个必须属性：test 和 use。这告诉 webpack 编译器(compiler) 如下信息： “嘿，webpack 编译器，当你碰到「在 require()/import 语句中被解析为 ‘.txt’ 的路径」时，在你对它打包之前，先使用 raw-loader 转换一下。” 重要的是要记得，在 webpack 配置中定义 loader 时，要定义在 module.rules 中，而不是 rules。然而，在定义错误时 webpack 会给出严重的警告。为了使你受益于此，如果没有按照正确方式去做，webpack 会“给出严重的警告” loader 还有更多我们尚未提到的具体配置属性。 4.插件(plugins) loader 被用于转换某些类型的模块，而插件则可以用于执行范围更广的任务。插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量。插件接口功能极其强大，可以用来处理各种各样的任务想要使用一个插件，你只需要 require() 它，然后把它添加到 plugins 数组中。多数插件可以通过选项(option)自定义。你也可以在一个配置文件中因为不同目的而多次使用同一个插件，这时需要通过使用 new 操作符来创建它的一个实例:webpack.config.js const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;); // 通过 npm 安装 const webpack = require(&#39;webpack&#39;); // 用于访问内置插件 const config = { module: { rules: [ { test: /\\.txt$/, use: &#39;raw-loader&#39; } ] }, plugins: [ new webpack.optimize.UglifyJsPlugin(), new HtmlWebpackPlugin({template: &#39;./src/index.html&#39;}) ] }; module.exports = config; webpack 提供许多开箱可用的插件！查阅我们的插件列表获取更多信息。 在 webpack 配置中使用插件是简单直接的，然而也有很多值得我们进一步探讨的用例。webpack有一个丰富的插件界面。webpack中的大部分功能都使用这个插件接口。这使得webpack变得灵活。 5.模式 通过选择 development 或 production 之中的一个，来设置 mode 参数，你可以启用相应模式下的 webpack 内置的优化. module.exports = { mode: &#39;production&#39; }; 入口起点(Entry Points) 正如我们在起步中提到的，在 webpack 配置中有多种方式定义 entry 属性。除了解释为什么它可能非常有用，我们还将向你展示如何去配置 entry 属性。 1.单个入口（简写）语法用法：entry: string|Array webpack.config.js const config = { entry: &#39;./path/to/my/entry/file.js&#39; }; module.exports = config; entry 属性的单个入口语法，是下面的简写： const config = { entry: { main: &#39;./path/to/my/entry/file.js&#39; } }; 当你向 entry 传入一个数组时会发生什么？向 entry 属性传入「文件路径(file path)数组」将创建“多个主入口(multi-main entry)”。在你想要多个依赖文件一起注入，并且将它们的依赖导向(graph)到一个“chunk”时，传入数组的方式就很有用。 当你正在寻找为「只有一个入口起点的应用程序或工具（即 library）」快速设置 webpack 配置的时候，这会是个很不错的选择。然而，使用此语法在扩展配置时有失灵活性。 对象语法:用法：entry: {[entryChunkName: string]: string|Array} webpack.config.js const config = { entry: { app: &#39;./src/app.js&#39;, vendors: &#39;./src/vendors.js&#39; } }; 对象语法会比较繁琐。然而，这是应用程序中定义入口的最可扩展的方式。可扩展的 webpack 配置”是指，可重用并且可以与其他配置组合使用。这是一种流行的技术，用于将关注点(concern)从环境(environment)、构建目标(build target)、运行时(runtime)中分离。然后使用专门的工具（如 webpack-merge）将它们合并。 2.常见场景,分离 应用程序(app) 和 第三方库(vendor) 入口:webpack.config.js const config = { entry: { app: &#39;./src/app.js&#39;, vendors: &#39;./src/vendors.js&#39; } }; 这是什么？从表面上看，这告诉我们 webpack 从 app.js 和 vendors.js 开始创建依赖图(dependency graph)。这些依赖图是彼此完全分离、互相独立的（每个 bundle 中都有一个 webpack 引导(bootstrap)）。这种方式比较常见于，只有一个入口起点（不包括 vendor）的单页应用程序(single page application)中。为什么？此设置允许你使用 CommonsChunkPlugin 从「应用程序 bundle」中提取 vendor 引用(vendor reference) 到 vendor bundle，并把引用 vendor 的部分替换为 webpack_require() 调用。如果应用程序 bundle 中没有 vendor 代码，那么你可以在 webpack 中实现被称为长效缓存的通用模式。 3.多页面应用程序 const config = { entry: { pageOne: &#39;./src/pageOne/index.js&#39;, pageTwo: &#39;./src/pageTwo/index.js&#39;, pageThree: &#39;./src/pageThree/index.js&#39; } }; 这是什么？我们告诉 webpack 需要 3 个独立分离的依赖图（如上面的示例）。为什么？在多页应用中，（译注：每当页面跳转时）服务器将为你获取一个新的 HTML文档。页面重新加载新文档，并且资源被重新下载。然而，这给了我们特殊的机会去做很多事： 使用 CommonsChunkPlugin 为每个页面间的应用程序共享代码创建 bundle。由于入口起点增多，多页应用能够复用入口起点之间的大量代码/模块，从而可以极大地从这些技术中受益。 输出(Output) 1.配置 output 选项可以控制 webpack 如何向硬盘写入编译文件。注意，即使可以存在多个入口起点，但只指定一个输出配置。 2.用法(Usage) 在 webpack 中配置 output 属性的最低要求是，将它的值设置为一个对象，包括以下两点： 1.filename 用于输出文件的文件名。2.目标输出目录 path 的绝对路径。 const config = { output: { filename: &#39;bundle.js&#39;, path: &#39;/home/proj/public/assets&#39; } }; module.exports = config; 此配置将一个单独的 bundle.js 文件输出到 /home/proj/public/assets 目录中。 3.多个入口起点 如果配置创建了多个单独的 “chunk”（例如，使用多个入口起点或使用像 CommonsChunkPlugin 这样的插件），则应该使用占位符(substitutions)来确保每个文件具有唯一的名称。 { entry: { app: &#39;./src/app.js&#39;, search: &#39;./src/search.js&#39; }, output: { filename: &#39;[name].js&#39;, path: __dirname + &#39;/dist&#39; } } // 写入到硬盘：./dist/app.js, ./dist/search.js 4.高级进阶 以下是使用 CDN 和资源 hash 的复杂示例：config.js output: { path: &quot;/home/proj/cdn/assets/[hash]&quot;, publicPath: &quot;http://cdn.example.com/assets/[hash]/&quot; } 在编译时不知道最终输出文件的 publicPath 的情况下，publicPath 可以留空，并且在入口起点文件运行时动态设置。如果你在编译时不知道 publicPath，你可以先忽略它，并且在入口起点设置 webpack_public_path。 __webpack_public_path__ = myRuntimePublicPath // 剩余的应用程序入口 模式 1.模式(Mode) 提供 mode 配置选项，告知 webpack 使用相应模式的内置优化。 用法:只在配置中提供 mode 选项： module.exports = { mode: &#39;production&#39; //生产环境 }; 或者从 CLI 参数中传递：webpack –mode=production 支持以下字符串值： 选项 描述 development 会将 process.env.NODE_ENV 的值设为 development。启用 NamedChunksPlugin 和 NamedModulesPlugin。 production 会将 process.env.NODE_ENV 的值设为 production。启用 FlagDependencyUsagePlugin, FlagIncludedChunksPlugin, ModuleConcatenationPlugin, NoEmitOnErrorsPlugin, OccurrenceOrderPlugin, SideEffectsFlagPlugin 和 UglifyJsPlugin. loader loader 用于对模块的源代码进行转换。loader 可以使你在 import 或”加载”模块时预处理文件。因此，loader 类似于其他构建工具中“任务(task)”，并提供了处理前端构建步骤的强大方法。loader 可以将文件从不同的语言（如 TypeScript）转换为 JavaScript，或将内联图像转换为 data URL。loader 甚至允许你直接在 JavaScript 模块中 import CSS文件！ 示例 例如，你可以使用 loader 告诉 webpack 加载 CSS 文件，或者将 TypeScript 转为 JavaScript。为此，首先安装相对应的 loade npm install --save-dev css-loader npm install --save-dev ts-loader 然后指示 webpack 对每个 .css 使用 css-loader，以及对所有 .ts 文件使用 ts-loader： module.exports = { module: { rules: [ { test: /\\.css$/, use: &#39;css-loader&#39; }, { test: /\\.ts$/, use: &#39;ts-loader&#39; } ] } }; 1.使用 loader 在你的应用程序中，有三种使用 loader 的方式： 1.1.配置（推荐）：在 webpack.config.js 文件中指定 loader。1.2.内联：在每个 import 语句中显式指定 loader。1.3.CLI：在 shell 命令中指定它们。 1.1.配置[Configuration]:module.rules 允许你在 webpack 配置中指定多个 loader。 这是展示 loader 的一种简明方式，并且有助于使代码变得简洁。同时让你对各个 loader 有个全局概览： module: { rules: [ { test: /\\.css$/, use: [ { loader: &#39;style-loader&#39; }, { loader: &#39;css-loader&#39;, options: { modules: true } } ] } ] } 1.2.内联:可以在 import 语句或任何等效于 “import” 的方式中指定 loader。使用 ! 将资源中的 loader 分开。分开的每个部分都相对于当前目录解析 import Styles from &#39;style-loader!css-loader?modules!./styles.css&#39;; 通过前置所有规则及使用 !，可以对应覆盖到配置中的任意 loader。 选项可以传递查询参数，例如 ?key=value&amp;foo=bar，或者一个 JSON 对象，例如 ?{“key”:”value”,”foo”:”bar”}。 尽可能使用module.rules，因为这样可以减少源码中的代码量，并且可以在出错时，更快地调试和定位 loader 中的问题。 1.3.CLI:你也可以通过 CLI 使用 loader： webpack --module-bind jade-loader --module-bind &#39;css=style-loader!css-loader&#39; 这会对 .jade 文件使用 jade-loader，对 .css 文件使用 style-loader 和 css-loader 2.loader 特性 2.1.loader 支持链式传递。能够对资源使用流水线(pipeline)。一组链式的 loader 将按照相反的顺序执行。loader 链中的第一个 loader 返回值给下一个 loader。在最后一个 loader，返回 webpack 所预期的 JavaScript。2.2.loader 可以是同步的，也可以是异步的。2.3.loader 运行在 Node.js 中，并且能够执行任何可能的操作。2.4.loader 接收查询参数。用于对 loader 传递配置。2.5.loader 也能够使用 options 对象进行配置。2.6.除了使用 package.json 常见的 main 属性，还可以将普通的 npm 模块导出为 loader，做法是在 package.json 里定义一个 loader 字段。2.7.插件(plugin)可以为 loader 带来更多特性。2.8.loader 能够产生额外的任意文件。 插件(Plugins) 插件是 wepback 的支柱功能。webpack 自身也是构建于，你在 webpack 配置中用到的相同的插件系统之上！ 插件目的在于解决 loader 无法实现的其他事。webpack 插件是一个具有 apply 属性的 JavaScript 对象。apply 属性会被 webpack compiler 调用，并且 compiler 对象可在整个编译生命周期访问:列如：ConsoleLogOnBuildWebpackPlugin.js const pluginName = &#39;ConsoleLogOnBuildWebpackPlugin&#39;; class ConsoleLogOnBuildWebpackPlugin { apply(compiler) { compiler.hooks.run.tap(pluginName, compilation =&gt; { console.log(&quot;webpack 构建过程开始！&quot;); }); } } compiler hook的tap方法的第一个参数，应该是驼峰式命名的插件名称。建议为此使用一个常量，以便它可以在所有 hook 中复用。 用法:由于插件可以携带参数/选项，你必须在 webpack 配置中，向 plugins 属性传入 new 实例。根据你的 webpack 用法，这里有多种方式使用插件。 配置:webpack.config.js const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;); //通过 npm 安装 const webpack = require(&#39;webpack&#39;); //访问内置的插件 const path = require(&#39;path&#39;); const config = { entry: &#39;./path/to/my/entry/file.js&#39;, output: { filename: &#39;my-first-webpack.bundle.js&#39;, path: path.resolve(__dirname, &#39;dist&#39;) }, module: { rules: [ { test: /\\.(js|jsx)$/, use: &#39;babel-loader&#39; } ] }, plugins: [ new webpack.optimize.UglifyJsPlugin(), new HtmlWebpackPlugin({template: &#39;./src/index.html&#39;}) ] }; module.exports = config; 配置(Configuration) 你可能已经注意到，很少有 webpack 配置看起来很完全相同。这是因为 webpack 的配置文件，是导出一个对象的 JavaScript 文件。此对象，由 webpack 根据对象定义的属性进行解析。 因为 webpack 配置是标准的 Node.js CommonJS 模块，你可以做到以下事情： 通过 require(…) 导入其他文件通过 require(…) 使用 npm 的工具函数使用 JavaScript 控制流表达式，例如 ?: 操作符对常用值使用常量或变量编写并执行函数来生成部分配置 1基本配置 var path = require(&#39;path&#39;); module.exports = { mode: &#39;development&#39;, entry: &#39;./foo.js&#39;, output: { path: path.resolve(__dirname, &#39;dist&#39;), filename: &#39;foo.bundle.js&#39; } }; 配置 webpack.config.js const path = require(&#39;path&#39;); module.exports = { mode: &quot;production&quot;, // &quot;production&quot; | &quot;development&quot; | &quot;none&quot; mode: &quot;production&quot;, // enable many optimizations for production builds mode: &quot;development&quot;, // enabled useful tools for development mode: &quot;none&quot;, // no defaults // Chosen mode tells webpack to use its built-in optimizations accordingly. entry: &quot;./app/entry&quot;, // string | object | array entry: [&quot;./app/entry1&quot;, &quot;./app/entry2&quot;], entry: { a: &quot;./app/entry-a&quot;, b: [&quot;./app/entry-b1&quot;, &quot;./app/entry-b2&quot;] }, // 这里应用程序开始执行 // webpack 开始打包 output: { // webpack 如何输出结果的相关选项 path: path.resolve(__dirname, &quot;dist&quot;), // string // 所有输出文件的目标路径 // 必须是绝对路径（使用 Node.js 的 path 模块） filename: &quot;bundle.js&quot;, // string filename: &quot;[name].js&quot;, // 用于多个入口点(entry point)（出口点？） filename: &quot;[chunkhash].js&quot;, // 用于长效缓存 // 「入口分块(entry chunk)」的文件名模板（出口分块？） publicPath: &quot;/assets/&quot;, // string publicPath: &quot;&quot;, publicPath: &quot;https://cdn.example.com/&quot;, // 输出解析文件的目录，url 相对于 HTML 页面 library: &quot;MyLibrary&quot;, // string, // 导出库(exported library)的名称 libraryTarget: &quot;umd&quot;, // 通用模块定义 libraryTarget: &quot;umd2&quot;, // 通用模块定义 libraryTarget: &quot;commonjs2&quot;, // exported with module.exports libraryTarget: &quot;commonjs-module&quot;, // 使用 module.exports 导出 libraryTarget: &quot;commonjs&quot;, // 作为 exports 的属性导出 libraryTarget: &quot;amd&quot;, // 使用 AMD 定义方法来定义 libraryTarget: &quot;this&quot;, // 在 this 上设置属性 libraryTarget: &quot;var&quot;, // 变量定义于根作用域下 libraryTarget: &quot;assign&quot;, // 盲分配(blind assignment) libraryTarget: &quot;window&quot;, // 在 window 对象上设置属性 libraryTarget: &quot;global&quot;, // property set to global object libraryTarget: &quot;jsonp&quot;, // jsonp wrapper // 导出库(exported library)的类型 /* 高级输出配置（点击显示） */ pathinfo: true, // boolean // 在生成代码时，引入相关的模块、导出、请求等有帮助的路径信息。 chunkFilename: &quot;[id].js&quot;, chunkFilename: &quot;[chunkhash].js&quot;, // 长效缓存(/guides/caching) // 「附加分块(additional chunk)」的文件名模板 jsonpFunction: &quot;myWebpackJsonp&quot;, // string // 用于加载分块的 JSONP 函数名 sourceMapFilename: &quot;[file].map&quot;, // string sourceMapFilename: &quot;sourcemaps/[file].map&quot;, // string // 「source map 位置」的文件名模板 devtoolModuleFilenameTemplate: &quot;webpack:///[resource-path]&quot;, // string // 「devtool 中模块」的文件名模板 devtoolFallbackModuleFilenameTemplate: &quot;webpack:///[resource-path]?[hash]&quot;, // string // 「devtool 中模块」的文件名模板（用于冲突） umdNamedDefine: true, // boolean // 在 UMD 库中使用命名的 AMD 模块 crossOriginLoading: &quot;use-credentials&quot;, // 枚举 crossOriginLoading: &quot;anonymous&quot;, crossOriginLoading: false, // 指定运行时如何发出跨域请求问题 /* 专家级输出配置（自行承担风险） */ }, module: { // 关于模块配置 rules: [ // 模块规则（配置 loader、解析器等选项） { test: /\\.jsx?$/, include: [ path.resolve(__dirname, &quot;app&quot;) ], exclude: [ path.resolve(__dirname, &quot;app/demo-files&quot;) ], // 这里是匹配条件，每个选项都接收一个正则表达式或字符串 // test 和 include 具有相同的作用，都是必须匹配选项 // exclude 是必不匹配选项（优先于 test 和 include） // 最佳实践： // - 只在 test 和 文件名匹配 中使用正则表达式 // - 在 include 和 exclude 中使用绝对路径数组 // - 尽量避免 exclude，更倾向于使用 include issuer: { test, include, exclude }, // issuer 条件（导入源） enforce: &quot;pre&quot;, enforce: &quot;post&quot;, // 标识应用这些规则，即使规则覆盖（高级选项） loader: &quot;babel-loader&quot;, // 应该应用的 loader，它相对上下文解析 // 为了更清晰，`-loader` 后缀在 webpack 2 中不再是可选的 // 查看 webpack 1 升级指南。 options: { presets: [&quot;es2015&quot;] }, // loader 的可选项 }, { test: /\\.html$/, test: &quot;\\.html$&quot; use: [ // 应用多个 loader 和选项 &quot;htmllint-loader&quot;, { loader: &quot;html-loader&quot;, options: { /* ... */ } } ] }, { oneOf: [ /* rules */ ] }, // 只使用这些嵌套规则之一 { rules: [ /* rules */ ] }, // 使用所有这些嵌套规则（合并可用条件） { resource: { and: [ /* 条件 */ ] } }, // 仅当所有条件都匹配时才匹配 { resource: { or: [ /* 条件 */ ] } }, { resource: [ /* 条件 */ ] }, // 任意条件匹配时匹配（默认为数组） { resource: { not: /* 条件 */ } } // 条件不匹配时匹配 ], /* 高级模块配置（点击展示） */ noParse: [ /special-library\\.js$/ ], // 不解析这里的模块 unknownContextRequest: &quot;.&quot;, unknownContextRecursive: true, unknownContextRegExp: /^\\.\\/.*$/, unknownContextCritical: true, exprContextRequest: &quot;.&quot;, exprContextRegExp: /^\\.\\/.*$/, exprContextRecursive: true, exprContextCritical: true, wrappedContextRegExp: /.*/, wrappedContextRecursive: true, wrappedContextCritical: false, // specifies default behavior for dynamic requests }, resolve: { // 解析模块请求的选项 // （不适用于对 loader 解析） modules: [ &quot;node_modules&quot;, path.resolve(__dirname, &quot;app&quot;) ], // 用于查找模块的目录 extensions: [&quot;.js&quot;, &quot;.json&quot;, &quot;.jsx&quot;, &quot;.css&quot;], // 使用的扩展名 alias: { // 模块别名列表 &quot;module&quot;: &quot;new-module&quot;, // 起别名：&quot;module&quot; -&gt; &quot;new-module&quot; 和 &quot;module/path/file&quot; -&gt; &quot;new-module/path/file&quot; &quot;only-module$&quot;: &quot;new-module&quot;, // 起别名 &quot;only-module&quot; -&gt; &quot;new-module&quot;，但不匹配 &quot;only-module/path/file&quot; -&gt; &quot;new-module/path/file&quot; &quot;module&quot;: path.resolve(__dirname, &quot;app/third/module.js&quot;), // 起别名 &quot;module&quot; -&gt; &quot;./app/third/module.js&quot; 和 &quot;module/file&quot; 会导致错误 // 模块别名相对于当前上下文导入 }, /* 可供选择的别名语法（点击展示） */ alias: [ { name: &quot;module&quot;, // 旧的请求 alias: &quot;new-module&quot;, // 新的请求 onlyModule: true // 如果为 true，只有 &quot;module&quot; 是别名 // 如果为 false，&quot;module/inner/path&quot; 也是别名 } ], /* 高级解析选项（点击展示） */ symlinks: true, // 遵循符号链接(symlinks)到新位置 descriptionFiles: [&quot;package.json&quot;], // 从 package 描述中读取的文件 mainFields: [&quot;main&quot;], // 从描述文件中读取的属性 // 当请求文件夹时 aliasFields: [&quot;browser&quot;], // 从描述文件中读取的属性 // 以对此 package 的请求起别名 enforceExtension: false, // 如果为 true，请求必不包括扩展名 // 如果为 false，请求可以包括扩展名 moduleExtensions: [&quot;-module&quot;], enforceModuleExtension: false, // 类似 extensions/enforceExtension，但是用模块名替换文件 unsafeCache: true, unsafeCache: {}, // 为解析的请求启用缓存 // 这是不安全，因为文件夹结构可能会改动 // 但是性能改善是很大的 cachePredicate: (path, request) =&gt; true, // predicate function which selects requests for caching plugins: [ // ... ] // 应用于解析器的附加插件 }, performance: { hints: &quot;warning&quot;, // 枚举 hints: &quot;error&quot;, // 性能提示中抛出错误 hints: false, // 关闭性能提示 maxAssetSize: 200000, // 整数类型（以字节为单位） maxEntrypointSize: 400000, // 整数类型（以字节为单位） assetFilter: function(assetFilename) { // 提供资源文件名的断言函数 return assetFilename.endsWith(&#39;.css&#39;) || assetFilename.endsWith(&#39;.js&#39;); } }, devtool: &quot;source-map&quot;, // enum devtool: &quot;inline-source-map&quot;, // 嵌入到源文件中 devtool: &quot;eval-source-map&quot;, // 将 SourceMap 嵌入到每个模块中 devtool: &quot;hidden-source-map&quot;, // SourceMap 不在源文件中引用 devtool: &quot;cheap-source-map&quot;, // 没有模块映射(module mappings)的 SourceMap 低级变体(cheap-variant) devtool: &quot;cheap-module-source-map&quot;, // 有模块映射(module mappings)的 SourceMap 低级变体 devtool: &quot;eval&quot;, // 没有模块映射，而是命名模块。以牺牲细节达到最快。 // 通过在浏览器调试工具(browser devtools)中添加元信息(meta info)增强调试 // 牺牲了构建速度的 `source-map&#39; 是最详细的。 context: __dirname, // string（绝对路径！） // webpack 的主目录 // entry 和 module.rules.loader 选项 // 相对于此目录解析 target: &quot;web&quot;, // 枚举 target: &quot;webworker&quot;, // WebWorker target: &quot;node&quot;, // node.js 通过 require target: &quot;async-node&quot;, // Node.js 通过 fs and vm target: &quot;node-webkit&quot;, // nw.js target: &quot;electron-main&quot;, // electron，主进程(main process) target: &quot;electron-renderer&quot;, // electron，渲染进程(renderer process) target: (compiler) =&gt; { /* ... */ }, // 自定义 // 包(bundle)应该运行的环境 // 更改 块加载行为(chunk loading behavior) 和 可用模块(available module) externals: [&quot;react&quot;, /^@angular\\//], externals: &quot;react&quot;, // string（精确匹配） externals: /^[a-z\\-]+($|\\/)/, // 正则 externals: { // 对象 angular: &quot;this angular&quot;, // this[&quot;angular&quot;] react: { // UMD commonjs: &quot;react&quot;, commonjs2: &quot;react&quot;, amd: &quot;react&quot;, root: &quot;React&quot; } }, externals: (request) =&gt; { /* ... */ return &quot;commonjs &quot; + request } // 不要遵循/打包这些模块，而是在运行时从环境中请求他们 stats: &quot;errors-only&quot;, stats: { //object assets: true, colors: true, errors: true, errorDetails: true, hash: true, // ... }, // 精确控制要显示的 bundle 信息 devServer: { proxy: { // proxy URLs to backend development server &#39;/api&#39;: &#39;http://localhost:3000&#39; }, contentBase: path.join(__dirname, &#39;public&#39;), // boolean | string | array, static file location compress: true, // enable gzip compression historyApiFallback: true, // true for index.html upon 404, object for multiple paths hot: true, // hot module replacement. Depends on HotModuleReplacementPlugin https: false, // true for self-signed, object for cert authority noInfo: true, // only errors &amp; warns on hot reload // ... }, plugins: [ // ... ], // 附加插件列表 /* 高级配置（点击展示） */ }","content":"<ul>\n<li>从 webpack v4.0.0 开始，可以不用引入一个配置文件。然而，webpack 仍然还是高度可配置的。在开始前你需要先理解四个核心概念：</li>\n</ul>\n<blockquote>\n<p>入口(entry)<br>输出(output)<br>loader<br>插件(plugins)</p>\n</blockquote>\n<ul>\n<li>1.入口(entry)</li>\n</ul>\n<blockquote>\n<p>入口起点(entry point)指示 webpack 应该使用哪个模块，来作为构建其内部依赖图的开始。进入入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的。每个依赖项随即被处理，最后输出到称之为 bundles 的文件中可以通过在 webpack 配置中配置 entry 属性，来指定一个入口起点（或多个入口起点）。默认值为 ./src。</p>\n</blockquote>\n<ul>\n<li>接下来我们看一个 entry 配置的最简单例子：webpack.config.js</li>\n</ul>\n<pre><code>module.exports = {\n  entry: &#39;./path/to/my/entry/file.js&#39;\n};\n</code></pre><ul>\n<li>2.出口(output)</li>\n</ul>\n<blockquote>\n<p>output 属性告诉 webpack 在哪里输出它所创建的 bundles，以及如何命名这些文件，默认值为 ./dist。基本上，整个应用程序结构，都会被编译到你指定的输出路径的文件夹中。你可以通过在配置中指定一个 output 字段，来配置这些处理过程：webpack.config.js</p>\n</blockquote>\n<pre><code>const path = require(&#39;path&#39;);\n\nmodule.exports = {\n  entry: &#39;./path/to/my/entry/file.js&#39;,\n  output: {\n    path: path.resolve(__dirname, &#39;dist&#39;),\n    filename: &#39;my-first-webpack.bundle.js&#39;\n  }\n};\n</code></pre><ul>\n<li>3.loader</li>\n</ul>\n<blockquote>\n<p>loader 让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript）。loader 可以将所有类型的文件转换为 webpack 能够处理的有效模块，然后你就可以利用 webpack 的打包能力，对它们进行处理。本质上，webpack loader 将所有类型的文件，转换为应用程序的依赖图（和最终的 bundle）可以直接引用的模块。</p>\n</blockquote>\n<p style=\"width: 100%;padding: 10px;background-color: #000;color:#fff;\">注意，loader 能够 import 导入任何类型的模块（例如 .css 文件），<br>这是 webpack 特有的功能，其他打包程序或任务执行器的可能并不支持。<br>我们认为这种语言扩展是有很必要的，<br>因为这可以使开发人员创建出更准确的依赖关系图。</p>\n\n<ul>\n<li>在更高层面，在 webpack 的配置中 loader 有两个目标：</li>\n</ul>\n<blockquote>\n<p>1.test 属性，用于标识出应该被对应的 loader 进行转换的某个或某些文件。<br>2.use 属性，表示进行转换时，应该使用哪个 loader。</p>\n</blockquote>\n<ul>\n<li>例如：webpack.config.js</li>\n</ul>\n<pre><code>const path = require(&#39;path&#39;);\n\nconst config = {\n  output: {\n    filename: &#39;my-first-webpack.bundle.js&#39;\n  },\n  module: {\n    rules: [\n      { test: /\\.txt$/, use: &#39;raw-loader&#39; }\n    ]\n  }\n};\n\nmodule.exports = config;\n</code></pre><ul>\n<li>以上配置中，对一个单独的 module 对象定义了 rules 属性，里面包含两个必须属性：test 和 use。这告诉 webpack 编译器(compiler) 如下信息：</li>\n</ul>\n<blockquote>\n<p>“嘿，webpack 编译器，当你碰到「在 require()/import 语句中被解析为 ‘.txt’ 的路径」时，在你对它打包之前，先使用 raw-loader 转换一下。”</p>\n<p>重要的是要记得，在 webpack 配置中定义 loader 时，<br>要定义在 module.rules 中，而不是 rules。然而，在定义错误时 webpack 会给出严重的警告。为了使你受益于此，如果没有按照正确方式去做，webpack 会“给出严重的警告”</p>\n</blockquote>\n<ul>\n<li><p>loader 还有更多我们尚未提到的具体配置属性。</p>\n</li>\n<li><p>4.插件(plugins)</p>\n</li>\n</ul>\n<blockquote>\n<p>loader 被用于转换某些类型的模块，而插件则可以用于执行范围更广的任务。插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量。插件接口功能极其强大，可以用来处理各种各样的任务想要使用一个插件，你只需要 require() 它，然后把它添加到 plugins 数组中。多数插件可以通过选项(option)自定义。你也可以在一个配置文件中因为不同目的而多次使用同一个插件，这时需要通过使用 new 操作符来创建它的一个实例:webpack.config.js</p>\n</blockquote>\n<pre><code>const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;); // 通过 npm 安装\nconst webpack = require(&#39;webpack&#39;); // 用于访问内置插件\n\nconst config = {\n  module: {\n    rules: [\n      { test: /\\.txt$/, use: &#39;raw-loader&#39; }\n    ]\n  },\n  plugins: [\n    new webpack.optimize.UglifyJsPlugin(),\n    new HtmlWebpackPlugin({template: &#39;./src/index.html&#39;})\n  ]\n};\n\nmodule.exports = config;\n</code></pre><ul>\n<li><p>webpack 提供许多开箱可用的插件！查阅我们的插件列表获取更多信息。</p>\n</li>\n<li><p>在 webpack 配置中使用插件是简单直接的，然而也有很多值得我们进一步探讨的用例。webpack有一个丰富的插件界面。webpack中的大部分功能都使用这个插件接口。这使得webpack变得灵活。</p>\n</li>\n</ul>\n<ul>\n<li>5.模式</li>\n</ul>\n<blockquote>\n<p>通过选择 development 或 production 之中的一个，来设置 mode 参数，你可以启用相应模式下的 webpack 内置的优化.</p>\n</blockquote>\n<pre><code>module.exports = {\n  mode: &#39;production&#39;\n};\n</code></pre><h3 id=\"入口起点-Entry-Points\"><a href=\"#入口起点-Entry-Points\" class=\"headerlink\" title=\"入口起点(Entry Points)\"></a>入口起点(Entry Points)</h3><ul>\n<li><p>正如我们在起步中提到的，在 webpack 配置中有多种方式定义 entry 属性。除了解释为什么它可能非常有用，我们还将向你展示如何去配置 entry 属性。</p>\n</li>\n<li><p>1.单个入口（简写）语法用法：entry: string|Array<string></p>\n</li>\n<li><p>webpack.config.js</p>\n</li>\n</ul>\n<pre><code>const config = {\n  entry: &#39;./path/to/my/entry/file.js&#39;\n};\n\nmodule.exports = config;\n</code></pre><ul>\n<li>entry 属性的单个入口语法，是下面的简写：</li>\n</ul>\n<pre><code>const config = {\n  entry: {\n    main: &#39;./path/to/my/entry/file.js&#39;\n  }\n};\n</code></pre><blockquote>\n<p>当你向 entry 传入一个数组时会发生什么？向 entry 属性传入「文件路径(file path)数组」将创建“多个主入口(multi-main entry)”。在你想要多个依赖文件一起注入，并且将它们的依赖导向(graph)到一个“chunk”时，传入数组的方式就很有用。</p>\n</blockquote>\n<ul>\n<li>当你正在寻找为「只有一个入口起点的应用程序或工具（即 library）」快速设置 webpack 配置的时候，这会是个很不错的选择。然而，使用此语法在扩展配置时有失灵活性。</li>\n</ul>\n<ul>\n<li><p>对象语法:用法：entry: {[entryChunkName: string]: string|Array<string>}</p>\n</li>\n<li><p>webpack.config.js</p>\n</li>\n</ul>\n<pre><code>const config = {\n  entry: {\n    app: &#39;./src/app.js&#39;,\n    vendors: &#39;./src/vendors.js&#39;\n  }\n};\n</code></pre><ul>\n<li>对象语法会比较繁琐。然而，这是应用程序中定义入口的最可扩展的方式。可扩展的 webpack 配置”是指，可重用并且可以与其他配置组合使用。这是一种流行的技术，用于将关注点(concern)从环境(environment)、构建目标(build target)、运行时(runtime)中分离。然后使用专门的工具（如 webpack-merge）将它们合并。</li>\n</ul>\n<p>2.常见场景,分离 应用程序(app) 和 第三方库(vendor) 入口:webpack.config.js</p>\n<pre><code>const config = {\n  entry: {\n    app: &#39;./src/app.js&#39;,\n    vendors: &#39;./src/vendors.js&#39;\n  }\n};\n</code></pre><ul>\n<li><p>这是什么？从表面上看，这告诉我们 webpack 从 app.js 和 vendors.js 开始创建依赖图(dependency graph)。这些依赖图是彼此完全分离、互相独立的（每个 bundle 中都有一个 webpack 引导(bootstrap)）。这种方式比较常见于，只有一个入口起点（不包括 vendor）的单页应用程序(single page application)中。为什么？此设置允许你使用 CommonsChunkPlugin 从「应用程序 bundle」中提取 vendor 引用(vendor reference) 到 vendor bundle，并把引用 vendor 的部分替换为 <strong>webpack_require</strong>() 调用。如果应用程序 bundle 中没有 vendor 代码，那么你可以在 webpack 中实现被称为长效缓存的通用模式。</p>\n</li>\n<li><p>3.多页面应用程序</p>\n</li>\n</ul>\n<pre><code>const config = {\n  entry: {\n    pageOne: &#39;./src/pageOne/index.js&#39;,\n    pageTwo: &#39;./src/pageTwo/index.js&#39;,\n    pageThree: &#39;./src/pageThree/index.js&#39;\n  }\n};\n</code></pre><ul>\n<li><p>这是什么？我们告诉 webpack 需要 3 个独立分离的依赖图（如上面的示例）。为什么？在多页应用中，（译注：每当页面跳转时）服务器将为你获取一个新的 HTML文档。页面重新加载新文档，并且资源被重新下载。然而，这给了我们特殊的机会去做很多事：</p>\n</li>\n<li><p>使用 CommonsChunkPlugin 为每个页面间的应用程序共享代码创建 bundle。由于入口起点增多，多页应用能够复用入口起点之间的大量代码/模块，从而可以极大地从这些技术中受益。</p>\n</li>\n</ul>\n<h3 id=\"输出-Output\"><a href=\"#输出-Output\" class=\"headerlink\" title=\"输出(Output)\"></a>输出(Output)</h3><ul>\n<li><p>1.配置 output 选项可以控制 webpack 如何向硬盘写入编译文件。注意，即使可以存在多个入口起点，但只指定一个输出配置。</p>\n</li>\n<li><p>2.用法(Usage)</p>\n</li>\n<li><p>在 webpack 中配置 output 属性的最低要求是，将它的值设置为一个对象，包括以下两点：</p>\n</li>\n</ul>\n<blockquote>\n<p>1.filename 用于输出文件的文件名。<br>2.目标输出目录 path 的绝对路径。</p>\n</blockquote>\n<pre><code>const config = {\n  output: {\n    filename: &#39;bundle.js&#39;,\n    path: &#39;/home/proj/public/assets&#39;\n  }\n};\n\nmodule.exports = config;\n</code></pre><ul>\n<li><p>此配置将一个单独的 bundle.js 文件输出到 /home/proj/public/assets 目录中。</p>\n</li>\n<li><p>3.多个入口起点</p>\n</li>\n<li><p>如果配置创建了多个单独的 “chunk”（例如，使用多个入口起点或使用像 CommonsChunkPlugin 这样的插件），则应该使用占位符(substitutions)来确保每个文件具有唯一的名称。</p>\n</li>\n</ul>\n<pre><code>{\n  entry: {\n    app: &#39;./src/app.js&#39;,\n    search: &#39;./src/search.js&#39;\n  },\n  output: {\n    filename: &#39;[name].js&#39;,\n    path: __dirname + &#39;/dist&#39;\n  }\n}\n\n// 写入到硬盘：./dist/app.js, ./dist/search.js\n</code></pre><ul>\n<li><p>4.高级进阶</p>\n</li>\n<li><p>以下是使用 CDN 和资源 hash 的复杂示例：config.js</p>\n</li>\n</ul>\n<pre><code>output: {\n  path: &quot;/home/proj/cdn/assets/[hash]&quot;,\n  publicPath: &quot;http://cdn.example.com/assets/[hash]/&quot;\n}\n</code></pre><ul>\n<li>在编译时不知道最终输出文件的 publicPath 的情况下，publicPath 可以留空，并且在入口起点文件运行时动态设置。如果你在编译时不知道 publicPath，你可以先忽略它，并且在入口起点设置 <strong>webpack_public_path</strong>。</li>\n</ul>\n<pre><code>__webpack_public_path__ = myRuntimePublicPath\n\n// 剩余的应用程序入口\n</code></pre><h3 id=\"模式\"><a href=\"#模式\" class=\"headerlink\" title=\"模式\"></a>模式</h3><ul>\n<li><p>1.模式(Mode)</p>\n</li>\n<li><p>提供 mode 配置选项，告知 webpack 使用相应模式的内置优化。</p>\n</li>\n<li>用法:只在配置中提供 mode 选项：</li>\n</ul>\n<pre><code>module.exports = {\n  mode: &#39;production&#39;  //生产环境\n};\n</code></pre><ul>\n<li><p>或者从 CLI 参数中传递：webpack –mode=production</p>\n</li>\n<li><p>支持以下字符串值：</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>描述 </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>development</td>\n<td>会将 process.env.NODE_ENV 的值设为 development。启用 NamedChunksPlugin 和 NamedModulesPlugin。 </td>\n</tr>\n<tr>\n<td>production</td>\n<td>会将 process.env.NODE_ENV 的值设为 production。启用 FlagDependencyUsagePlugin, FlagIncludedChunksPlugin, ModuleConcatenationPlugin, NoEmitOnErrorsPlugin, OccurrenceOrderPlugin, SideEffectsFlagPlugin 和 UglifyJsPlugin.</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"loader\"><a href=\"#loader\" class=\"headerlink\" title=\"loader\"></a>loader</h3><ul>\n<li><p>loader 用于对模块的源代码进行转换。loader 可以使你在 import 或”加载”模块时预处理文件。因此，loader 类似于其他构建工具中“任务(task)”，并提供了处理前端构建步骤的强大方法。loader 可以将文件从不同的语言（如 TypeScript）转换为 JavaScript，或将内联图像转换为 data URL。loader 甚至允许你直接在 JavaScript 模块中 import CSS文件！</p>\n</li>\n<li><p>示例 例如，你可以使用 loader 告诉 webpack 加载 CSS 文件，或者将 TypeScript 转为 JavaScript。为此，首先安装相对应的 loade</p>\n</li>\n</ul>\n<pre><code>npm install --save-dev css-loader\nnpm install --save-dev ts-loader\n</code></pre><ul>\n<li>然后指示 webpack 对每个 .css 使用 css-loader，以及对所有 .ts 文件使用 ts-loader：</li>\n</ul>\n<pre><code>module.exports = {\n  module: {\n    rules: [\n      { test: /\\.css$/, use: &#39;css-loader&#39; },\n      { test: /\\.ts$/, use: &#39;ts-loader&#39; }\n    ]\n  }\n};\n</code></pre><ul>\n<li><p>1.使用 loader</p>\n</li>\n<li><p>在你的应用程序中，有三种使用 loader 的方式：</p>\n</li>\n</ul>\n<blockquote>\n<p>1.1.配置（推荐）：在 webpack.config.js 文件中指定 loader。<br>1.2.内联：在每个 import 语句中显式指定 loader。<br>1.3.CLI：在 shell 命令中指定它们。</p>\n</blockquote>\n<ul>\n<li>1.1.配置[Configuration]:module.rules 允许你在 webpack 配置中指定多个 loader。 这是展示 loader 的一种简明方式，并且有助于使代码变得简洁。同时让你对各个 loader 有个全局概览：</li>\n</ul>\n<pre><code> module: {\n    rules: [\n      {\n        test: /\\.css$/,\n        use: [\n          { loader: &#39;style-loader&#39; },\n          {\n            loader: &#39;css-loader&#39;,\n            options: {\n              modules: true\n            }\n          }\n        ]\n      }\n    ]\n  }\n</code></pre><ul>\n<li>1.2.内联:可以在 import 语句或任何等效于 “import” 的方式中指定 loader。使用 ! 将资源中的 loader 分开。分开的每个部分都相对于当前目录解析</li>\n</ul>\n<pre><code>import Styles from &#39;style-loader!css-loader?modules!./styles.css&#39;;\n</code></pre><ul>\n<li><p>通过前置所有规则及使用 !，可以对应覆盖到配置中的任意 loader。</p>\n</li>\n<li><p>选项可以传递查询参数，例如 ?key=value&amp;foo=bar，或者一个 JSON 对象，例如 ?{“key”:”value”,”foo”:”bar”}。</p>\n</li>\n</ul>\n<p style=\"padding: 10px;background-color: #000;color: #fff\">尽可能使用module.rules，因为这样可以减少源码中的代码量，并且可以在出错时，更快地调试和定位 loader 中的问题。</p>\n\n<ul>\n<li>1.3.CLI:你也可以通过 CLI 使用 loader：</li>\n</ul>\n<pre><code>webpack --module-bind jade-loader --module-bind &#39;css=style-loader!css-loader&#39;\n</code></pre><ul>\n<li><p>这会对 .jade 文件使用 jade-loader，对 .css 文件使用 style-loader 和 css-loader</p>\n</li>\n<li><p>2.loader 特性</p>\n</li>\n</ul>\n<blockquote>\n<p>2.1.loader 支持链式传递。能够对资源使用流水线(pipeline)。一组链式的 loader 将按照相反的顺序执行。loader 链中的第一个 loader 返回值给下一个 loader。在最后一个 loader，返回 webpack 所预期的 JavaScript。<br>2.2.loader 可以是同步的，也可以是异步的。<br>2.3.loader 运行在 Node.js 中，并且能够执行任何可能的操作。<br>2.4.loader 接收查询参数。用于对 loader 传递配置。<br>2.5.loader 也能够使用 options 对象进行配置。<br>2.6.除了使用 package.json 常见的 main 属性，还可以将普通的 npm 模块导出为 loader，做法是在 package.json 里定义一个 loader 字段。<br>2.7.插件(plugin)可以为 loader 带来更多特性。<br>2.8.loader 能够产生额外的任意文件。</p>\n</blockquote>\n<h3 id=\"插件-Plugins\"><a href=\"#插件-Plugins\" class=\"headerlink\" title=\"插件(Plugins)\"></a>插件(Plugins)</h3><ul>\n<li><p>插件是 wepback 的支柱功能。webpack 自身也是构建于，你在 webpack 配置中用到的相同的插件系统之上！</p>\n</li>\n<li><p>插件目的在于解决 loader 无法实现的其他事。webpack 插件是一个具有 apply 属性的 JavaScript 对象。apply 属性会被 webpack compiler 调用，并且 compiler 对象可在整个编译生命周期访问:列如：ConsoleLogOnBuildWebpackPlugin.js</p>\n</li>\n</ul>\n<pre><code>const pluginName = &#39;ConsoleLogOnBuildWebpackPlugin&#39;;\n\nclass ConsoleLogOnBuildWebpackPlugin {\n    apply(compiler) {\n        compiler.hooks.run.tap(pluginName, compilation =&gt; {\n            console.log(&quot;webpack 构建过程开始！&quot;);\n        });\n    }\n}\n</code></pre><ul>\n<li><p>compiler hook的tap方法的第一个参数，应该是驼峰式命名的插件名称。建议为此使用一个常量，以便它可以在所有 hook 中复用。</p>\n</li>\n<li><p>用法:由于插件可以携带参数/选项，你必须在 webpack 配置中，向 plugins 属性传入 new 实例。根据你的 webpack 用法，这里有多种方式使用插件。</p>\n</li>\n<li><p>配置:webpack.config.js</p>\n</li>\n</ul>\n<pre><code>const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;); //通过 npm 安装\nconst webpack = require(&#39;webpack&#39;); //访问内置的插件\nconst path = require(&#39;path&#39;);\n\nconst config = {\n  entry: &#39;./path/to/my/entry/file.js&#39;,\n  output: {\n    filename: &#39;my-first-webpack.bundle.js&#39;,\n    path: path.resolve(__dirname, &#39;dist&#39;)\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.(js|jsx)$/,\n        use: &#39;babel-loader&#39;\n      }\n    ]\n  },\n  plugins: [\n    new webpack.optimize.UglifyJsPlugin(),\n    new HtmlWebpackPlugin({template: &#39;./src/index.html&#39;})\n  ]\n};\n\nmodule.exports = config;\n</code></pre><h3 id=\"配置-Configuration\"><a href=\"#配置-Configuration\" class=\"headerlink\" title=\"配置(Configuration)\"></a>配置(Configuration)</h3><ul>\n<li><p>你可能已经注意到，很少有 webpack 配置看起来很完全相同。这是因为 webpack 的配置文件，是导出一个对象的 JavaScript 文件。此对象，由 webpack 根据对象定义的属性进行解析。</p>\n</li>\n<li><p>因为 webpack 配置是标准的 Node.js CommonJS 模块，你可以做到以下事情：</p>\n</li>\n</ul>\n<blockquote>\n<p>通过 require(…) 导入其他文件<br>通过 require(…) 使用 npm 的工具函数<br>使用 JavaScript 控制流表达式，例如 ?: 操作符<br>对常用值使用常量或变量<br>编写并执行函数来生成部分配置</p>\n</blockquote>\n<ul>\n<li>1基本配置</li>\n</ul>\n<pre><code>var path = require(&#39;path&#39;);\n\nmodule.exports = {\n  mode: &#39;development&#39;,\n  entry: &#39;./foo.js&#39;,\n  output: {\n    path: path.resolve(__dirname, &#39;dist&#39;),\n    filename: &#39;foo.bundle.js&#39;\n  }\n};\n</code></pre><h2 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h2><ul>\n<li>webpack.config.js</li>\n</ul>\n<pre><code>const path = require(&#39;path&#39;);\n\nmodule.exports = {\n  mode: &quot;production&quot;, // &quot;production&quot; | &quot;development&quot; | &quot;none&quot;\n  mode: &quot;production&quot;, // enable many optimizations for production builds\n  mode: &quot;development&quot;, // enabled useful tools for development\n  mode: &quot;none&quot;, // no defaults\n  // Chosen mode tells webpack to use its built-in optimizations accordingly.\n\n  entry: &quot;./app/entry&quot;, // string | object | array\n  entry: [&quot;./app/entry1&quot;, &quot;./app/entry2&quot;],\n  entry: {\n    a: &quot;./app/entry-a&quot;,\n    b: [&quot;./app/entry-b1&quot;, &quot;./app/entry-b2&quot;]\n  },\n  // 这里应用程序开始执行\n  // webpack 开始打包\n\n  output: {\n    // webpack 如何输出结果的相关选项\n\n    path: path.resolve(__dirname, &quot;dist&quot;), // string\n    // 所有输出文件的目标路径\n    // 必须是绝对路径（使用 Node.js 的 path 模块）\n\n    filename: &quot;bundle.js&quot;, // string\n    filename: &quot;[name].js&quot;, // 用于多个入口点(entry point)（出口点？）\n    filename: &quot;[chunkhash].js&quot;, // 用于长效缓存\n    // 「入口分块(entry chunk)」的文件名模板（出口分块？）\n\n    publicPath: &quot;/assets/&quot;, // string\n    publicPath: &quot;&quot;,\n    publicPath: &quot;https://cdn.example.com/&quot;,\n    // 输出解析文件的目录，url 相对于 HTML 页面\n\n    library: &quot;MyLibrary&quot;, // string,\n    // 导出库(exported library)的名称\n\n    libraryTarget: &quot;umd&quot;, // 通用模块定义\n        libraryTarget: &quot;umd2&quot;, // 通用模块定义\n        libraryTarget: &quot;commonjs2&quot;, // exported with module.exports\n        libraryTarget: &quot;commonjs-module&quot;, // 使用 module.exports 导出\n        libraryTarget: &quot;commonjs&quot;, // 作为 exports 的属性导出\n        libraryTarget: &quot;amd&quot;, // 使用 AMD 定义方法来定义\n        libraryTarget: &quot;this&quot;, // 在 this 上设置属性\n        libraryTarget: &quot;var&quot;, // 变量定义于根作用域下\n        libraryTarget: &quot;assign&quot;, // 盲分配(blind assignment)\n        libraryTarget: &quot;window&quot;, // 在 window 对象上设置属性\n        libraryTarget: &quot;global&quot;, // property set to global object\n        libraryTarget: &quot;jsonp&quot;, // jsonp wrapper\n    // 导出库(exported library)的类型\n\n    /* 高级输出配置（点击显示） */\n\n    pathinfo: true, // boolean\n    // 在生成代码时，引入相关的模块、导出、请求等有帮助的路径信息。\n\n    chunkFilename: &quot;[id].js&quot;,\n    chunkFilename: &quot;[chunkhash].js&quot;, // 长效缓存(/guides/caching)\n    // 「附加分块(additional chunk)」的文件名模板\n\n    jsonpFunction: &quot;myWebpackJsonp&quot;, // string\n    // 用于加载分块的 JSONP 函数名\n\n    sourceMapFilename: &quot;[file].map&quot;, // string\n    sourceMapFilename: &quot;sourcemaps/[file].map&quot;, // string\n    // 「source map 位置」的文件名模板\n\n    devtoolModuleFilenameTemplate: &quot;webpack:///[resource-path]&quot;, // string\n    // 「devtool 中模块」的文件名模板\n\n    devtoolFallbackModuleFilenameTemplate: &quot;webpack:///[resource-path]?[hash]&quot;, // string\n    // 「devtool 中模块」的文件名模板（用于冲突）\n\n    umdNamedDefine: true, // boolean\n    // 在 UMD 库中使用命名的 AMD 模块\n\n    crossOriginLoading: &quot;use-credentials&quot;, // 枚举\n    crossOriginLoading: &quot;anonymous&quot;,\n    crossOriginLoading: false,\n    // 指定运行时如何发出跨域请求问题\n\n    /* 专家级输出配置（自行承担风险） */\n  },\n\n  module: {\n    // 关于模块配置\n\n    rules: [\n      // 模块规则（配置 loader、解析器等选项）\n\n      {\n        test: /\\.jsx?$/,\n        include: [\n          path.resolve(__dirname, &quot;app&quot;)\n        ],\n        exclude: [\n          path.resolve(__dirname, &quot;app/demo-files&quot;)\n        ],\n        // 这里是匹配条件，每个选项都接收一个正则表达式或字符串\n        // test 和 include 具有相同的作用，都是必须匹配选项\n        // exclude 是必不匹配选项（优先于 test 和 include）\n        // 最佳实践：\n        // - 只在 test 和 文件名匹配 中使用正则表达式\n        // - 在 include 和 exclude 中使用绝对路径数组\n        // - 尽量避免 exclude，更倾向于使用 include\n\n        issuer: { test, include, exclude },\n        // issuer 条件（导入源）\n\n        enforce: &quot;pre&quot;,\n        enforce: &quot;post&quot;,\n        // 标识应用这些规则，即使规则覆盖（高级选项）\n\n        loader: &quot;babel-loader&quot;,\n        // 应该应用的 loader，它相对上下文解析\n        // 为了更清晰，`-loader` 后缀在 webpack 2 中不再是可选的\n        // 查看 webpack 1 升级指南。\n\n        options: {\n          presets: [&quot;es2015&quot;]\n        },\n        // loader 的可选项\n      },\n\n      {\n        test: /\\.html$/,\n        test: &quot;\\.html$&quot;\n\n        use: [\n          // 应用多个 loader 和选项\n          &quot;htmllint-loader&quot;,\n          {\n            loader: &quot;html-loader&quot;,\n            options: {\n              /* ... */\n            }\n          }\n        ]\n      },\n\n      { oneOf: [ /* rules */ ] },\n      // 只使用这些嵌套规则之一\n\n      { rules: [ /* rules */ ] },\n      // 使用所有这些嵌套规则（合并可用条件）\n\n      { resource: { and: [ /* 条件 */ ] } },\n      // 仅当所有条件都匹配时才匹配\n\n      { resource: { or: [ /* 条件 */ ] } },\n      { resource: [ /* 条件 */ ] },\n      // 任意条件匹配时匹配（默认为数组）\n\n      { resource: { not: /* 条件 */ } }\n      // 条件不匹配时匹配\n    ],\n\n    /* 高级模块配置（点击展示） */\n\n    noParse: [\n      /special-library\\.js$/\n    ],\n    // 不解析这里的模块\n\n    unknownContextRequest: &quot;.&quot;,\n    unknownContextRecursive: true,\n    unknownContextRegExp: /^\\.\\/.*$/,\n    unknownContextCritical: true,\n    exprContextRequest: &quot;.&quot;,\n    exprContextRegExp: /^\\.\\/.*$/,\n    exprContextRecursive: true,\n    exprContextCritical: true,\n    wrappedContextRegExp: /.*/,\n    wrappedContextRecursive: true,\n    wrappedContextCritical: false,\n    // specifies default behavior for dynamic requests\n  },\n\n  resolve: {\n    // 解析模块请求的选项\n    // （不适用于对 loader 解析）\n\n    modules: [\n      &quot;node_modules&quot;,\n      path.resolve(__dirname, &quot;app&quot;)\n    ],\n    // 用于查找模块的目录\n\n    extensions: [&quot;.js&quot;, &quot;.json&quot;, &quot;.jsx&quot;, &quot;.css&quot;],\n    // 使用的扩展名\n\n    alias: {\n      // 模块别名列表\n\n      &quot;module&quot;: &quot;new-module&quot;,\n      // 起别名：&quot;module&quot; -&gt; &quot;new-module&quot; 和 &quot;module/path/file&quot; -&gt; &quot;new-module/path/file&quot;\n\n      &quot;only-module$&quot;: &quot;new-module&quot;,\n      // 起别名 &quot;only-module&quot; -&gt; &quot;new-module&quot;，但不匹配 &quot;only-module/path/file&quot; -&gt; &quot;new-module/path/file&quot;\n\n      &quot;module&quot;: path.resolve(__dirname, &quot;app/third/module.js&quot;),\n      // 起别名 &quot;module&quot; -&gt; &quot;./app/third/module.js&quot; 和 &quot;module/file&quot; 会导致错误\n      // 模块别名相对于当前上下文导入\n    },\n    /* 可供选择的别名语法（点击展示） */\n    alias: [\n      {\n        name: &quot;module&quot;,\n        // 旧的请求\n\n        alias: &quot;new-module&quot;,\n        // 新的请求\n\n        onlyModule: true\n        // 如果为 true，只有 &quot;module&quot; 是别名\n        // 如果为 false，&quot;module/inner/path&quot; 也是别名\n      }\n    ],\n\n    /* 高级解析选项（点击展示） */\n\n    symlinks: true,\n    // 遵循符号链接(symlinks)到新位置\n\n    descriptionFiles: [&quot;package.json&quot;],\n    // 从 package 描述中读取的文件\n\n    mainFields: [&quot;main&quot;],\n    // 从描述文件中读取的属性\n    // 当请求文件夹时\n\n    aliasFields: [&quot;browser&quot;],\n    // 从描述文件中读取的属性\n    // 以对此 package 的请求起别名\n\n    enforceExtension: false,\n    // 如果为 true，请求必不包括扩展名\n    // 如果为 false，请求可以包括扩展名\n\n    moduleExtensions: [&quot;-module&quot;],\n    enforceModuleExtension: false,\n    // 类似 extensions/enforceExtension，但是用模块名替换文件\n\n    unsafeCache: true,\n    unsafeCache: {},\n    // 为解析的请求启用缓存\n    // 这是不安全，因为文件夹结构可能会改动\n    // 但是性能改善是很大的\n\n    cachePredicate: (path, request) =&gt; true,\n    // predicate function which selects requests for caching\n\n    plugins: [\n      // ...\n    ]\n    // 应用于解析器的附加插件\n  },\n\n  performance: {\n    hints: &quot;warning&quot;, // 枚举\n    hints: &quot;error&quot;, // 性能提示中抛出错误\n    hints: false, // 关闭性能提示\n    maxAssetSize: 200000, // 整数类型（以字节为单位）\n    maxEntrypointSize: 400000, // 整数类型（以字节为单位）\n    assetFilter: function(assetFilename) {\n      // 提供资源文件名的断言函数\n      return assetFilename.endsWith(&#39;.css&#39;) || assetFilename.endsWith(&#39;.js&#39;);\n    }\n  },\n\n  devtool: &quot;source-map&quot;, // enum\n  devtool: &quot;inline-source-map&quot;, // 嵌入到源文件中\n  devtool: &quot;eval-source-map&quot;, // 将 SourceMap 嵌入到每个模块中\n  devtool: &quot;hidden-source-map&quot;, // SourceMap 不在源文件中引用\n  devtool: &quot;cheap-source-map&quot;, // 没有模块映射(module mappings)的 SourceMap 低级变体(cheap-variant)\n  devtool: &quot;cheap-module-source-map&quot;, // 有模块映射(module mappings)的 SourceMap 低级变体\n  devtool: &quot;eval&quot;, // 没有模块映射，而是命名模块。以牺牲细节达到最快。\n  // 通过在浏览器调试工具(browser devtools)中添加元信息(meta info)增强调试\n  // 牺牲了构建速度的 `source-map&#39; 是最详细的。\n\n  context: __dirname, // string（绝对路径！）\n  // webpack 的主目录\n  // entry 和 module.rules.loader 选项\n  // 相对于此目录解析\n\n  target: &quot;web&quot;, // 枚举\n  target: &quot;webworker&quot;, // WebWorker\n  target: &quot;node&quot;, // node.js 通过 require\n  target: &quot;async-node&quot;, // Node.js 通过 fs and vm\n  target: &quot;node-webkit&quot;, // nw.js\n  target: &quot;electron-main&quot;, // electron，主进程(main process)\n  target: &quot;electron-renderer&quot;, // electron，渲染进程(renderer process)\n  target: (compiler) =&gt; { /* ... */ }, // 自定义\n  // 包(bundle)应该运行的环境\n  // 更改 块加载行为(chunk loading behavior) 和 可用模块(available module)\n\n  externals: [&quot;react&quot;, /^@angular\\//],\n  externals: &quot;react&quot;, // string（精确匹配）\n  externals: /^[a-z\\-]+($|\\/)/, // 正则\n  externals: { // 对象\n    angular: &quot;this angular&quot;, // this[&quot;angular&quot;]\n    react: { // UMD\n      commonjs: &quot;react&quot;,\n      commonjs2: &quot;react&quot;,\n      amd: &quot;react&quot;,\n      root: &quot;React&quot;\n    }\n  },\n  externals: (request) =&gt; { /* ... */ return &quot;commonjs &quot; + request }\n  // 不要遵循/打包这些模块，而是在运行时从环境中请求他们\n\n  stats: &quot;errors-only&quot;,\n  stats: { //object\n    assets: true,\n    colors: true,\n    errors: true,\n    errorDetails: true,\n    hash: true,\n    // ...\n  },\n  // 精确控制要显示的 bundle 信息\n\n  devServer: {\n    proxy: { // proxy URLs to backend development server\n      &#39;/api&#39;: &#39;http://localhost:3000&#39;\n    },\n    contentBase: path.join(__dirname, &#39;public&#39;), // boolean | string | array, static file location\n    compress: true, // enable gzip compression\n    historyApiFallback: true, // true for index.html upon 404, object for multiple paths\n    hot: true, // hot module replacement. Depends on HotModuleReplacementPlugin\n    https: false, // true for self-signed, object for cert authority\n    noInfo: true, // only errors &amp; warns on hot reload\n    // ...\n  },\n\n  plugins: [\n    // ...\n  ],\n  // 附加插件列表\n\n\n  /* 高级配置（点击展示） */\n}\n</code></pre>","updated":"2018-04-27T10:56:52.000Z","comments":true,"link":"","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://yoursite.com/categories/前端开发/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"xshell 连接阿里云服务器centos7.3系统指南与安装mongodb数据库","date":"2018-04-25T02:03:58.000Z","path":"2018/04/25/centos7_3/","text":"服务器系统为centos 使用如下命令安装各种包1.sudo yum install vim openssl build-essential libssl-dev wget curl git安装vim 和openssl 和build-essential和 libssl-dev和wget和curl和git 2.输入：nvm查看它信息， 2.1可以通过curl或者wget进行安装nvm: curl方式: curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.1/install.sh | bash wget方式: wget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.33.1/install.sh | bash 2.1.sudo yum install git安装git 2.2.连接服务器成功后输入：yum install -y lrzsz安装上上传和下载命令，rz为上传sz为下载 3.1.安装东西使用yum install -y 包名 即可 3.2 nvm ls-remote列出全部可以安装的版本号 4.nvm use 版本号 切换指定版本，切换效果是全局的 5.nvm current 查看当前使用的版本 6.nvm ls 查看该系统已经安装的版本，这个命令也能看到当前使用的是哪个版本 7.nvm install v9.11.1 安装指定版本 8.nvm use v9.11.1 使用指定版本 9.nvm alias default v9.11.1 指定默认版本 10.node -v 查看node版本号;输出v9.11.1说明安装成功 npm --registry=https://registry.npm.taobao.org install -g npm 将npm 指定到淘宝镜像来加快包下载速度 echo fs.inotify.max_user_watches = 524288 | sudo tee -a /etc/sysctl.conf &amp;&amp; sudo sysctl -p npm --registry=https://registry.npm.taobao.org install -g cnpm 将npm 指定到淘宝镜像cnpm来加快包下载速度以后可以使用cnpm install 来下载波包； 然后使用cnpm install webpack pm2 gulp -g 来安装这些包； sudo yum install nginx 来安装nginx 然后nginx -v 查看安装版本号 输入 cd /etc/nginx/conf.d 回车，然后vim nginx_8081.conf进行文件编辑内容如下： upstream suchengyong { server 127.0.0.1:8081; } server { listen 80; server_name 112.74.54.23; location / { proxy_redirect off; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://suchengyong; } } 然后按Esc键在按：wq回车保存成功然后输入nginx -t 测试是否成功，返回success表示成功： Centos系统 nginx启动：service nginx start或者重启：service nginx restart或者/etc/init.d/nginx stop关闭nginx或者/etc/init.d/nginx start启动nginx mongodb数据库安装一、打开官网下载对应版本 二、解压安装包，复制到对应目录中#下载安装包 wget -c https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-rhel70-3.6.0.tgz #下载完后进行解压包 tar -xzvf mongodb-linux-x86_64-rhel70-3.6.0.tgz #创建mogodb目录 mkdir /usr/local/mongodb #复制安装包到mongodb目录中 mv mongodb-linux-x86_64-rhel70-3.6.0 /usr/local/mongodb cd /usr/local/mongodb 三、守护进程启动mongodb 启动方式和参数：./mongod –dbpath=/usr/local/mongodb/data/db –logpath=/usr/local/mongodb/data/log/logs.log –logappend –fork #/usr/local/mongodb/创建数据库目录和日志目录 mkdir data #进入data目录 cd data #创建两个文件夹 mkdir db mkdir log cd log #建立日志文件 touch logs.log #进入/usr/local/mongodb/bin/目录中启动mongodb [root@localhost bin]# ./mongod --dbpath=/usr/local/mongodb/data/db --logpath=/usr/local/mongodb/data/log/logs.log --logappend --fork #运行结果 about to fork child process, waiting until server is ready for connections. forked process: 1874 child process started successfully, parent exiting 四、使用客户端进行mongodb数据库的操作 启动方式（/usr/local/mongodb/bin/目录）：./mongo [root@localhost bin]# ./mongo MongoDB shell version v3.6.0 connecting to: mongodb://127.0.0.1:27017 MongoDB server version: 3.6.0 Server has startup warnings: 2017-12-08T16:00:38.798+0800 I CONTROL [initandlisten] 2017-12-08T16:00:38.798+0800 I CONTROL [initandlisten] ** WARNING: Access control is not enabled for the database. 2017-12-08T16:00:38.798+0800 I CONTROL [initandlisten] ** Read and write access to data and configuration is unrestricted. 2017-12-08T16:00:38.798+0800 I CONTROL [initandlisten] ** WARNING: You are running this process as the root user, which is not recommended. 2017-12-08T16:00:38.798+0800 I CONTROL [initandlisten] 2017-12-08T16:00:38.798+0800 I CONTROL [initandlisten] ** WARNING: This server is bound to localhost. 2017-12-08T16:00:38.798+0800 I CONTROL [initandlisten] ** Remote systems will be unable to connect to this server. 2017-12-08T16:00:38.798+0800 I CONTROL [initandlisten] ** Start the server with --bind_ip &lt;address&gt; to specify which IP 2017-12-08T16:00:38.798+0800 I CONTROL [initandlisten] ** addresses it should serve responses from, or with --bind_ip_all to 2017-12-08T16:00:38.798+0800 I CONTROL [initandlisten] ** bind to all interfaces. If this behavior is desired, start the 2017-12-08T16:00:38.798+0800 I CONTROL [initandlisten] ** server with --bind_ip 127.0.0.1 to disable this warning. 2017-12-08T16:00:38.798+0800 I CONTROL [initandlisten] 2017-12-08T16:00:38.798+0800 I CONTROL [initandlisten] 2017-12-08T16:00:38.798+0800 I CONTROL [initandlisten] ** WARNING: /sys/kernel/mm/transparent_hugepage/enabled is &#39;always&#39;. 2017-12-08T16:00:38.798+0800 I CONTROL [initandlisten] ** We suggest setting it to &#39;never&#39; 2017-12-08T16:00:38.798+0800 I CONTROL [initandlisten] 2017-12-08T16:00:38.798+0800 I CONTROL [initandlisten] ** WARNING: /sys/kernel/mm/transparent_hugepage/defrag is &#39;always&#39;. 2017-12-08T16:00:38.798+0800 I CONTROL [initandlisten] ** We suggest setting it to &#39;never&#39; 2017-12-08T16:00:38.798+0800 I CONTROL [initandlisten] &gt; #查看数据库 &gt; show databases; admin 0.000GB config 0.000GB local 0.000GB #选择数据库 &gt; use admin switched to db admin #查看数据表 &gt; show tables; system.users system.version 五、mongodb3.6开机启动脚本设置 mongodb3.6开机启动shell脚本，当每次系统重启后mongodb进程并不会随着系统去启动，必须手动去启动它，让费时间，所以需要借助shell脚本让mongodb自动启动。 六、mongodb开机启动脚本 1.创建脚本文件：vim /etc/init.d/mongodb #!/bin/bash # chkconfig: - 85 15 #author:zuoping name=mongod path_bin=/usr/local/mongodb/bin/ path=/usr/local/mongodb/ case &quot;$1&quot; in start) ${path_bin}${name} --dbpath=${path}data/db --logpath=${path}data/log/logs.log --logappend --fork if [ $? -eq 0 ];then echo &quot;${name}启动成功...&quot; else echo &quot;${name}启动失败...&quot; fi ;; stop) if [ $(ps -ef|grep &quot;mongod&quot; |grep &quot;fork&quot;|awk {&#39;print $2&#39;}) -gt 0 ];then kill `ps -ef|grep &quot;mongod&quot; |grep &quot;fork&quot;|awk {&#39;print $2&#39;}` if [ $? -eq 0 ];then echo &quot;${name}停止成功&quot; else echo &quot;${name}停止失败&quot; fi else echo &quot;${name}进程已经停止&quot; fi ;; restart) if [ $(ps -ef|grep &quot;mongod&quot; |grep &quot;fork&quot;|awk {&#39;print $2&#39;}) -gt 0 ];then kill `ps -ef|grep &quot;mongod&quot; |grep &quot;fork&quot;|awk {&#39;print $2&#39;}` if [ $? -eq 0 ];then echo &quot;${name}停止成功&quot; else echo &quot;${name}停止失败&quot; fi else echo &quot;${name}进程已经停止&quot; fi echo &quot;${name}启动中...&quot; sleep 3s ${path_bin}${name} --dbpath=${path}data/db --logpath=${path}data/log/logs.log --logappend --fork if [ $? -eq 0 ];then echo &quot;${name}重启成功&quot; else echo &quot;${name}重启失败&quot; fi ;; *) echo &quot;${name}start|stop|restart&quot; ;; esac 3.加入系统服务和开机自启 cd /etc/init.d/ #设置执行权限 chmod a+x mongodb #加入系统服务 chkconfig --add mongodb #开机服务自启 chkconfig mongodb on #重启系统生效 shutdown -r 4.mongodb开启、停止、重启操作 #开启 service mongodb start #停止 service mongodb stop #重启 service mongodb restart","content":"<h3 id=\"服务器系统为centos-使用如下命令安装各种包\"><a href=\"#服务器系统为centos-使用如下命令安装各种包\" class=\"headerlink\" title=\"服务器系统为centos 使用如下命令安装各种包\"></a>服务器系统为centos 使用如下命令安装各种包</h3><pre><code>1.sudo yum install vim openssl build-essential libssl-dev wget curl git安装vim 和openssl  和build-essential和 libssl-dev和wget和curl和git\n</code></pre><ul>\n<li>2.输入：nvm查看它信息，</li>\n<li>2.1可以通过curl或者wget进行安装nvm:</li>\n<li>curl方式:</li>\n</ul>\n<pre><code>    curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.1/install.sh | bash\n</code></pre><p>wget方式:</p>\n<pre><code>    wget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.33.1/install.sh | bash\n</code></pre><pre><code>2.1.sudo yum install git安装git\n</code></pre><ul>\n<li><p>2.2.连接服务器成功后输入：yum install -y lrzsz安装上上传和下载命令，rz为上传sz为下载</p>\n</li>\n<li><p>3.1.安装东西使用yum install -y 包名   即可</p>\n</li>\n<li><p>3.2 nvm ls-remote列出全部可以安装的版本号</p>\n</li>\n<li><p>4.nvm use 版本号 切换指定版本，切换效果是全局的</p>\n</li>\n<li><p>5.nvm current 查看当前使用的版本</p>\n</li>\n<li><p>6.nvm ls 查看该系统已经安装的版本，这个命令也能看到当前使用的是哪个版本</p>\n</li>\n<li><p>7.nvm install v9.11.1 安装指定版本</p>\n</li>\n<li><p>8.nvm use v9.11.1 使用指定版本</p>\n</li>\n<li><p>9.nvm alias default v9.11.1 指定默认版本</p>\n</li>\n<li><p>10.node -v 查看node版本号;输出v9.11.1说明安装成功</p>\n</li>\n</ul>\n<pre><code>npm --registry=https://registry.npm.taobao.org install -g npm 将npm 指定到淘宝镜像来加快包下载速度\n</code></pre><pre><code>  echo fs.inotify.max_user_watches = 524288 | sudo tee -a /etc/sysctl.conf &amp;&amp; sudo sysctl -p\n</code></pre><pre><code>npm --registry=https://registry.npm.taobao.org install -g cnpm 将npm 指定到淘宝镜像cnpm来加快包下载速度以后可以使用cnpm install 来下载波包；\n</code></pre><ul>\n<li><p>然后使用cnpm install webpack pm2 gulp -g 来安装这些包；</p>\n</li>\n<li><p>sudo yum install nginx 来安装nginx 然后nginx -v 查看安装版本号</p>\n</li>\n<li><p>输入 cd /etc/nginx/conf.d 回车，然后vim nginx_8081.conf进行文件编辑内容如下：</p>\n</li>\n</ul>\n<pre><code>upstream suchengyong {\n    server 127.0.0.1:8081;\n}\nserver {\n    listen 80;\n    server_name  112.74.54.23;\n\n    location / {\n        proxy_redirect off;\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; \n        proxy_pass http://suchengyong;\n    }\n\n}\n</code></pre><ul>\n<li><p>然后按Esc键在按：wq回车保存成功然后输入nginx -t 测试是否成功，返回success表示成功：</p>\n</li>\n<li><p>Centos系统 nginx启动：service nginx  start或者重启：service nginx  restart或者/etc/init.d/nginx stop关闭nginx或者/etc/init.d/nginx start启动nginx</p>\n</li>\n</ul>\n<h2 id=\"mongodb数据库安装\"><a href=\"#mongodb数据库安装\" class=\"headerlink\" title=\"mongodb数据库安装\"></a>mongodb数据库安装</h2><h3 id=\"一、打开官网下载对应版本\"><a href=\"#一、打开官网下载对应版本\" class=\"headerlink\" title=\"一、打开官网下载对应版本\"></a>一、打开官网下载对应版本</h3><p><img src=\"http://www.zixuephp.net/uploads/image/20171208/1512724483131413.png\" alt=\"\"></p>\n<h3 id=\"二、解压安装包，复制到对应目录中\"><a href=\"#二、解压安装包，复制到对应目录中\" class=\"headerlink\" title=\"二、解压安装包，复制到对应目录中\"></a>二、解压安装包，复制到对应目录中</h3><pre><code>#下载安装包\nwget -c https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-rhel70-3.6.0.tgz\n#下载完后进行解压包\ntar -xzvf mongodb-linux-x86_64-rhel70-3.6.0.tgz\n#创建mogodb目录\nmkdir /usr/local/mongodb\n#复制安装包到mongodb目录中\nmv mongodb-linux-x86_64-rhel70-3.6.0 /usr/local/mongodb\ncd /usr/local/mongodb\n</code></pre><h3 id=\"三、守护进程启动mongodb\"><a href=\"#三、守护进程启动mongodb\" class=\"headerlink\" title=\"三、守护进程启动mongodb\"></a>三、守护进程启动mongodb</h3><ul>\n<li>启动方式和参数：./mongod –dbpath=/usr/local/mongodb/data/db –logpath=/usr/local/mongodb/data/log/logs.log –logappend –fork</li>\n</ul>\n<pre><code>#/usr/local/mongodb/创建数据库目录和日志目录\nmkdir data\n#进入data目录\ncd data\n#创建两个文件夹\nmkdir db\nmkdir log\ncd log\n#建立日志文件\ntouch logs.log\n\n#进入/usr/local/mongodb/bin/目录中启动mongodb\n\n[root@localhost bin]# ./mongod --dbpath=/usr/local/mongodb/data/db --logpath=/usr/local/mongodb/data/log/logs.log --logappend --fork\n#运行结果\nabout to fork child process, waiting until server is ready for connections.\nforked process: 1874\nchild process started successfully, parent exiting\n</code></pre><h3 id=\"四、使用客户端进行mongodb数据库的操作\"><a href=\"#四、使用客户端进行mongodb数据库的操作\" class=\"headerlink\" title=\"四、使用客户端进行mongodb数据库的操作\"></a>四、使用客户端进行mongodb数据库的操作</h3><ul>\n<li>启动方式（/usr/local/mongodb/bin/目录）：./mongo</li>\n</ul>\n<pre><code>[root@localhost bin]# ./mongo\nMongoDB shell version v3.6.0\nconnecting to: mongodb://127.0.0.1:27017\nMongoDB server version: 3.6.0\nServer has startup warnings: \n2017-12-08T16:00:38.798+0800 I CONTROL  [initandlisten] \n2017-12-08T16:00:38.798+0800 I CONTROL  [initandlisten] ** WARNING: Access control is not enabled for the database.\n2017-12-08T16:00:38.798+0800 I CONTROL  [initandlisten] **          Read and write access to data and configuration is unrestricted.\n2017-12-08T16:00:38.798+0800 I CONTROL  [initandlisten] ** WARNING: You are running this process as the root user, which is not recommended.\n2017-12-08T16:00:38.798+0800 I CONTROL  [initandlisten] \n2017-12-08T16:00:38.798+0800 I CONTROL  [initandlisten] ** WARNING: This server is bound to localhost.\n2017-12-08T16:00:38.798+0800 I CONTROL  [initandlisten] **          Remote systems will be unable to connect to this server. \n2017-12-08T16:00:38.798+0800 I CONTROL  [initandlisten] **          Start the server with --bind_ip &lt;address&gt; to specify which IP \n2017-12-08T16:00:38.798+0800 I CONTROL  [initandlisten] **          addresses it should serve responses from, or with --bind_ip_all to\n2017-12-08T16:00:38.798+0800 I CONTROL  [initandlisten] **          bind to all interfaces. If this behavior is desired, start the\n2017-12-08T16:00:38.798+0800 I CONTROL  [initandlisten] **          server with --bind_ip 127.0.0.1 to disable this warning.\n2017-12-08T16:00:38.798+0800 I CONTROL  [initandlisten] \n2017-12-08T16:00:38.798+0800 I CONTROL  [initandlisten] \n2017-12-08T16:00:38.798+0800 I CONTROL  [initandlisten] ** WARNING: /sys/kernel/mm/transparent_hugepage/enabled is &#39;always&#39;.\n2017-12-08T16:00:38.798+0800 I CONTROL  [initandlisten] **        We suggest setting it to &#39;never&#39;\n2017-12-08T16:00:38.798+0800 I CONTROL  [initandlisten] \n2017-12-08T16:00:38.798+0800 I CONTROL  [initandlisten] ** WARNING: /sys/kernel/mm/transparent_hugepage/defrag is &#39;always&#39;.\n2017-12-08T16:00:38.798+0800 I CONTROL  [initandlisten] **        We suggest setting it to &#39;never&#39;\n2017-12-08T16:00:38.798+0800 I CONTROL  [initandlisten] \n&gt;\n#查看数据库\n&gt; show databases;\nadmin   0.000GB\nconfig  0.000GB\nlocal   0.000GB\n#选择数据库\n&gt; use admin\nswitched to db admin\n#查看数据表\n&gt; show tables;\nsystem.users\nsystem.version\n</code></pre><h3 id=\"五、mongodb3-6开机启动脚本设置\"><a href=\"#五、mongodb3-6开机启动脚本设置\" class=\"headerlink\" title=\"五、mongodb3.6开机启动脚本设置\"></a>五、mongodb3.6开机启动脚本设置</h3><ul>\n<li>mongodb3.6开机启动shell脚本，当每次系统重启后mongodb进程并不会随着系统去启动，必须手动去启动它，让费时间，所以需要借助shell脚本让mongodb自动启动。</li>\n</ul>\n<h3 id=\"六、mongodb开机启动脚本\"><a href=\"#六、mongodb开机启动脚本\" class=\"headerlink\" title=\"六、mongodb开机启动脚本\"></a>六、mongodb开机启动脚本</h3><ul>\n<li>1.创建脚本文件：vim /etc/init.d/mongodb</li>\n</ul>\n<pre><code>#!/bin/bash\n# chkconfig: - 85 15\n#author:zuoping\nname=mongod\npath_bin=/usr/local/mongodb/bin/\npath=/usr/local/mongodb/\ncase &quot;$1&quot; in\n  start)\n    ${path_bin}${name} --dbpath=${path}data/db --logpath=${path}data/log/logs.log --logappend --fork\n    if [ $? -eq 0 ];then\n      echo &quot;${name}启动成功...&quot;\n    else\n      echo &quot;${name}启动失败...&quot;\n    fi\n  ;;\n  stop)\n    if [ $(ps -ef|grep &quot;mongod&quot; |grep &quot;fork&quot;|awk {&#39;print $2&#39;}) -gt 0 ];then\n      kill `ps -ef|grep &quot;mongod&quot; |grep &quot;fork&quot;|awk {&#39;print $2&#39;}`\n      if [ $? -eq 0 ];then\n        echo &quot;${name}停止成功&quot;\n      else\n        echo &quot;${name}停止失败&quot;\n      fi\n    else\n      echo &quot;${name}进程已经停止&quot;\n    fi\n  ;;\n  restart)\n    if [ $(ps -ef|grep &quot;mongod&quot; |grep &quot;fork&quot;|awk {&#39;print $2&#39;}) -gt 0 ];then\n      kill `ps -ef|grep &quot;mongod&quot; |grep &quot;fork&quot;|awk {&#39;print $2&#39;}`\n      if [ $? -eq 0 ];then\n        echo &quot;${name}停止成功&quot;\n      else\n        echo &quot;${name}停止失败&quot;\n      fi\n    else\n      echo &quot;${name}进程已经停止&quot;\n    fi\n    echo &quot;${name}启动中...&quot;\n    sleep 3s\n    ${path_bin}${name} --dbpath=${path}data/db --logpath=${path}data/log/logs.log --logappend --fork\n    if [ $? -eq 0 ];then\n      echo &quot;${name}重启成功&quot;\n    else\n      echo &quot;${name}重启失败&quot;\n    fi\n   ;;\n   *)\n    echo &quot;${name}start|stop|restart&quot;\n   ;;\nesac\n</code></pre><ul>\n<li>3.加入系统服务和开机自启</li>\n</ul>\n<pre><code>cd /etc/init.d/\n#设置执行权限\nchmod a+x mongodb\n#加入系统服务\nchkconfig --add mongodb\n#开机服务自启\nchkconfig mongodb on\n#重启系统生效\nshutdown -r\n</code></pre><ul>\n<li>4.mongodb开启、停止、重启操作</li>\n</ul>\n<pre><code>#开启\nservice mongodb start\n#停止\nservice mongodb stop\n#重启\nservice mongodb restart\n</code></pre>","updated":"2018-04-25T08:30:12.000Z","comments":true,"link":"","categories":[{"name":"js","slug":"js","permalink":"http://yoursite.com/categories/js/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"好用的时间控件","date":"2018-04-24T07:03:58.000Z","path":"2018/04/24/time/","text":"好用的一款时间插件支持年，月，日，时，分，秒，各个阶段的查询 直接上代码 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;link href=&quot;https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;script src=&quot;https://cdn.bootcss.com/bootstrap/3.3.7/js/bootstrap.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.bootcss.com/moment.js/2.18.1/moment-with-locales.min.js&quot;&gt;&lt;/script&gt; &lt;link href=&quot;https://cdn.bootcss.com/bootstrap-datetimepicker/4.17.47/css/bootstrap-datetimepicker.min.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;script src=&quot;https://cdn.bootcss.com/bootstrap-datetimepicker/4.17.47/js/bootstrap-datetimepicker.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-sm-6&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;&quot;&gt;选择日期：&lt;/label&gt; &lt;div class=&quot;input-group date&quot; id=&#39;date1&#39;&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot;&gt; &lt;span class=&quot;input-group-addon&quot;&gt; &lt;i class=&quot;glyphicon glyphicon-calendar&quot;&gt;&lt;/i&gt; &lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; $(function () { var picker1=$(&#39;#date1&#39;).datetimepicker({ format: &#39;YYYY-MM-DD&#39;, //这里换成YYYY-MM表示到月，YYYY表示到年，YYYY-MM-DD HH:mm:ss表示到时分 defaultDate: &quot;2018-02-02&quot;, locale: moment.locale(&#39;zh-cn&#39;) }); picker1.on(&#39;dp.change&#39;, function (values) {//这里监听时间选择变化 var d = new Date(values.date._d); var year = d.getFullYear(); var month = (d.getMonth() + 1)&lt;10? &#39;0&#39;+(d.getMonth() + 1):(d.getMonth() + 1); var day = d.getDate()&lt;10? &#39;0&#39;+d.getDate():d.getDate(); var setter = year + &#39;-&#39; + month + &#39;-&#39;+ day; // $scope.startDateTime = setter; // sessionStorage.setItem(&quot;starttime&quot;, setter) }); }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;","content":"<h3 id=\"好用的一款时间插件支持年，月，日，时，分，秒，各个阶段的查询\"><a href=\"#好用的一款时间插件支持年，月，日，时，分，秒，各个阶段的查询\" class=\"headerlink\" title=\"好用的一款时间插件支持年，月，日，时，分，秒，各个阶段的查询\"></a>好用的一款时间插件支持年，月，日，时，分，秒，各个阶段的查询</h3><ul>\n<li>直接上代码</li>\n</ul>\n<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Document&lt;/title&gt;\n    &lt;script src=&quot;https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js&quot;&gt;&lt;/script&gt;  \n    &lt;link href=&quot;https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt;  \n    &lt;script src=&quot;https://cdn.bootcss.com/bootstrap/3.3.7/js/bootstrap.min.js&quot;&gt;&lt;/script&gt;  \n\n    &lt;script src=&quot;https://cdn.bootcss.com/moment.js/2.18.1/moment-with-locales.min.js&quot;&gt;&lt;/script&gt;  \n    &lt;link href=&quot;https://cdn.bootcss.com/bootstrap-datetimepicker/4.17.47/css/bootstrap-datetimepicker.min.css&quot; rel=&quot;stylesheet&quot;&gt;  \n    &lt;script src=&quot;https://cdn.bootcss.com/bootstrap-datetimepicker/4.17.47/js/bootstrap-datetimepicker.min.js&quot;&gt;&lt;/script&gt;  \n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div class=&quot;row&quot;&gt;  \n    &lt;div class=&quot;col-sm-6&quot;&gt;  \n        &lt;div class=&quot;form-group&quot;&gt;  \n            &lt;label for=&quot;&quot;&gt;选择日期：&lt;/label&gt;  \n            &lt;div class=&quot;input-group date&quot; id=&#39;date1&#39;&gt;  \n                &lt;input type=&quot;text&quot; class=&quot;form-control&quot;&gt;  \n                &lt;span class=&quot;input-group-addon&quot;&gt;  \n                    &lt;i class=&quot;glyphicon glyphicon-calendar&quot;&gt;&lt;/i&gt;  \n                &lt;/span&gt;  \n            &lt;/div&gt;  \n        &lt;/div&gt;  \n    &lt;/div&gt;  \n    &lt;script&gt;\n        $(function () {  \n           var picker1=$(&#39;#date1&#39;).datetimepicker({  \n                format: &#39;YYYY-MM-DD&#39;, //这里换成YYYY-MM表示到月，YYYY表示到年，YYYY-MM-DD HH:mm:ss表示到时分\n                defaultDate: &quot;2018-02-02&quot;,\n                locale: moment.locale(&#39;zh-cn&#39;)  \n            });  \n             picker1.on(&#39;dp.change&#39;, function (values) {//这里监听时间选择变化\n                        var d = new Date(values.date._d);\n                        var year = d.getFullYear();\n                        var month = (d.getMonth() + 1)&lt;10? &#39;0&#39;+(d.getMonth() + 1):(d.getMonth() + 1);\n                        var day = d.getDate()&lt;10? &#39;0&#39;+d.getDate():d.getDate();\n                        var setter = year + &#39;-&#39; + month + &#39;-&#39;+ day;\n                        // $scope.startDateTime = setter;\n                        // sessionStorage.setItem(&quot;starttime&quot;, setter)\n                    });\n        });  \n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>","updated":"2018-04-24T09:59:36.000Z","comments":true,"link":"","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://yoursite.com/categories/前端开发/"}],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"工作实用总结","date":"2018-03-08T07:03:58.000Z","path":"2018/03/08/workuser/","text":"1.生成随机字符串function randomStr() { return Math.random().toString(36).substring(2); } 2.判断一个实例是否为 数组的几种方法 1.console.log(arr instanceof Array) 2.console.log(Array.isArray(arr)) 3.console.log(arr.constructor === Array) 4.console.log(Object.prototype.toString.call(arr) === &#39;[Object Array]&#39;) 5.console.log(Object.prototype.toString.call(function(){})) 判断滚动条是向上还是向下$(document).ready(function(){ var position=0,top=0; $(window).scroll(function(e){ position = $(this).scrollTop(); if(top&lt;=position){//下滚 ....... } else{//上滚 ....... } setTimeout(function(){top = position;},0); }); }); 利用padding制作响应式正方形 有些情况下、我们要做响应式的布局、来应对多设备、或者多分辨率 来个简单的需求 需求：每行三个正方形、依次排开、做列表、流式 最简单的需求出来了、那我们直接开搞 首先、我们要了解到、padding的百分比是基于谁的 这里敲了几下黑白、这道送分题、相信很多人心中已经知道了答案 那就是 基于父元素的宽度 注意、是宽度、也就是说、利用这个特性、我们父子元素保持宽度一致、 子元素的padding是100%、就可以达到效果 &lt;style&gt; *{ padding: 0; margin: 0; } .list{ width: 100%; padding: 5px 16px; box-sizing: border-box; } /*用padding的方式*/ .square-box{ margin: 5px auto; padding: 0 5px; box-sizing: border-box; float:left; width:calc(100%/3) } .square{ width: calc(100%); padding-bottom: 100%; background: red; box-sizing: border-box; } /*用calc的方式*/ /*.square-box{ margin: 5px auto; box-sizing: border-box; float:left; width:calc(100%/3) } .square{ margin: 0 auto; width: calc(100% - 16px * 2); padding-bottom: calc(100% - 16px * 2); background: red; box-sizing: border-box; }*/ &lt;/style&gt; &lt;div class=&quot;list&quot;&gt; &lt;div class=&quot;square-box&quot;&gt; &lt;div class=&quot;square&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;square-box&quot;&gt; &lt;div class=&quot;square&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;square-box&quot;&gt; &lt;div class=&quot;square&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;square-box&quot;&gt; &lt;div class=&quot;square&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;square-box&quot;&gt; &lt;div class=&quot;square&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div style=&quot;clear:both&quot;&gt;&lt;/div&gt; &lt;div class=&quot;text-center&quot;&gt;试着放大缩小窗口&lt;/div&gt; 制作两端对齐响应式布局 制作这个布局主要用到了text-align: justify 大家应该知道、这是文字两端对齐的css样式 但是注意了（敲敲黑板） 没有换行的文本不会生效 那么这里有一个投机的办法、就是用:after的content属性为它创造换行的环境 用到这个、我还想起了一个和他很像的属性text-align-last: justify 但是text-align-last 只有IE和Firefox支持 那么就不考虑、喜欢尝试的同学可以下去自己试一下 那么只需要把元素设为inline-block并且加上after伪类就可以了 &lt;style&gt; .test{ text-align: justify; } .test .box{ display: inline-block; width: 100px; height: 100px; background: red; } .test:after {width: 100%;height: 0;margin: 0;display: inline-block;overflow: hidden;content: &#39;&#39;;} &lt;/style&gt; &lt;div class=&quot;test&quot;&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;text-center&quot;&gt;试着放大缩小窗口&lt;/div&gt; 判断浏览器为PC还是移动端 判断userAgent、根据正则、找出对应的设备或者浏览器 &lt;script type=&quot;text/javascript&quot;&gt; function browserRedirect() { var sUserAgent = navigator.userAgent.toLowerCase(); var bIsIpad = sUserAgent.match(/ipad/i) == &quot;ipad&quot;; var bIsIphoneOs = sUserAgent.match(/iphone os/i) == &quot;iphone os&quot;; var bIsMidp = sUserAgent.match(/midp/i) == &quot;midp&quot;; var bIsUc7 = sUserAgent.match(/rv:1.2.3.4/i) == &quot;rv:1.2.3.4&quot;; var bIsUc = sUserAgent.match(/ucweb/i) == &quot;ucweb&quot;; var bIsAndroid = sUserAgent.match(/android/i) == &quot;android&quot;; var bIsCE = sUserAgent.match(/windows ce/i) == &quot;windows ce&quot;; var bIsWM = sUserAgent.match(/windows mobile/i) == &quot;windows mobile&quot;; document.writeln(&quot;您的浏览设备为：&quot;); if (bIsIpad || bIsIphoneOs || bIsMidp || bIsUc7 || bIsUc || bIsAndroid || bIsCE || bIsWM) { document.writeln(&quot;phone&quot;); } else { document.writeln(&quot;pc&quot;); } } browserRedirect(); &lt;/script&gt; Js 将字符串对象转换成对象的三种方法 如果某天从后端返回的对象莫名其妙的变成了字符串、需要前端处理成对象、再去取值的话,那就需要用到、字符串强转对象了 首先我们要转换的东西可能是这个样子： ‘{“name”:”test”}’ JSON的标准写法应该是KEY和VALUE都带引号的 我们要将这样的字符串转为对象、有三种方法可以参考使用 第一种可能是大家用的非常之多的、用JSON对象下面的方法.parse() 写起来可能是这样的： var jsonData = &#39;{&quot;name&quot;:&quot;test&quot;}&#39;; var obj = JSON.parse(jsonData) console.log(obj.name);//&quot;test&quot; JSON.parse()和JSON.stringify() 是我用的比较多的方法 第二种是利用JS的eval()函数 var jsonData = &#39;{&quot;name&quot;:&quot;test&quot;}&#39;; var obj= eval(&#39;(&#39;+ jsonData +&#39;)&#39;); console.log(obj.name);//&quot;test&quot; 这里要解释一下、为什么要再eval里面头尾加入圆括号、因为eval()是以函数语句解析的、那么其中的{}大括号会用作标记为作用域、或者方法体类似的概念、我们想要把他解析成对象就不会成功了 eval(‘{}’)eval(‘({})’)//返回的是一个obj第三种是用Function对象 var jsonData = &#39;{&quot;name&quot;:&quot;test&quot;}&#39;; var obj = new Function(&#39;return &#39; + jsonData)(); console.log(obj.name);//&quot;test&quot; 原理比较类似第二种、将return 拼接字符串对象、放入function 执行的时候、由于将字符串解析成了语句、所以return出去的是一个对象 以上就是今天所要说的三种方法、欢迎补充！ 水平出现滚动条布局 &lt;style&gt; ul{ width: 50%; height: 100px; border: 1px solid #ddd; padding: 10px; box-sizing: border-box; white-space: nowrap; overflow: hidden; overflow-x: scroll; /* 1 */ -webkit-backface-visibility: hidden; -webkit-perspective: 1000; -webkit-overflow-scrolling: touch; /* 2 */ text-align: justify; /* 3 */ &amp;::-webkit-scrollbar { display: none; } } ul li{ display: inline-block; width: 100px; background-color: red; margin-right: 20px; height: 80px; } &lt;/style&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt; &lt;li&gt;6&lt;/li&gt; &lt;li&gt;7&lt;/li&gt; &lt;li&gt;8&lt;/li&gt; &lt;li&gt;9&lt;/li&gt; &lt;li&gt;10&lt;/li&gt; &lt;li&gt;11&lt;/li&gt; &lt;li&gt;12&lt;/li&gt; &lt;li&gt;13&lt;/li&gt; &lt;li&gt;14&lt;/li&gt; &lt;li&gt;15&lt;/li&gt; &lt;li&gt;16&lt;/li&gt; &lt;li&gt;17&lt;/li&gt; &lt;li&gt;18&lt;/li&gt; &lt;/ul&gt; 百度语音阅读接口 http://fanyi.baidu.com/gettts?lan=zh&amp;text=&quot;哈哈哈&quot;&amp;spd=5&amp;source=web gitHub创建一个仓库时选择： 1.勾选Initialize this repository with a README2.Add.gitignore:选择node3.Add a license:选择MIT License 导航添加鼠标移动添加下划线效果&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;&gt; &lt;title&gt;Examples&lt;/title&gt; &lt;meta name=&quot;description&quot; content=&quot;&quot;&gt; &lt;meta name=&quot;keywords&quot; content=&quot;&quot;&gt; &lt;style&gt; ul{ width: 800px; margin: 0 auto; height: 50px; font-size: 0; } li{ list-style: none; position: relative; display: inline-block; line-height: 50px; padding: 0 10px; box-sizing: border-box; font-size: 18px; height: 50px; border-bottom:0px solid #000; } li::before{ content: &#39;&#39;; position: absolute; left: 100%; top: 0; width: 0; height: 100%; border-bottom:3px solid red; transition: 0.2s all linear; } li:hover::before{ width: 100%; left:0; } li:hover ~ li:before{ left:0; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;ul&gt; &lt;li&gt;哈哈哈&lt;/li&gt; &lt;li&gt;行搜索&lt;/li&gt; &lt;li&gt;很好&lt;/li&gt; &lt;li&gt;不好吗密码&lt;/li&gt; &lt;li&gt;很棒部&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt; &lt;/html&gt;","content":"<h3 id=\"1-生成随机字符串\"><a href=\"#1-生成随机字符串\" class=\"headerlink\" title=\"1.生成随机字符串\"></a>1.生成随机字符串</h3><pre><code>function randomStr() {\n    return Math.random().toString(36).substring(2);\n}\n</code></pre><h3 id=\"2-判断一个实例是否为-数组的几种方法\"><a href=\"#2-判断一个实例是否为-数组的几种方法\" class=\"headerlink\" title=\"2.判断一个实例是否为 数组的几种方法\"></a>2.判断一个实例是否为 数组的几种方法</h3><pre><code>    1.console.log(arr instanceof Array)\n    2.console.log(Array.isArray(arr))\n    3.console.log(arr.constructor === Array)\n    4.console.log(Object.prototype.toString.call(arr) === &#39;[Object Array]&#39;)\n    5.console.log(Object.prototype.toString.call(function(){}))\n</code></pre><h3 id=\"判断滚动条是向上还是向下\"><a href=\"#判断滚动条是向上还是向下\" class=\"headerlink\" title=\"判断滚动条是向上还是向下\"></a>判断滚动条是向上还是向下</h3><pre><code>$(document).ready(function(){\n    var position=0,top=0;\n\n    $(window).scroll(function(e){\n            position = $(this).scrollTop();\n\n            if(top&lt;=position){//下滚\n                .......\n            }\n\n            else{//上滚\n                .......\n            }\n            setTimeout(function(){top = position;},0);\n    });\n});\n</code></pre><h3 id=\"利用padding制作响应式正方形\"><a href=\"#利用padding制作响应式正方形\" class=\"headerlink\" title=\"利用padding制作响应式正方形\"></a>利用padding制作响应式正方形</h3><ul>\n<li><p>有些情况下、我们要做响应式的布局、来应对多设备、或者多分辨率</p>\n</li>\n<li><p>来个简单的需求</p>\n</li>\n<li><p>需求：每行三个正方形、依次排开、做列表、流式</p>\n</li>\n<li><p>最简单的需求出来了、那我们直接开搞</p>\n</li>\n<li><p>首先、我们要了解到、padding的百分比是基于谁的</p>\n</li>\n<li><p>这里敲了几下黑白、这道送分题、相信很多人心中已经知道了答案</p>\n</li>\n<li><p>那就是 基于父元素的宽度</p>\n</li>\n<li><p>注意、是宽度、也就是说、利用这个特性、我们父子元素保持宽度一致、</p>\n</li>\n<li><p>子元素的padding是100%、就可以达到效果</p>\n</li>\n</ul>\n<pre><code>&lt;style&gt;\n  *{\n    padding: 0;\n    margin: 0;\n  }\n  .list{\n    width: 100%;\n    padding: 5px 16px;\n    box-sizing: border-box;\n  }\n  /*用padding的方式*/\n  .square-box{\n    margin: 5px auto;\n    padding: 0 5px;\n    box-sizing: border-box;\n    float:left;\n    width:calc(100%/3)\n  }\n  .square{\n    width: calc(100%);\n    padding-bottom: 100%;\n    background: red;\n    box-sizing: border-box;\n  }\n  /*用calc的方式*/\n  /*.square-box{\n    margin: 5px auto;\n    box-sizing: border-box;\n    float:left;\n    width:calc(100%/3)\n  }\n  .square{\n    margin: 0 auto;\n    width: calc(100% - 16px * 2);\n    padding-bottom: calc(100% - 16px * 2);\n    background: red;\n    box-sizing: border-box;\n  }*/\n&lt;/style&gt;\n\n&lt;div class=&quot;list&quot;&gt;\n  &lt;div class=&quot;square-box&quot;&gt;\n    &lt;div class=&quot;square&quot;&gt;&lt;/div&gt;\n  &lt;/div&gt;\n  &lt;div class=&quot;square-box&quot;&gt;\n    &lt;div class=&quot;square&quot;&gt;&lt;/div&gt;\n  &lt;/div&gt;\n  &lt;div class=&quot;square-box&quot;&gt;\n    &lt;div class=&quot;square&quot;&gt;&lt;/div&gt;\n  &lt;/div&gt;\n  &lt;div class=&quot;square-box&quot;&gt;\n    &lt;div class=&quot;square&quot;&gt;&lt;/div&gt;\n  &lt;/div&gt;\n  &lt;div class=&quot;square-box&quot;&gt;\n    &lt;div class=&quot;square&quot;&gt;&lt;/div&gt;\n  &lt;/div&gt;\n&lt;/div&gt;\n&lt;div style=&quot;clear:both&quot;&gt;&lt;/div&gt;\n&lt;div class=&quot;text-center&quot;&gt;试着放大缩小窗口&lt;/div&gt;\n</code></pre><h3 id=\"制作两端对齐响应式布局\"><a href=\"#制作两端对齐响应式布局\" class=\"headerlink\" title=\"制作两端对齐响应式布局\"></a>制作两端对齐响应式布局</h3><ul>\n<li><p>制作这个布局主要用到了text-align: justify</p>\n</li>\n<li><p>大家应该知道、这是文字两端对齐的css样式</p>\n</li>\n<li><p>但是注意了（敲敲黑板） 没有换行的文本不会生效</p>\n</li>\n<li><p>那么这里有一个投机的办法、就是用:after的content属性为它创造换行的环境</p>\n</li>\n<li><p>用到这个、我还想起了一个和他很像的属性text-align-last: justify</p>\n</li>\n<li><p>但是text-align-last 只有IE和Firefox支持</p>\n</li>\n<li><p>那么就不考虑、喜欢尝试的同学可以下去自己试一下</p>\n</li>\n<li><p>那么只需要把元素设为inline-block并且加上after伪类就可以了</p>\n</li>\n</ul>\n<pre><code>&lt;style&gt;\n  .test{\n    text-align: justify;\n  }\n  .test .box{\n    display: inline-block;\n    width: 100px;\n    height: 100px;\n    background: red;\n  }\n  .test:after {width: 100%;height: 0;margin: 0;display: inline-block;overflow: hidden;content: &#39;&#39;;}\n&lt;/style&gt;\n\n&lt;div class=&quot;test&quot;&gt;\n  &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n  &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n  &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n  &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n  &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n  &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n  &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n&lt;/div&gt;\n&lt;div class=&quot;text-center&quot;&gt;试着放大缩小窗口&lt;/div&gt;\n</code></pre><h3 id=\"判断浏览器为PC还是移动端\"><a href=\"#判断浏览器为PC还是移动端\" class=\"headerlink\" title=\"判断浏览器为PC还是移动端\"></a>判断浏览器为PC还是移动端</h3><ul>\n<li>判断userAgent、根据正则、找出对应的设备或者浏览器</li>\n</ul>\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\n    function browserRedirect() {\n        var sUserAgent = navigator.userAgent.toLowerCase();\n        var bIsIpad = sUserAgent.match(/ipad/i) == &quot;ipad&quot;;\n        var bIsIphoneOs = sUserAgent.match(/iphone os/i) == &quot;iphone os&quot;;\n        var bIsMidp = sUserAgent.match(/midp/i) == &quot;midp&quot;;\n        var bIsUc7 = sUserAgent.match(/rv:1.2.3.4/i) == &quot;rv:1.2.3.4&quot;;\n        var bIsUc = sUserAgent.match(/ucweb/i) == &quot;ucweb&quot;;\n        var bIsAndroid = sUserAgent.match(/android/i) == &quot;android&quot;;\n        var bIsCE = sUserAgent.match(/windows ce/i) == &quot;windows ce&quot;;\n        var bIsWM = sUserAgent.match(/windows mobile/i) == &quot;windows mobile&quot;;\n        document.writeln(&quot;您的浏览设备为：&quot;);\n        if (bIsIpad || bIsIphoneOs || bIsMidp || bIsUc7 || bIsUc || bIsAndroid || bIsCE || bIsWM) {\n            document.writeln(&quot;phone&quot;);\n        } else {\n            document.writeln(&quot;pc&quot;);\n        }\n    }\n\n    browserRedirect();\n&lt;/script&gt;\n</code></pre><h3 id=\"Js-将字符串对象转换成对象的三种方法\"><a href=\"#Js-将字符串对象转换成对象的三种方法\" class=\"headerlink\" title=\"Js 将字符串对象转换成对象的三种方法\"></a>Js 将字符串对象转换成对象的三种方法</h3><ul>\n<li><p>如果某天从后端返回的对象莫名其妙的变成了字符串、需要前端处理成对象、再去取值的话,那就需要用到、字符串强转对象了</p>\n</li>\n<li><p>首先我们要转换的东西可能是这个样子：</p>\n</li>\n</ul>\n<blockquote>\n<p>‘{“name”:”test”}’</p>\n</blockquote>\n<ul>\n<li><p>JSON的标准写法应该是KEY和VALUE都带引号的</p>\n</li>\n<li><p>我们要将这样的字符串转为对象、有三种方法可以参考使用</p>\n</li>\n<li><p>第一种可能是大家用的非常之多的、用JSON对象下面的方法.parse()</p>\n</li>\n<li><p>写起来可能是这样的：</p>\n</li>\n</ul>\n<pre><code>var jsonData = &#39;{&quot;name&quot;:&quot;test&quot;}&#39;;\nvar obj = JSON.parse(jsonData)\nconsole.log(obj.name);//&quot;test&quot;\nJSON.parse()和JSON.stringify() 是我用的比较多的方法\n</code></pre><ul>\n<li>第二种是利用JS的eval()函数</li>\n</ul>\n<pre><code>var jsonData = &#39;{&quot;name&quot;:&quot;test&quot;}&#39;;\nvar obj= eval(&#39;(&#39;+ jsonData +&#39;)&#39;);\nconsole.log(obj.name);//&quot;test&quot;\n</code></pre><ul>\n<li>这里要解释一下、为什么要再eval里面头尾加入圆括号、因为eval()是以函数语句解析的、那么其中的{}大括号会用作标记为作用域、或者方法体类似的概念、我们想要把他解析成对象就不会成功了</li>\n</ul>\n<blockquote>\n<p>eval(‘{}’)<br>eval(‘({})’)//返回的是一个obj<br>第三种是用Function对象</p>\n</blockquote>\n<pre><code>var jsonData = &#39;{&quot;name&quot;:&quot;test&quot;}&#39;;\nvar obj = new Function(&#39;return &#39; + jsonData)();\nconsole.log(obj.name);//&quot;test&quot;\n</code></pre><ul>\n<li><p>原理比较类似第二种、将return 拼接字符串对象、放入function</p>\n</li>\n<li><p>执行的时候、由于将字符串解析成了语句、所以return出去的是一个对象</p>\n</li>\n<li><p>以上就是今天所要说的三种方法、欢迎补充！</p>\n</li>\n</ul>\n<h3 id=\"水平出现滚动条布局\"><a href=\"#水平出现滚动条布局\" class=\"headerlink\" title=\"水平出现滚动条布局\"></a>水平出现滚动条布局</h3><pre><code>  &lt;style&gt;\n    ul{\n      width: 50%;\n      height: 100px;\n      border: 1px solid #ddd;\n      padding: 10px;\n      box-sizing: border-box;\n      white-space: nowrap;\n      overflow: hidden;\n      overflow-x: scroll; /* 1 */\n      -webkit-backface-visibility: hidden;\n      -webkit-perspective: 1000;\n      -webkit-overflow-scrolling: touch; /* 2 */\n      text-align: justify; /* 3 */\n      &amp;::-webkit-scrollbar {\n          display: none;\n      }\n  }\n  ul li{\n    display: inline-block;\n    width: 100px;\n    background-color: red;\n    margin-right: 20px;\n    height: 80px;\n  }\n\n  &lt;/style&gt;\n &lt;ul&gt;\n      &lt;li&gt;1&lt;/li&gt;\n      &lt;li&gt;2&lt;/li&gt;\n      &lt;li&gt;3&lt;/li&gt;\n      &lt;li&gt;4&lt;/li&gt;\n      &lt;li&gt;5&lt;/li&gt;\n      &lt;li&gt;6&lt;/li&gt;\n      &lt;li&gt;7&lt;/li&gt;\n      &lt;li&gt;8&lt;/li&gt;\n      &lt;li&gt;9&lt;/li&gt;\n      &lt;li&gt;10&lt;/li&gt;\n      &lt;li&gt;11&lt;/li&gt;\n      &lt;li&gt;12&lt;/li&gt;\n      &lt;li&gt;13&lt;/li&gt;\n      &lt;li&gt;14&lt;/li&gt;\n      &lt;li&gt;15&lt;/li&gt;\n      &lt;li&gt;16&lt;/li&gt;\n      &lt;li&gt;17&lt;/li&gt;\n      &lt;li&gt;18&lt;/li&gt;\n    &lt;/ul&gt;\n</code></pre><h3 id=\"百度语音阅读接口\"><a href=\"#百度语音阅读接口\" class=\"headerlink\" title=\"百度语音阅读接口\"></a>百度语音阅读接口</h3><blockquote>\n<p><a href=\"http://fanyi.baidu.com/gettts?lan=zh&amp;text=&quot;哈哈哈&quot;&amp;spd=5&amp;source=web\">http://fanyi.baidu.com/gettts?lan=zh&amp;text=&quot;哈哈哈&quot;&amp;spd=5&amp;source=web</a></p>\n</blockquote>\n<h3 id=\"gitHub创建一个仓库时选择：\"><a href=\"#gitHub创建一个仓库时选择：\" class=\"headerlink\" title=\"gitHub创建一个仓库时选择：\"></a>gitHub创建一个仓库时选择：</h3><blockquote>\n<p>1.勾选Initialize this repository with a README<br>2.Add.gitignore:选择node<br>3.Add a license:选择MIT License</p>\n</blockquote>\n<h3 id=\"导航添加鼠标移动添加下划线效果\"><a href=\"#导航添加鼠标移动添加下划线效果\" class=\"headerlink\" title=\"导航添加鼠标移动添加下划线效果\"></a>导航添加鼠标移动添加下划线效果</h3><pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;meta charset=&quot;utf-8&quot;&gt;\n&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;&gt;\n&lt;title&gt;Examples&lt;/title&gt;\n&lt;meta name=&quot;description&quot; content=&quot;&quot;&gt;\n&lt;meta name=&quot;keywords&quot; content=&quot;&quot;&gt;\n&lt;style&gt;\n  ul{\n\n    width: 800px;\n    margin: 0 auto;\n    height: 50px;\n    font-size: 0;\n  }\n  li{\n    list-style: none;\n    position: relative;\n    display: inline-block;\n    line-height: 50px;\n    padding: 0 10px;\n    box-sizing: border-box;\n    font-size: 18px;\n    height: 50px;\n    border-bottom:0px solid #000;\n  }\n  li::before{\n    content: &#39;&#39;;\n    position: absolute;\n    left: 100%;\n    top: 0;\n    width: 0;\n    height: 100%;\n    border-bottom:3px solid red;\n    transition: 0.2s all linear;\n  }\n  li:hover::before{\n    width: 100%;\n    left:0;\n  }\n  li:hover ~ li:before{\n    left:0;\n  }\n&lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;ul&gt;\n      &lt;li&gt;哈哈哈&lt;/li&gt;\n      &lt;li&gt;行搜索&lt;/li&gt;\n      &lt;li&gt;很好&lt;/li&gt;\n      &lt;li&gt;不好吗密码&lt;/li&gt;\n      &lt;li&gt;很棒部&lt;/li&gt;\n    &lt;/ul&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>","updated":"2018-04-04T01:47:44.000Z","comments":true,"link":"","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://yoursite.com/categories/前端开发/"}],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"使用formidable做node的文件上传，并利用iframe让表单提交不跳转","date":"2018-03-08T07:03:58.000Z","path":"2018/03/08/nodeFilleUpload/","text":"使用formidable做node的文件上传，并利用iframe让表单提交不跳转 今天做功能做到了文件上传、之前做过img的上传是用的h5的fileReader对象转base64上传 遇到纯数据文件上传确实做的时候遇到了很多问题 开始的时候想的用ajax传（以前base64就是长字符串、可以用ajax），发现ajax只能传字符串、不然就要引用插件、对于现在的项目来说、引入插件也会变得冗余、所以寻求一个其他的方法 先没管那么多、先用表单传过去看看吧、发现传文件流需要给from表单一个比较重要的属性enctype=”multipart/form-data” 这里是前台代码v-on：change的方法可以理解成onchange触发submit() &lt;form id=&quot;fileForm&quot; method=&quot;post&quot; action=&quot;/data/import&quot; enctype=&quot;multipart/form-data&quot; &gt; &lt;a href=&quot;#&quot; class=&quot;btn btn-primary uploaderBtn&quot;&gt; 上传 &lt;input type=&quot;file&quot; id=&quot;test&quot; name=&quot;files&quot; v-on:change=&quot;importData(&#39;fileForm&#39;)&quot;/&gt; &lt;/a&gt; &lt;/form&gt; 提交之后、node这边应该用我们的主角formidable抓取请求了 首先install这一步是一定的 npm install formidable --save-dev //fs文件操作模块（可选项） npm install formidable --save-dev 用require的方式引入 var formidable = require(&#39;formidable&#39;); var fs = require(&#39;fs&#39;); 方法中我们要先new一个formidable对象并设置他的属性 var form = new formidable(); form.encoding = &#39;utf-8&#39;; //设置编辑 form.uploadDir = &#39;static&#39; //设置上传目录 form.keepExtensions = true; //保留后缀 form.maxFieldsSize = 2 * 1024 * 1024; //文件大小 调用form.parse()方法 form.parse(req, (err, fields, files)=&gt;{ if (err) { console.log(&quot;文件上传报错&quot;+err); res.send(err); } //这里我把上传的文件读取出来 var data = fs.readFileSync(files.files.path,&#39;utf-8&#39;); //你要做的操作 ... } 到了这一步、上传可以实现了、但是前台传完文件之后会跳转到action的地址、这对于我来说是不想看到的 所以便有了iframe的出现 &lt;iframe name=&quot;testIframeName&quot; style=&quot;display:none;&quot;&gt;&lt;/iframe&gt; &lt;form target=&quot;testIframeName&quot; id=&quot;fileForm&quot; method=&quot;post&quot; action=&quot;/data/import&quot; enctype=&quot;multipart/form-data&quot; &gt; &lt;a href=&quot;#&quot; class=&quot;btn btn-primary uploaderBtn&quot;&gt; 上传 &lt;input type=&quot;file&quot; id=&quot;test&quot; name=&quot;files&quot; v-on:change=&quot;importData(&#39;fileForm&#39;)&quot;/&gt; &lt;/a&gt; &lt;/form&gt; 改写了一下前台页面、加入了一个iframe并且把他们用target链接到一起、意义在于、form提交之后、iframe去跳转、form表单不会跳转、iframe是看不见的、所以达到了简单实现我们要的效果","content":"<h3 id=\"使用formidable做node的文件上传，并利用iframe让表单提交不跳转\"><a href=\"#使用formidable做node的文件上传，并利用iframe让表单提交不跳转\" class=\"headerlink\" title=\"使用formidable做node的文件上传，并利用iframe让表单提交不跳转\"></a>使用formidable做node的文件上传，并利用iframe让表单提交不跳转</h3><ul>\n<li><p>今天做功能做到了文件上传、之前做过img的上传是用的h5的fileReader对象转base64上传 遇到纯数据文件上传确实做的时候遇到了很多问题</p>\n</li>\n<li><p>开始的时候想的用ajax传（以前base64就是长字符串、可以用ajax），发现ajax只能传字符串、不然就要引用插件、对于现在的项目来说、引入插件也会变得冗余、所以寻求一个其他的方法</p>\n</li>\n<li><p>先没管那么多、先用表单传过去看看吧、发现传文件流需要给from表单一个比较重要的属性enctype=”multipart/form-data”</p>\n</li>\n<li><p>这里是前台代码v-on：change的方法可以理解成onchange触发submit()</p>\n</li>\n</ul>\n<pre><code>&lt;form id=&quot;fileForm&quot; method=&quot;post&quot; action=&quot;/data/import&quot; enctype=&quot;multipart/form-data&quot; &gt;\n    &lt;a href=&quot;#&quot; class=&quot;btn btn-primary uploaderBtn&quot;&gt;\n            上传\n        &lt;input type=&quot;file&quot; id=&quot;test&quot; name=&quot;files&quot; v-on:change=&quot;importData(&#39;fileForm&#39;)&quot;/&gt;\n    &lt;/a&gt;\n&lt;/form&gt;\n</code></pre><ul>\n<li><p>提交之后、node这边应该用我们的主角formidable抓取请求了</p>\n</li>\n<li><p>首先install这一步是一定的</p>\n</li>\n</ul>\n<pre><code>npm install formidable --save-dev\n//fs文件操作模块（可选项）\nnpm install formidable --save-dev\n</code></pre><ul>\n<li>用require的方式引入</li>\n</ul>\n<pre><code>var formidable = require(&#39;formidable&#39;);\nvar fs = require(&#39;fs&#39;);\n</code></pre><ul>\n<li>方法中我们要先new一个formidable对象并设置他的属性</li>\n</ul>\n<pre><code>var form = new formidable();\nform.encoding = &#39;utf-8&#39;;        //设置编辑\nform.uploadDir = &#39;static&#39;     //设置上传目录\nform.keepExtensions = true;     //保留后缀\nform.maxFieldsSize = 2 * 1024 * 1024;   //文件大小\n</code></pre><ul>\n<li>调用form.parse()方法</li>\n</ul>\n<pre><code>form.parse(req, (err, fields, files)=&gt;{\n\n    if (err) {\n      console.log(&quot;文件上传报错&quot;+err);\n      res.send(err);        \n    }\n    //这里我把上传的文件读取出来\n    var data = fs.readFileSync(files.files.path,&#39;utf-8&#39;);\n    //你要做的操作\n    ...\n}\n</code></pre><ul>\n<li><p>到了这一步、上传可以实现了、但是前台传完文件之后会跳转到action的地址、这对于我来说是不想看到的</p>\n</li>\n<li><p>所以便有了iframe的出现</p>\n</li>\n</ul>\n<pre><code>&lt;iframe name=&quot;testIframeName&quot; style=&quot;display:none;&quot;&gt;&lt;/iframe&gt;\n&lt;form target=&quot;testIframeName&quot; id=&quot;fileForm&quot; method=&quot;post&quot; action=&quot;/data/import&quot; enctype=&quot;multipart/form-data&quot; &gt;\n    &lt;a href=&quot;#&quot; class=&quot;btn btn-primary uploaderBtn&quot;&gt;\n        上传\n        &lt;input type=&quot;file&quot; id=&quot;test&quot; name=&quot;files&quot; v-on:change=&quot;importData(&#39;fileForm&#39;)&quot;/&gt;\n    &lt;/a&gt;\n&lt;/form&gt;\n</code></pre><ul>\n<li>改写了一下前台页面、加入了一个iframe并且把他们用target链接到一起、意义在于、form提交之后、iframe去跳转、form表单不会跳转、iframe是看不见的、所以达到了简单实现我们要的效果</li>\n</ul>\n","updated":"2018-03-29T06:02:30.000Z","comments":true,"link":"","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://yoursite.com/categories/前端开发/"}],"tags":[{"name":"Node","slug":"Node","permalink":"http://yoursite.com/tags/Node/"}]},{"title":"如何使用Nuxt.js入门","date":"2018-03-02T07:03:12.000Z","path":"2018/03/02/nuxt/","text":"初学者模板或使用vue-cli安装它： vue init nuxt/starter project-name 如果vue-cli没有安装，请安装npm install -g vue-cli 然后安装依赖关系： $ cd &lt;project-name&gt; $ npm install 或者用 yarn install 并通过以下方式启动项目 npm run dev 该应用程序现在在http：// localhost：3000上运行 Nuxt.js将监听pages目录中的文件更改，因此在添加新页面时不需要重新启动应用程序。 目录结构介绍 资产目录 该assets目录包含您未编译的资产，如Less，Sass或JavaScript 默认情况下，vue-loader会使用css-loader和Vue模板编译器自动处理样式和模板文件。在此编译过程中，所有资产的URL，例如，background: url(…)和CSS @import的解析为模块依赖关系。 如有下目录结构： -| assets/ ----| image.png -| pages/ ----| index.vue 你的CSS中，如果你使用url(‘~/assets/image.png’)，它会被翻译成require(‘~/assets/image.png’)。 或者如果在pages/index.vue你使用 &lt;template&gt; &lt;img src=&quot;~/assets/image.png&quot;&gt; &lt;/template&gt; 静态的 如果您不想使用该assets目录中的webpacked Assets，则可以static在项目根目录中创建并使用该目录。 这些文件将由Nuxt自动提供，并可在您的项目根URL中访问。 此选项对于像文件有帮助robots.txt，sitemap.xml或CNAME（像GitHub的页面）。 从您的代码中，您可以使用/URL 来引用这些文件： &lt;!-- 这是来自Static目录中图片使用方法 image from static directory --&gt; &lt;img src=&quot;/my-image.png&quot;/&gt; &lt;!-- 这是来自assets目录中图片使用方法 webpacked image from assets directory --&gt; &lt;img src=&quot;~/assets/my-image-2.png&quot;/&gt; 组件目录 该components目录包含您的Vue.js组件。Nuxt.js不会增加这些组件的数据方法 布局目录 该layouts目录包含您的应用程序布局。该目录不能被重命名。视图部分描述了在Nuxt.js应用程序（文档，布局，页面和HTML头）中为特定路线配置数据和视图所需的全部内容。 文件 要扩展HTML模板，请app.html在项目的根目录下创建。默认模板是： &lt;!DOCTYPE html&gt; &lt;html {{ HTML_ATTRS }}&gt; &lt;head&gt; {{ HEAD }} &lt;/head&gt; &lt;body {{ BODY_ATTRS }}&gt; {{ APP }} &lt;/body&gt; &lt;/html&gt; 一个例子是为IE添加条件CSS类html模板： &lt;!DOCTYPE html&gt; &lt;!--[if IE 9]&gt;&lt;html lang=&quot;en-US&quot; class=&quot;lt-ie9 ie9&quot; {{ HTML_ATTRS }}&gt;&lt;![endif]--&gt; &lt;!--[if (gt IE 9)|!(IE)]&gt;&lt;!--&gt;&lt;html {{ HTML_ATTRS }}&gt;&lt;!--&lt;![endif]--&gt; &lt;head&gt; {{ HEAD }} &lt;/head&gt; &lt;body {{ BODY_ATTRS }}&gt; {{ APP }} &lt;/body&gt; &lt;/html&gt; 布局 Nuxt.js允许您扩展主布局或通过在layouts目录中添加它们来创建自定义布局。 默认布局 您可以通过添加layouts/default.vue文件来扩展主布局。 确保在创建布局以显示页面组件时添加组件。 默认的布局源代码是： &lt;template&gt; &lt;nuxt/&gt; &lt;/template&gt; 错误页面 您可以通过添加layouts/error.vue文件来自定义错误页面。 这种布局是特殊的，因为你应该不包括它的模板中。必须看到这布局发生错误时（一个组件显示404，500等）。 GitHub上提供了默认的错误页面源代码。 &lt;template&gt; &lt;div class=&quot;__nuxt-error-page&quot;&gt; &lt;div class=&quot;error&quot;&gt; &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;90&quot; height=&quot;90&quot; fill=&quot;#DBE1EC&quot; viewBox=&quot;0 0 48 48&quot;&gt;&lt;path d=&quot;M22 30h4v4h-4zm0-16h4v12h-4zm1.99-10C12.94 4 4 12.95 4 24s8.94 20 19.99 20S44 35.05 44 24 35.04 4 23.99 4zM24 40c-8.84 0-16-7.16-16-16S15.16 8 24 8s16 7.16 16 16-7.16 16-16 16z&quot;/&gt;&lt;/svg&gt; &lt;div class=&quot;title&quot;&gt;{{ message }}&lt;/div&gt; &lt;p class=&quot;description&quot; v-if=&quot;statusCode === 404&quot;&gt; &lt;nuxt-link class=&quot;error-link&quot; to=&quot;/&quot;&gt;&lt;%= messages.back_to_home %&gt;&lt;/nuxt-link&gt; &lt;/p&gt; &lt;% if(debug) { %&gt; &lt;p class=&quot;description&quot; v-else&gt;&lt;%= messages.client_error_details %&gt;&lt;/p&gt; &lt;% } %&gt; &lt;div class=&quot;logo&quot;&gt; &lt;a href=&quot;https://nuxtjs.org&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;%= messages.nuxtjs %&gt;&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: &#39;nuxt-error&#39;, props: [&#39;error&#39;], head () { return { title: this.message, meta: [ { name: &#39;viewport&#39;, content: &#39;width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no&#39; } ] } }, &lt;% if(debug) { %&gt; // Only on debug mode data () { return { mounted: false } }, mounted () { this.mounted = true }, created () { console.error(this.error) }, watch: { error(newErr) { if(newErr) { console.error(newErr) } } }, &lt;% } %&gt; computed: { statusCode () { return (this.error &amp;&amp; this.error.statusCode) || 500 }, message () { return this.error.message || &#39;&lt;%= messages.client_error %&gt;&#39; } } } &lt;/script&gt; &lt;style&gt; .__nuxt-error-page { padding: 1rem; background: #F7F8FB; color: #47494E; text-align: center; display: flex; justify-content: center; align-items: center; flex-direction: column; font-family: sans-serif; font-weight: 100 !important; -ms-text-size-adjust: 100%; -webkit-text-size-adjust: 100%; -webkit-font-smoothing: antialiased; position: absolute; top: 0; left: 0; right: 0; bottom: 0; } .__nuxt-error-page .error { max-width: 450px; } .__nuxt-error-page .title { font-size: 1.5rem; margin-top: 15px; color: #47494E; margin-bottom: 8px; } .__nuxt-error-page .description { color: #7F828B; line-height: 21px; margin-bottom: 10px; } .__nuxt-error-page a { color: #7F828B !important; text-decoration: none; } .__nuxt-error-page .logo { position: fixed; left: 12px; bottom: 12px; } &lt;/style&gt; 自定义错误页面的示例layouts/error.vue： &lt;template&gt; &lt;div class=&quot;container&quot;&gt; &lt;h1 v-if=&quot;error.statusCode === 404&quot;&gt;Page not found&lt;/h1&gt; &lt;h1 v-else&gt;An error occurred&lt;/h1&gt; &lt;nuxt-link to=&quot;/&quot;&gt;Home page&lt;/nuxt-link&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { props: [&#39;error&#39;], layout: &#39;blog&#39; // you can set a custom layout for the error page } &lt;/script&gt; 自定义布局 目录中的每个文件（第一级）layouts都将创建一个可通过layout页面组件中的属性访问的自定义布局。 确保在创建布局以显示页面组件时添加组件。 例子layouts/blog.vue： &lt;template&gt; &lt;div&gt; &lt;div&gt;My blog navigation bar here&lt;/div&gt; &lt;nuxt/&gt; &lt;/div&gt; &lt;/template&gt; 然后pages/posts.vue，你可以告诉Nuxt.js使用你的自定义布局： &lt;script&gt; export default { layout: &#39;blog&#39; } &lt;/script&gt; 布局属性 布局目录中的每个文件（第一层）都将创建一个可通过页面组件中的布局属性访问的自定义布局。 类型： String或者Function（默认：’default’） 使用layout页面组件中的键来定义要使用的布局： export default { layout: &#39;blog&#39;, // OR layout (context) { return &#39;blog&#39; } } 网页 每个页面组件都是一个Vue组件，但是Nuxt.js添加了特殊键以尽可能简化通用应用程序的开发 &lt;template&gt; &lt;h1 class=&quot;red&quot;&gt;Hello {{ name }}!&lt;/h1&gt; &lt;/template&gt; &lt;script&gt; export default { asyncData (context) { // 每次加载组件之前调用 return { name: &#39;World&#39; } }, fetch () { // 用于在呈现页面之前填充数据中状态管理vuex中数据仓库store。它就像data方法，但它不设置组件数据。请参阅API页面fetch文档 }, head () { // 为当前页面设置特定的标签&lt;meta&gt; }, // and more functionality to discover ... } &lt;/script&gt; &lt;style&gt; .red { color: red; } &lt;/style&gt; 具体的页面方法api 属性 描述 asyncData 最重要的一个键, 支持 异步数据处理，另外该方法的第一个参数为当前页面组件的 上下文对象。 fetch 与 asyncData 方法类似，用于在渲染页面之前获取数据填充应用的状态树（store）。不同的是 fetch 方法不会设置组件的数据。详情请参考 关于fetch方法的文档。 head 配置当前页面的 Meta 标签, 详情参考 页面头部配置API。 layout 指定当前页面使用的布局（layouts 根目录下的布局文件）。详情请参考 关于 布局 的文档。 transition 指定页面切换的过渡动效, 详情请参考 页面过渡动效。 scrollToTop 布尔值，默认: false。 用于判定渲染页面前是否需要将当前页面滚动至顶部。这个配置用于 嵌套路由的应用场景。 validate 校验方法用于校验 动态路由的参数。 middleware 指定页面的中间件，中间件会在页面渲染之前被调用， 请参考 路由中间件。 异步数据 Nuxt.js 扩展了 Vue.js，增加了一个叫 asyncData 的方法，使得我们可以在设置组件的数据之前能异步获取或处理数据。 asyncData 方法 asyncData方法会在组件（限于页面组件）每次加载之前被调用。它可以在服务端或路由更新之前被调用。 在这个方法被调用的时候，第一个参数被设定为当前页面的上下文对象，你可以利用 asyncData方法来获取数据，Nuxt.js 会将 asyncData 返回的数据融合组件 data 方法返回的数据一并返回给当前组件。 注意：由于asyncData方法是在组件 初始化 前被调用的，所以在方法内是没有办法通过 this 来引用组件的实例对象。 Nuxt.js 提供了几种不同的方法来使用 asyncData 方法，你可以选择自己熟悉的一种来用： 1.返回一个 Promise, nuxt.js会等待该Promise被解析之后才会设置组件的数据，从而渲染组件.2.使用 async 或 await3.为第二个参数指定一个回调函数. 注：该回调函数需符合通用的 NodeJs 回调函数的形式: callback(err, data) 返回 Promise export default { asyncData ({ params }) { return axios.get(`https://my-api/posts/${params.id}`) .then((res) =&gt; { return { title: res.data.title } }) } } 使用 async或await export default { async asyncData ({ params }) { let { data } = await axios.get(`https://my-api/posts/${params.id}`) return { title: data.title } } } 使用 回调函数 export default { asyncData ({ params }, callback) { axios.get(`https://my-api/posts/${params.id}`) .then((res) =&gt; { callback(null, { title: res.data.title }) }) } } 返回 对象 如果组件的数据不需要异步获取或处理，可以直接返回指定的字面对象作为组件的数据 export default { data () { return { foo: &#39;bar&#39; } } } 错误处理 Nuxt.js 在上下文对象context中提供了一个 error(params) 方法，你可以通过调用该方法来显示错误信息页面。params.statusCode 可用于指定服务端返回的请求状态码。 export default { asyncData ({ params, error }) { return axios.get(`https://my-api/posts/${params.id}`) .then((res) =&gt; { return { title: res.data.title } }) .catch((e) =&gt; { error({ statusCode: 404, message: &#39;Post not found&#39; }) }) } } 如果你使用 回调函数 的方式, 你可以将错误的信息对象直接传给该回调函数， Nuxt.js 内部会自动调用 error 方法： export default { asyncData ({ params }, callback) { axios.get(`https://my-api/posts/${params.id}`) .then((res) =&gt; { callback(null, { title: res.data.title }) }) .catch((e) =&gt; { callback({ statusCode: 404, message: &#39;Post not found&#39; }) }) } } 插件 Nuxt.js允许您在实例化根vue.js应用程序之前定义要运行的JavaScript插件。这在使用自己的库或外部模块时特别有用。 注意 知道在任何Vue 实例生命周期中.仅从客户端和服务器端调用钩子beforeCreate和created钩子是非常重要的。所有其他的钩子只能从客户端调用。 使用第三方模块 我们可以在应用中使用第三方模块，一个典型的例子是在客户端和服务端使用 axios 做 HTTP 请求。 首先我们需要安装 npm 包： npm install --save axios 然后在页面内可以这样使用： &lt;template&gt; &lt;h1&gt;{{ title }}&lt;/h1&gt; &lt;/template&gt; &lt;script&gt; import axios from &#39;axios&#39; export default { async asyncData ({ params }) { let { data } = await axios.get(`https://my-api/posts/${params.id}`) return { title: data.title } } } &lt;/script&gt; 有一个值得注意的问题是，如果我们在另外一个页面内也引用了 axios，那么在应用打包发布的时候 axios 会被打包两次，而实际上我们只需要打包一次。这个问题可以通过在 nuxt.config.js 里面配置 build.vendor 来解决： module.exports = { build: { vendor: [&#39;axios&#39;] } } 经过上面的配置后，我们可以在任何页面里面引入 axios 而不用担心它会被重复打包。 使用 Vue 插件 假如我们想使用 vue-notifications 显示应用的通知信息，我们需要在程序运行前配置好这个插件。 首先增加文件 plugins/vue-notifications.js： import Vue from &#39;vue&#39; import VueNotifications from &#39;vue-notifications&#39; Vue.use(VueNotifications) 然后, 在 nuxt.config.js 内配置 plugins 如下： module.exports = { plugins: [&#39;~/plugins/vue-notifications&#39;] } 实际上， vue-notifications 会被打包至应用的脚本代码里， 但是它属于第三方库，我们理应将它打包至库文件里以获得更好的缓存效果。（译者注：应用代码比库文件修改频繁，应尽量将第三方库打包至单独的文件中去）。 我们可以更新 nuxt.config.js 文件，在 vendor 构建配置项里添加 vue-notifications： module.exports = { build: { vendor: [&#39;~/plugins/vue-notifications&#39;] }, plugins: [&#39;~/plugins/vue-notifications&#39;] } 只在浏览器里使用的插件 有些插件可能只是在浏览器里使用，所以你可以用 ssr: false 变量来配置插件只从客户端还是服务端运行。 举个例子： nuxt.config.js: module.exports = { plugins: [ { src: &#39;~/plugins/vue-notifications&#39;, ssr: false } ] } plugins/vue-notifications.js: import Vue from &#39;vue&#39; import VueNotifications from &#39;vue-notifications&#39; Vue.use(VueNotifications) 同样地，如果有些脚本库你只想在服务端使用，在 Webpack 打包 server.bundle.js 文件的时候会将 process.server 变量设置成 true。 Vuex 状态树 对于每个大项目来说，使用状态树 (store) 管理状态 (state) 十分有必要。这就是为什么 Nuxt.js 内核实现了 Vuex。 使用状态树 Nuxt.js 会尝试找到应用根目录下的 store 目录，如果该目录存在，它将做以下的事情： 1.引用 vuex 模块2.将 vuex 模块 加到 vendors 构建配置中去3.设置 Vue 根实例的 store 配置项4.Nuxt.js 支持两种使用 store 的方式，你可以择一使用： 普通方式： store/index.js 返回一个 Vuex.Store 实例 模块方式： store 目录下的每个 .js 文件会被转换成为状态树指定命名的子模块 （当然，index 是根模块） 普通方式 使用普通方式的状态树，需要添加 store/index.js 文件，并对外暴露一个 Vuex.Store 实例： import Vue from &#39;vue&#39; import Vuex from &#39;vuex&#39; Vue.use(Vuex) const store = () =&gt; new Vuex.Store({ state: { counter: 0 }, mutations: { increment (state) { state.counter++ } } }) export default store Nuxt.js 内置引用了 vuex 模块，所以不需要额外安装。 现在我们可以在组件里面通过 this.$store 来使用状态树： &lt;template&gt; &lt;button @click=&quot;$store.commit(&#39;increment&#39;)&quot;&gt;{{ $store.state.counter }}&lt;/button&gt; &lt;/template&gt; 模块方式 状态树还可以拆分成为模块，store 目录下的每个 .js 文件会被转换成为状态树指定命名的子模块 使用状态树模块化的方式，store/index.js 不需要返回 Vuex.Store 实例，而应该直接将 state、mutations 和 actions 暴露出来： export const state = () =&gt; ({ counter: 0 }) export const mutations = { increment (state) { state.counter++ } } 其他的模块文件也需要采用类似的方式，如 store/todos.js 文件： export const state = () =&gt; ({ list: [] }) export const mutations = { add (state, text) { state.list.push({ text: text, done: false }) }, remove (state, { todo }) { state.list.splice(state.list.indexOf(todo), 1) }, toggle (state, todo) { todo.done = !todo.done } } 最终的状态树大概如下： new Vuex.Store({ state: { counter: 0 }, mutations: { increment (state) { state.counter++ } }, modules: { todos: { state: { list: [] }, mutations: { add (state, { text }) { state.list.push({ text, done: false }) }, remove (state, { todo }) { state.list.splice(state.list.indexOf(todo), 1) }, toggle (state, { todo }) { todo.done = !todo.done } } } } }) 在页面组件 pages/todos.vue， 可以像下面这样使用 todos 模块： &lt;template&gt; &lt;ul&gt; &lt;li v-for=&quot;todo in todos&quot;&gt; &lt;input type=&quot;checkbox&quot; :checked=&quot;todo.done&quot; @change=&quot;toggle(todo)&quot;&gt; &lt;span :class=&quot;{ done: todo.done }&quot;&gt;{{ todo.text }}&lt;/span&gt; &lt;/li&gt; &lt;li&gt;&lt;input placeholder=&quot;What needs to be done?&quot; @keyup.enter=&quot;addTodo&quot;&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/template&gt; &lt;script&gt; import { mapMutations } from &#39;vuex&#39; export default { computed: { todos () { return this.$store.state.todos.list } }, methods: { addTodo (e) { this.$store.commit(&#39;todos/add&#39;, e.target.value) e.target.value = &#39;&#39; }, ...mapMutations({ toggle: &#39;todos/toggle&#39; }) } } &lt;/script&gt; &lt;style&gt; .done { text-decoration: line-through; } &lt;/style&gt; 你也可以在模块文件里返回Vuex.Store实例,但是这种情况下你需要手工设置应用的状态树 fetch方法 fetch方法会在渲染页面前被调用，作用是填充状态树 (store) 数据，与 asyncData 方法类似，不同的是它不会设置组件的数据。 nuxtServerInit方法 如果在状态树中指定了 nuxtServerInit 方法，Nuxt.js 调用它的时候会将页面的上下文对象作为第2个参数传给它（服务端调用时才会酱紫哟）。当我们想将服务端的一些数据传到客户端时，这个方法是非常好用的。 举个例子，假设我们服务端的会话状态树里可以通过req.session.user 来访问当前登录的用户。将该登录用户信息传给客户端的状态树，我们只需更新 store/index.js 如下 actions: { nuxtServerInit ({ commit }, { req }) { if (req.session.user) { commit(&#39;user&#39;, req.session.user) } } } 如果你使用状态树模块化的模式，只有主模块（即 store/index.js）适用设置该方法（其他模块设置了也不会被调用）。 nuxtServerInit 方法接收的上下文对象和 fetch 的一样，但不包括 context.redirect() 和 context.error()。 命令列表 命令 描述 nuxt 启动一个热加载的Web服务器（开发模式） localhost:3000。 nuxt build 利用webpack编译应用，压缩JS和CSS资源（发布用）。 nuxt start 以生成模式启动一个Web服务器 (nuxt build 会先被执行)。 nuxt generate 编译应用，并依据路由配置生成对应的HTML文件 (用于静态站点的部署) 你可以将这些命令添加至 package.json： &quot;scripts&quot;: { &quot;dev&quot;: &quot;nuxt&quot;, &quot;build&quot;: &quot;nuxt build&quot;, &quot;start&quot;: &quot;nuxt start&quot;, &quot;generate&quot;: &quot;nuxt generate&quot; } 这样你可以通过 npm run 来执行相应的命令。如: npm run dev。 发布部署 Nuxt.js 提供了两种发布部署应用的方式：服务端渲染应用部署 和 静态应用部署 服务端渲染应用部署 部署 Nuxt.js 服务端渲染的应用不能直接使用 nuxt 命令，而应该先进行编译构建，然后再启动 Nuxt 服务，可通过以下两个命令来完成： nuxt build nuxt start 推荐的 package.json 配置如下： { &quot;name&quot;: &quot;my-app&quot;, &quot;dependencies&quot;: { &quot;nuxt&quot;: &quot;latest&quot; }, &quot;scripts&quot;: { &quot;dev&quot;: &quot;nuxt&quot;, &quot;build&quot;: &quot;nuxt build&quot;, &quot;start&quot;: &quot;nuxt start&quot; } } 静态应用部署 Nuxt.js 可依据路由配置将应用静态化，使得我们可以将应用部署至任何一个静态站点主机服务商。 可利用下面的命令生成应用的静态目录和文件： npm run generate 这个命令会创建一个 dist 文件夹，所有静态化后的资源文件均在其中。 如果你的项目需要用到动态路由，请移步 generate配置API 了解如何让 Nuxt.js 生成此类动态路由的静态文件。 注意：使用 nuxt generate 静态化应用的时候, 传给 asyncData() 和 fetch() 方法的上下文对象 不会包含 req 和 res 两个属性。 API学习应用1.asyncData 方法 你可能想要在服务器端获取并渲染数据。Nuxt.js添加了asyncData方法使得你能够在渲染组件之前异步获取数据。类型： FunctionasyncData方法会在组件（限于页面组件）每次加载之前被调用。它可以在服务端或路由更新之前被调用。在这个方法被调用的时候，第一个参数被设定为当前页面的上下文对象，你可以利用 asyncData方法来获取数据并返回给当前组件 export default { data () { return { project: &#39;default&#39; } }, asyncData (context) { return { project: &#39;nuxt&#39; } } } 注意：由于asyncData方法是在组件 初始化 前被调用的，所以在方法内是没有办法通过 this 来引用组件的实例对象。 上下文对象 context 变量的可用属性一览： 属性字段 类型 可用 描述 app 根Vue实例 客户端服务器 包含所有插件的根Vue实例。例如，使用时axios，您可以访问$axios通过context.app.$axios。 isClient Boolean 客户端 &amp; 服务端 是否来自客户端渲染 isServer Boolean 客户端 &amp; 服务端 是否来自服务端渲染 isDev Boolean 客户端 &amp; 服务端 是否是开发(dev) 模式，在生产环境的数据缓存中用到 route vue-router 路由 客户端 &amp; 服务端 vue-router 路由实例。 store vuex 数据流 客户端 &amp; 服务端 Vuex.Store 实例。只有vuex 数据流存在相关配置时可用。 env Object 客户端 &amp; 服务端 nuxt.config.js 中配置的环境变量, 见 环境变量 api params Object 客户端 &amp; 服务端 route.params 的别名 query Object 客户端 &amp; 服务端 route.query 的别名 req http.Request 服务端 Node.js API 的 Request 对象。如果 nuxt 以中间件形式使用的话，这个对象就根据你所使用的框架而定。nuxt generate 不可用。 res http.Response 服务端 Node.js API 的 Response 对象。如果 nuxt 以中间件形式使用的话，这个对象就根据你所使用的框架而定。nuxt generate 不可用。 redirect Function 客户端 &amp; 服务端 用这个方法重定向用户请求到另一个路由。状态码在服务端被使用，默认 302。redirect([status,] path [, query]) error Function 客户端 &amp; 服务端 用这个方法展示错误页：error(params)。params 参数应该包含 statusCode 和 message 字段。 fetch 方法 fetch 方法用于在渲染页面前填充应用的状态树（store）数据， 与 asyncData 方法类似，不同的是它不会设置组件的数据 类型： Function 如果页面组件设置了 fetch 方法，它会在组件每次加载前被调用（在服务端或切换至目标路由之前）。 fetch 方法的第一个参数是页面组件的上下文对象 context，我们可以用 fetch 方法来获取数据填充应用的状态树。为了让获取过程可以异步，你需要返回一个 Promise，Nuxt.js 会等这个 promise 完成后再渲染组件。 例如 pages/index.vue： &lt;template&gt; &lt;h1&gt;Stars: {{ $store.state.stars }}&lt;/h1&gt; &lt;/template&gt; &lt;script&gt; export default { fetch ({ store, params }) { return axios.get(&#39;http://my-api/stars&#39;) .then((res) =&gt; { store.commit(&#39;setStars&#39;, res.data) }) } } &lt;/script&gt; 你也可以使用 async 或 await 的模式简化代码如下： &lt;template&gt; &lt;h1&gt;Stars: {{ $store.state.stars }}&lt;/h1&gt; &lt;/template&gt; &lt;script&gt; export default { async fetch ({ store, params }) { let { data } = await axios.get(&#39;http://my-api/stars&#39;) store.commit(&#39;setStars&#39;, data) } } &lt;/script&gt; head 方法 Nuxt.js 使用了 vue-meta 更新应用的 头部标签(Head) 和 html 属性 类型： Object 或 Function 使用 head 方法设置当前页面的头部标签。 在 head 方法里可通过 this 关键字来获取组件的数据，你可以利用页面组件的数据来设置个性化的 meta 标签 &lt;template&gt; &lt;h1&gt;{{ title }}&lt;/h1&gt; &lt;/template&gt; &lt;script&gt; export default { data () { return { title: &#39;Hello World!&#39; } }, head () { return { title: this.title, meta: [ { hid: &#39;description&#39;, name: &#39;description&#39;, content: &#39;My custom description&#39; } ] } } } &lt;/script&gt; 注意：为了避免子组件中的meta标签不能正确覆盖父组件中相同的标签而产生重复的现象，建议利用 hid 键为meta标签配一个唯一的标识编号。请阅读关于 vue-meta 的更多信息 layout 属性 layouts 根目录下的所有文件都属于个性化布局文件，可以在页面组件中利用 layout 属性来引用。 类型： String 或 Function (默认值： ‘default’) 使用 layout 属性来为页面指定使用哪一个布局文件：在上面的例子中,Nuxt.js 会使用 layouts/blog.vue 作为当前页面组件的布局文件。 export default { layout: &#39;blog&#39;, // 或 layout (context) { return &#39;blog&#39; } } middleware 属性 中间件属性 类型：String或Array项目： String为应用程序的特定页面设置中间件。 例：pages/secret.vue： &lt;template&gt; &lt;h1&gt;Secret page&lt;/h1&gt; &lt;/template&gt; &lt;script&gt; export default { middleware: &#39;authenticated&#39; } &lt;/script&gt; middleware/authenticated.js： export default function ({ store, redirect }) { // If the user is not authenticated if (!store.state.authenticated) { return redirect(&#39;/login&#39;) } } scrollToTop属性 使用scrollToTop属性可以告诉nuxt.js在呈现页面之前滚动到顶部。 类型： Boolean（默认：false） 默认情况下，当你转到另一个页面时，Nuxt.js会滚动到顶部，但是对于子路径，Nuxt.js将保持滚动位置。如果你想告诉Nuxt.js在渲染子路径时滚动到顶部，请设置scrollToTop: true： &lt;template&gt; &lt;h1&gt;My child component&lt;/h1&gt; &lt;/template&gt; &lt;script&gt; export default { scrollToTop: true } &lt;/script&gt; transition 属性 Nuxt.js 使用 Vue.js 的组件来实现路由切换时的过渡动效。 类型： String 或 Object 或 Function 如果想给某个页面自定义过渡特效的话，只要在该页面组件中配置 transition 字段即可： export default { // 可以是字符 transition: &#39;&#39; // 或对象 transition: {} // 或函数 transition (to, from) {} } String 字符 如果 transition 属性的值类型是字符类型， 相当于设置了动效配置对象的 name 属性：transition.name。 export default { transition: &#39;test&#39; } Nuxt.js 将使用上面的配置来设置 Vue.js transition 组件，如下： &lt;transition name=&quot;test&quot;&gt; Object对象 如果 transition 属性的值类型是对象类型： export default { transition: { name: &#39;test&#39;, mode: &#39;out-in&#39; } } Nuxt.js 将使用上面的配置来设置 Vue.js transition 组件，如下： &lt;transition name=&quot;test&quot; mode=&quot;out-in&quot;&gt; transition 允许配置的字段介绍： 属性字段 类型 默认值 描述 name String “page” 所有路由过渡都会用到的过渡名称。 mode String “out-in” 所有路由都用到的过渡模式，见 Vue.js transition 使用文档。 css Boolean true 是否给页面组件根元素添加 CSS 过渡类名。如果值为false，路由过渡时将触发页面组件事件注册的 Javascript 钩子方法。 type String n/a 指定过滤动效事件的类型，用于判断过渡结束的时间点。值可以是 “transition” 或 “animation”。 默认情况下, Nuxt.js 会自动侦测动效事件的类型。 enterClass String n/a 目标路由动效开始时的类名。 详情请参考 Vue.js transition 使用文档 。 enterToClass String n/a 目标路由动效结束时的类名。 详情请参考 Vue.js transition 使用文档 。 enterActiveClass String n/a 目标路由过渡过程中的类名。详情请参考 Vue.js transition 使用文档 leaveClass String n/a 当前路由动效开始时的类名。 详情请参考 Vue.js transition 使用文档 。 leaveToClass String n/a 当前路由动效结束时的类名。 详情请参考 Vue.js transition 使用文档 。 leaveActiveClass String n/a 当前路由动效过程中的类名。详情请参考 Vue.js transition 使用文档 validate 方法 Nuxt.js 可以让你在动态路由对应的页面组件中配置一个校验方法用于校验动态路由参数的有效性。 类型： Function validate({ params, query }) { return true // 如果参数有效 return false // 参数无效，Nuxt.js 停止渲染当前页面并显示错误页面 } Nuxt.js 可以让你在动态路由对应的页面组件（本例为： pages/users/_id.vue）中配置一个校验方法 如果校验方法返回的值不为 true， Nuxt.js 将自动加载显示 404 错误页面 export default { validate ({ params }) { // Must be a number return /^\\d+$/.test(params.id) } } 你也可以在validate 方法中校验 store 的数据 (如果 store 此前在 nuxtServerInit 方法 中被设置了的话): 你也可以在validate 方法中校验 store 的数据 (如果 store 此前在 nuxtServerInit 方法 中被设置了的话): export default { validate ({ params, store }) { // 校验 `params.id` 是否存在 return store.state.categories.some((category) =&gt; category.id === params.id) } }","content":"<ul>\n<li>初学者模板或使用vue-cli安装它：</li>\n</ul>\n<pre><code>vue init nuxt/starter project-name\n</code></pre><ul>\n<li><p>如果vue-cli没有安装，请安装npm install -g vue-cli</p>\n</li>\n<li><p>然后安装依赖关系：</p>\n</li>\n</ul>\n<pre><code>$ cd &lt;project-name&gt;\n$ npm install 或者用 yarn install\n</code></pre><ul>\n<li>并通过以下方式启动项目</li>\n</ul>\n<pre><code>npm run dev\n</code></pre><ul>\n<li><p>该应用程序现在在http：// localhost：3000上运行</p>\n</li>\n<li><p>Nuxt.js将监听pages目录中的文件更改，因此在添加新页面时不需要重新启动应用程序。</p>\n</li>\n<li><p>目录结构介绍</p>\n<h3 id=\"资产目录\"><a href=\"#资产目录\" class=\"headerlink\" title=\"资产目录\"></a>资产目录</h3><ul>\n<li><p>该assets目录包含您未编译的资产，如Less，Sass或JavaScript</p>\n</li>\n<li><p>默认情况下，vue-loader会使用css-loader和Vue模板编译器自动处理样式和模板文件。在此编译过程中，所有资产的URL，例如<img src=\"...\">，background: url(…)和CSS @import的解析为模块依赖关系。 </p>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>如有下目录结构：</li>\n</ul>\n<pre><code>-| assets/\n----| image.png\n-| pages/\n----| index.vue\n</code></pre><ul>\n<li><p>你的CSS中，如果你使用url(‘~/assets/image.png’)，它会被翻译成require(‘~/assets/image.png’)。</p>\n</li>\n<li><p>或者如果在pages/index.vue你使用</p>\n</li>\n</ul>\n<pre><code>&lt;template&gt;\n  &lt;img src=&quot;~/assets/image.png&quot;&gt;\n&lt;/template&gt;\n</code></pre><h3 id=\"静态的\"><a href=\"#静态的\" class=\"headerlink\" title=\"静态的\"></a>静态的</h3><ul>\n<li><p>如果您不想使用该assets目录中的webpacked Assets，则可以static在项目根目录中创建并使用该目录。</p>\n</li>\n<li><p>这些文件将由Nuxt自动提供，并可在您的项目根URL中访问。</p>\n</li>\n<li><p>此选项对于像文件有帮助robots.txt，sitemap.xml或CNAME（像GitHub的页面）。</p>\n</li>\n<li><p>从您的代码中，您可以使用/URL 来引用这些文件：</p>\n</li>\n</ul>\n<pre><code>&lt;!-- 这是来自Static目录中图片使用方法 image from static directory --&gt;\n&lt;img src=&quot;/my-image.png&quot;/&gt;\n\n&lt;!-- 这是来自assets目录中图片使用方法 webpacked image from assets directory --&gt;\n&lt;img src=&quot;~/assets/my-image-2.png&quot;/&gt;\n</code></pre><h3 id=\"组件目录\"><a href=\"#组件目录\" class=\"headerlink\" title=\"组件目录\"></a>组件目录</h3><ul>\n<li>该components目录包含您的Vue.js组件。Nuxt.js不会增加这些组件的数据方法</li>\n</ul>\n<h3 id=\"布局目录\"><a href=\"#布局目录\" class=\"headerlink\" title=\"布局目录\"></a>布局目录</h3><ul>\n<li>该layouts目录包含您的应用程序布局。该目录不能被重命名。视图部分描述了在Nuxt.js应用程序（文档，布局，页面和HTML头）中为特定路线配置数据和视图所需的全部内容。</li>\n</ul>\n<p><img src=\"https://nuxtjs.org/nuxt-views-schema.png\" alt=\"图片\"></p>\n<h3 id=\"文件\"><a href=\"#文件\" class=\"headerlink\" title=\"文件\"></a>文件</h3><ul>\n<li>要扩展HTML模板，请app.html在项目的根目录下创建。默认模板是：</li>\n</ul>\n<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html {{ HTML_ATTRS }}&gt;\n  &lt;head&gt;\n    {{ HEAD }}\n  &lt;/head&gt;\n  &lt;body {{ BODY_ATTRS }}&gt;\n    {{ APP }}\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre><ul>\n<li>一个例子是为IE添加条件CSS类html模板：</li>\n</ul>\n<pre><code>&lt;!DOCTYPE html&gt;\n&lt;!--[if IE 9]&gt;&lt;html lang=&quot;en-US&quot; class=&quot;lt-ie9 ie9&quot; {{ HTML_ATTRS }}&gt;&lt;![endif]--&gt;\n&lt;!--[if (gt IE 9)|!(IE)]&gt;&lt;!--&gt;&lt;html {{ HTML_ATTRS }}&gt;&lt;!--&lt;![endif]--&gt;\n  &lt;head&gt;\n    {{ HEAD }}\n  &lt;/head&gt;\n  &lt;body {{ BODY_ATTRS }}&gt;\n    {{ APP }}\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre><h3 id=\"布局\"><a href=\"#布局\" class=\"headerlink\" title=\"布局\"></a>布局</h3><ul>\n<li>Nuxt.js允许您扩展主布局或通过在layouts目录中添加它们来创建自定义布局。</li>\n</ul>\n<h3 id=\"默认布局\"><a href=\"#默认布局\" class=\"headerlink\" title=\"默认布局\"></a>默认布局</h3><ul>\n<li><p>您可以通过添加layouts/default.vue文件来扩展主布局。</p>\n</li>\n<li><p>确保<nuxt/>在创建布局以显示页面组件时添加组件。</p>\n</li>\n<li><p>默认的布局源代码是：</p>\n</li>\n</ul>\n<pre><code>&lt;template&gt;\n  &lt;nuxt/&gt;\n&lt;/template&gt;\n</code></pre><h3 id=\"错误页面\"><a href=\"#错误页面\" class=\"headerlink\" title=\"错误页面\"></a>错误页面</h3><ul>\n<li><p>您可以通过添加layouts/error.vue文件来自定义错误页面。</p>\n</li>\n<li><p>这种布局是特殊的，因为你应该不包括<nuxt/>它的模板中。必须看到这布局发生错误时（一个组件显示404，500等）。</p>\n</li>\n<li><p>GitHub上提供了默认的错误页面源代码。</p>\n</li>\n</ul>\n<pre><code>&lt;template&gt;\n&lt;div class=&quot;__nuxt-error-page&quot;&gt;\n&lt;div class=&quot;error&quot;&gt;\n  &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;90&quot; height=&quot;90&quot; fill=&quot;#DBE1EC&quot; viewBox=&quot;0 0 48 48&quot;&gt;&lt;path d=&quot;M22 30h4v4h-4zm0-16h4v12h-4zm1.99-10C12.94 4 4 12.95 4 24s8.94 20 19.99 20S44 35.05 44 24 35.04 4 23.99 4zM24 40c-8.84 0-16-7.16-16-16S15.16 8 24 8s16 7.16 16 16-7.16 16-16 16z&quot;/&gt;&lt;/svg&gt;\n\n  &lt;div class=&quot;title&quot;&gt;{{ message }}&lt;/div&gt;\n  &lt;p class=&quot;description&quot; v-if=&quot;statusCode === 404&quot;&gt;\n    &lt;nuxt-link class=&quot;error-link&quot; to=&quot;/&quot;&gt;&lt;%= messages.back_to_home %&gt;&lt;/nuxt-link&gt;\n  &lt;/p&gt;\n  &lt;% if(debug) { %&gt;\n  &lt;p class=&quot;description&quot; v-else&gt;&lt;%= messages.client_error_details %&gt;&lt;/p&gt;\n  &lt;% } %&gt;\n\n  &lt;div class=&quot;logo&quot;&gt;\n    &lt;a href=&quot;https://nuxtjs.org&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;%= messages.nuxtjs %&gt;&lt;/a&gt;\n  &lt;/div&gt;\n&lt;/div&gt;\n&lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nexport default {\n  name: &#39;nuxt-error&#39;,\n  props: [&#39;error&#39;],\n  head () {\n    return {\n      title: this.message,\n      meta: [\n        {\n          name: &#39;viewport&#39;,\n          content: &#39;width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no&#39;\n        }\n      ]\n    }\n  },\n  &lt;% if(debug) { %&gt;\n  // Only on debug mode\n  data () {\n    return {\n      mounted: false\n    }\n  },\n  mounted () {\n    this.mounted = true\n  },\n  created () {\n    console.error(this.error)\n  },\n  watch: {\n    error(newErr) {\n      if(newErr) {\n        console.error(newErr)\n      }\n    }\n  },\n  &lt;% } %&gt;\n  computed: {\n    statusCode () {\n      return (this.error &amp;&amp; this.error.statusCode) || 500\n    },\n    message () {\n      return this.error.message || &#39;&lt;%= messages.client_error %&gt;&#39;\n    }\n  }\n}\n&lt;/script&gt;\n\n&lt;style&gt;\n.__nuxt-error-page {\n  padding: 1rem;\n  background: #F7F8FB;\n  color: #47494E;\n  text-align: center;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  flex-direction: column;\n  font-family: sans-serif;\n  font-weight: 100 !important;\n  -ms-text-size-adjust: 100%;\n  -webkit-text-size-adjust: 100%;\n  -webkit-font-smoothing: antialiased; \n  position: absolute;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n}\n.__nuxt-error-page .error {\n  max-width: 450px;\n}\n.__nuxt-error-page .title {\n  font-size: 1.5rem;\n  margin-top: 15px;\n  color: #47494E;\n  margin-bottom: 8px; \n}\n.__nuxt-error-page .description {\n  color: #7F828B;\n  line-height: 21px;\n  margin-bottom: 10px;\n}\n.__nuxt-error-page a {\n  color: #7F828B !important;\n  text-decoration: none;\n}\n.__nuxt-error-page .logo {\n  position: fixed;\n  left: 12px;\n  bottom: 12px;\n}\n&lt;/style&gt;\n</code></pre><ul>\n<li>自定义错误页面的示例layouts/error.vue：</li>\n</ul>\n<pre><code>&lt;template&gt;\n  &lt;div class=&quot;container&quot;&gt;\n    &lt;h1 v-if=&quot;error.statusCode === 404&quot;&gt;Page not found&lt;/h1&gt;\n    &lt;h1 v-else&gt;An error occurred&lt;/h1&gt;\n    &lt;nuxt-link to=&quot;/&quot;&gt;Home page&lt;/nuxt-link&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nexport default {\n  props: [&#39;error&#39;],\n  layout: &#39;blog&#39; // you can set a custom layout for the error page\n}\n&lt;/script&gt;\n</code></pre><h3 id=\"自定义布局\"><a href=\"#自定义布局\" class=\"headerlink\" title=\"自定义布局\"></a>自定义布局</h3><ul>\n<li><p>目录中的每个文件（第一级）layouts都将创建一个可通过layout页面组件中的属性访问的自定义布局。</p>\n</li>\n<li><p>确保<nuxt/>在创建布局以显示页面组件时添加组件。</p>\n</li>\n<li><p>例子layouts/blog.vue：</p>\n</li>\n</ul>\n<pre><code>&lt;template&gt;\n  &lt;div&gt;\n    &lt;div&gt;My blog navigation bar here&lt;/div&gt;\n    &lt;nuxt/&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n</code></pre><ul>\n<li>然后pages/posts.vue，你可以告诉Nuxt.js使用你的自定义布局：</li>\n</ul>\n<pre><code>&lt;script&gt;\nexport default {\n  layout: &#39;blog&#39;\n}\n&lt;/script&gt;\n</code></pre><h3 id=\"布局属性\"><a href=\"#布局属性\" class=\"headerlink\" title=\"布局属性\"></a>布局属性</h3><ul>\n<li>布局目录中的每个文件（第一层）都将创建一个可通过页面组件中的布局属性访问的自定义布局。</li>\n<li>类型： String或者Function（默认：’default’）</li>\n<li>使用layout页面组件中的键来定义要使用的布局：</li>\n</ul>\n<pre><code>export default {\n  layout: &#39;blog&#39;,\n  // OR\n  layout (context) {\n    return &#39;blog&#39;\n  }\n}\n</code></pre><h3 id=\"网页\"><a href=\"#网页\" class=\"headerlink\" title=\"网页\"></a>网页</h3><ul>\n<li>每个页面组件都是一个Vue组件，但是Nuxt.js添加了特殊键以尽可能简化通用应用程序的开发</li>\n</ul>\n<pre><code>&lt;template&gt;\n  &lt;h1 class=&quot;red&quot;&gt;Hello {{ name }}!&lt;/h1&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nexport default {\n  asyncData (context) {\n    // 每次加载组件之前调用\n    return { name: &#39;World&#39; }\n  },\n  fetch () {\n    // 用于在呈现页面之前填充数据中状态管理vuex中数据仓库store。它就像data方法，但它不设置组件数据。请参阅API页面fetch文档\n  },\n  head () {\n    // 为当前页面设置特定的标签&lt;meta&gt;\n  },\n  // and more functionality to discover\n  ...\n}\n&lt;/script&gt;\n\n&lt;style&gt;\n.red {\n  color: red;\n}\n&lt;/style&gt;\n</code></pre><h3 id=\"具体的页面方法api\"><a href=\"#具体的页面方法api\" class=\"headerlink\" title=\"具体的页面方法api\"></a>具体的页面方法api</h3><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">属性</th>\n<th style=\"text-align:center\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">asyncData</td>\n<td style=\"text-align:center\">最重要的一个键, 支持 异步数据处理，另外该方法的第一个参数为当前页面组件的 上下文对象。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">fetch</td>\n<td style=\"text-align:center\">与 asyncData 方法类似，用于在渲染页面之前获取数据填充应用的状态树（store）。不同的是 fetch 方法不会设置组件的数据。详情请参考 关于fetch方法的文档。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">head</td>\n<td style=\"text-align:center\">配置当前页面的 Meta 标签, 详情参考 页面头部配置API。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">layout</td>\n<td style=\"text-align:center\">指定当前页面使用的布局（layouts 根目录下的布局文件）。详情请参考 关于 布局 的文档。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">transition</td>\n<td style=\"text-align:center\">指定页面切换的过渡动效, 详情请参考 页面过渡动效。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">scrollToTop</td>\n<td style=\"text-align:center\">布尔值，默认: false。 用于判定渲染页面前是否需要将当前页面滚动至顶部。这个配置用于 嵌套路由的应用场景。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">validate</td>\n<td style=\"text-align:center\">校验方法用于校验 动态路由的参数。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">middleware</td>\n<td style=\"text-align:center\">指定页面的中间件，中间件会在页面渲染之前被调用， 请参考 路由中间件。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"异步数据\"><a href=\"#异步数据\" class=\"headerlink\" title=\"异步数据\"></a>异步数据</h3><ul>\n<li><p>Nuxt.js 扩展了 Vue.js，增加了一个叫 asyncData 的方法，使得我们可以在设置组件的数据之前能异步获取或处理数据。</p>\n</li>\n<li><p>asyncData 方法</p>\n</li>\n</ul>\n<hr>\n<ul>\n<li>asyncData方法会在组件（限于页面组件）每次加载之前被调用。它可以在服务端或路由更新之前被调用。 在这个方法被调用的时候，第一个参数被设定为当前页面的上下文对象，你可以利用 asyncData方法来获取数据，Nuxt.js 会将 asyncData 返回的数据融合组件 data 方法返回的数据一并返回给当前组件。</li>\n</ul>\n<ul>\n<li><p><p style=\"color:#fff;background-color:red;\">注意：由于asyncData方法是在组件 初始化 前被调用的，所以在方法内是没有办法通过 this 来引用组件的实例对象</p>。</p>\n</li>\n<li><p>Nuxt.js 提供了几种不同的方法来使用 asyncData 方法，你可以选择自己熟悉的一种来用：</p>\n</li>\n</ul>\n<blockquote>\n<p>1.返回一个 Promise, nuxt.js会等待该Promise被解析之后才会设置组件的数据，从而渲染组件.<br>2.使用 async 或 await<br>3.为第二个参数指定一个回调函数. 注：该回调函数需符合通用的 NodeJs 回调函数的形式: callback(err, data)</p>\n</blockquote>\n<ul>\n<li>返回 Promise</li>\n</ul>\n<pre><code>export default {\n  asyncData ({ params }) {\n    return axios.get(`https://my-api/posts/${params.id}`)\n    .then((res) =&gt; {\n      return { title: res.data.title }\n    })\n  }\n}\n</code></pre><ul>\n<li>使用 async或await</li>\n</ul>\n<pre><code>export default {\n  async asyncData ({ params }) {\n    let { data } = await axios.get(`https://my-api/posts/${params.id}`)\n    return { title: data.title }\n  }\n}\n</code></pre><ul>\n<li>使用 回调函数</li>\n</ul>\n<pre><code>export default {\n  asyncData ({ params }, callback) {\n    axios.get(`https://my-api/posts/${params.id}`)\n    .then((res) =&gt; {\n      callback(null, { title: res.data.title })\n    })\n  }\n}\n</code></pre><ul>\n<li>返回 对象</li>\n<li>如果组件的数据不需要异步获取或处理，可以直接返回指定的字面对象作为组件的数据</li>\n</ul>\n<pre><code>export default {\n  data () {\n    return { foo: &#39;bar&#39; }\n  }\n}\n</code></pre><h1 id=\"错误处理\"><a href=\"#错误处理\" class=\"headerlink\" title=\"错误处理\"></a>错误处理</h1><ul>\n<li>Nuxt.js 在上下文对象context中提供了一个 error(params) 方法，你可以通过调用该方法来显示错误信息页面。params.statusCode 可用于指定服务端返回的请求状态码。</li>\n</ul>\n<pre><code>export default {\n  asyncData ({ params, error }) {\n    return axios.get(`https://my-api/posts/${params.id}`)\n    .then((res) =&gt; {\n      return { title: res.data.title }\n    })\n    .catch((e) =&gt; {\n      error({ statusCode: 404, message: &#39;Post not found&#39; })\n    })\n  }\n}\n</code></pre><ul>\n<li>如果你使用 回调函数 的方式, 你可以将错误的信息对象直接传给该回调函数， Nuxt.js 内部会自动调用 error 方法：</li>\n</ul>\n<pre><code>export default {\n  asyncData ({ params }, callback) {\n    axios.get(`https://my-api/posts/${params.id}`)\n    .then((res) =&gt; {\n      callback(null, { title: res.data.title })\n    })\n    .catch((e) =&gt; {\n      callback({ statusCode: 404, message: &#39;Post not found&#39; })\n    })\n  }\n}\n</code></pre><h3 id=\"插件\"><a href=\"#插件\" class=\"headerlink\" title=\"插件\"></a>插件</h3><ul>\n<li>Nuxt.js允许您在实例化根vue.js应用程序之前定义要运行的JavaScript插件。这在使用自己的库或外部模块时特别有用。</li>\n</ul>\n<h3 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h3><blockquote>\n<p>知道在任何Vue 实例生命周期中.<br>仅从客户端和服务器端调用钩子<br>beforeCreate和created钩子是非常重要的。<br>所有其他的钩子只能从客户端调用。</p>\n</blockquote>\n<h3 id=\"使用第三方模块\"><a href=\"#使用第三方模块\" class=\"headerlink\" title=\"使用第三方模块\"></a>使用第三方模块</h3><ul>\n<li><p>我们可以在应用中使用第三方模块，一个典型的例子是在客户端和服务端使用 axios 做 HTTP 请求。</p>\n</li>\n<li><p>首先我们需要安装 npm 包：</p>\n</li>\n</ul>\n<pre><code>npm install --save axios\n</code></pre><ul>\n<li>然后在页面内可以这样使用：</li>\n</ul>\n<pre><code>&lt;template&gt;\n  &lt;h1&gt;{{ title }}&lt;/h1&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nimport axios from &#39;axios&#39;\n\nexport default {\n  async asyncData ({ params }) {\n    let { data } = await axios.get(`https://my-api/posts/${params.id}`)\n    return { title: data.title }\n  }\n}\n&lt;/script&gt;\n</code></pre><ul>\n<li>有一个值得注意的问题是，如果我们在另外一个页面内也引用了 axios，那么在应用打包发布的时候 axios 会被打包两次，而实际上我们只需要打包一次。这个问题可以通过在 nuxt.config.js 里面配置 build.vendor 来解决：</li>\n</ul>\n<pre><code>module.exports = {\n  build: {\n    vendor: [&#39;axios&#39;]\n  }\n}\n</code></pre><ul>\n<li>经过上面的配置后，我们可以在任何页面里面引入 axios 而不用担心它会被重复打包。</li>\n</ul>\n<h3 id=\"使用-Vue-插件\"><a href=\"#使用-Vue-插件\" class=\"headerlink\" title=\"使用 Vue 插件\"></a>使用 Vue 插件</h3><ul>\n<li><p>假如我们想使用 vue-notifications 显示应用的通知信息，我们需要在程序运行前配置好这个插件。</p>\n</li>\n<li><p>首先增加文件 plugins/vue-notifications.js：</p>\n</li>\n</ul>\n<pre><code>import Vue from &#39;vue&#39;\nimport VueNotifications from &#39;vue-notifications&#39;\n\nVue.use(VueNotifications)\n</code></pre><ul>\n<li>然后, 在 nuxt.config.js 内配置 plugins 如下：</li>\n</ul>\n<pre><code>module.exports = {\n  plugins: [&#39;~/plugins/vue-notifications&#39;]\n}\n</code></pre><ul>\n<li><p>实际上， vue-notifications 会被打包至应用的脚本代码里， 但是它属于第三方库，我们理应将它打包至库文件里以获得更好的缓存效果。（译者注：应用代码比库文件修改频繁，应尽量将第三方库打包至单独的文件中去）。</p>\n</li>\n<li><p>我们可以更新 nuxt.config.js 文件，在 vendor 构建配置项里添加 vue-notifications：</p>\n</li>\n</ul>\n<pre><code>module.exports = {\n  build: {\n    vendor: [&#39;~/plugins/vue-notifications&#39;]\n  },\n  plugins: [&#39;~/plugins/vue-notifications&#39;]\n}\n</code></pre><ul>\n<li>只在浏览器里使用的插件</li>\n</ul>\n<hr>\n<ul>\n<li><p>有些插件可能只是在浏览器里使用，所以你可以用 ssr: false 变量来配置插件只从客户端还是服务端运行。</p>\n</li>\n<li><p>举个例子：</p>\n</li>\n<li><p>nuxt.config.js:</p>\n</li>\n</ul>\n<pre><code>module.exports = {\n  plugins: [\n    { src: &#39;~/plugins/vue-notifications&#39;, ssr: false }\n  ]\n}\n</code></pre><ul>\n<li>plugins/vue-notifications.js:</li>\n</ul>\n<pre><code>import Vue from &#39;vue&#39;\nimport VueNotifications from &#39;vue-notifications&#39;\n\nVue.use(VueNotifications)\n</code></pre><ul>\n<li>同样地，如果有些脚本库你只想在服务端使用，在 Webpack 打包 server.bundle.js 文件的时候会将 process.server 变量设置成 true。</li>\n</ul>\n<h3 id=\"Vuex-状态树\"><a href=\"#Vuex-状态树\" class=\"headerlink\" title=\"Vuex 状态树\"></a>Vuex 状态树</h3><ul>\n<li>对于每个大项目来说，使用状态树 (store) 管理状态 (state) 十分有必要。这就是为什么 Nuxt.js 内核实现了 Vuex。</li>\n</ul>\n<h3 id=\"使用状态树\"><a href=\"#使用状态树\" class=\"headerlink\" title=\"使用状态树\"></a>使用状态树</h3><ul>\n<li>Nuxt.js 会尝试找到应用根目录下的 store 目录，如果该目录存在，它将做以下的事情：</li>\n</ul>\n<blockquote>\n<p>1.引用 vuex 模块<br>2.将 vuex 模块 加到 vendors 构建配置中去<br>3.设置 Vue 根实例的 store 配置项<br>4.Nuxt.js 支持两种使用 store 的方式，你可以择一使用：</p>\n</blockquote>\n<p><strong> 普通方式：</strong>  store/index.js 返回一个 Vuex.Store 实例<br><strong> 模块方式：</strong> store 目录下的每个 .js 文件会被转换成为状态树指定命名的子模块 （当然，index 是根模块）</p>\n<h3 id=\"普通方式\"><a href=\"#普通方式\" class=\"headerlink\" title=\"普通方式\"></a>普通方式</h3><ul>\n<li>使用普通方式的状态树，需要添加 store/index.js 文件，并对外暴露一个 Vuex.Store 实例：</li>\n</ul>\n<pre><code>import Vue from &#39;vue&#39;\nimport Vuex from &#39;vuex&#39;\n\nVue.use(Vuex)\n\nconst store = () =&gt; new Vuex.Store({\n\n  state: {\n    counter: 0\n  },\n  mutations: {\n    increment (state) {\n      state.counter++\n    }\n  }\n})\n\nexport default store\n</code></pre><ul>\n<li><p>Nuxt.js 内置引用了 vuex 模块，所以不需要额外安装。</p>\n</li>\n<li><p>现在我们可以在组件里面通过 this.$store 来使用状态树：</p>\n</li>\n</ul>\n<pre><code>&lt;template&gt;\n  &lt;button @click=&quot;$store.commit(&#39;increment&#39;)&quot;&gt;{{ $store.state.counter }}&lt;/button&gt;\n&lt;/template&gt;\n</code></pre><h3 id=\"模块方式\"><a href=\"#模块方式\" class=\"headerlink\" title=\"模块方式\"></a>模块方式</h3><ul>\n<li><p>状态树还可以拆分成为模块，store 目录下的每个 .js 文件会被转换成为状态树指定命名的子模块</p>\n</li>\n<li><p>使用状态树模块化的方式，store/index.js 不需要返回 Vuex.Store 实例，而应该直接将 state、mutations 和 actions 暴露出来：</p>\n</li>\n</ul>\n<pre><code>export const state = () =&gt; ({\n  counter: 0\n})\n\nexport const mutations = {\n  increment (state) {\n    state.counter++\n  }\n}\n</code></pre><ul>\n<li>其他的模块文件也需要采用类似的方式，如 store/todos.js 文件：</li>\n</ul>\n<pre><code>export const state = () =&gt; ({\n  list: []\n})\n\nexport const mutations = {\n  add (state, text) {\n    state.list.push({\n      text: text,\n      done: false\n    })\n  },\n  remove (state, { todo }) {\n    state.list.splice(state.list.indexOf(todo), 1)\n  },\n  toggle (state, todo) {\n    todo.done = !todo.done\n  }\n}\n</code></pre><ul>\n<li>最终的状态树大概如下：</li>\n</ul>\n<pre><code>new Vuex.Store({\n  state: { counter: 0 },\n  mutations: {\n    increment (state) {\n      state.counter++\n    }\n  },\n  modules: {\n    todos: {\n      state: {\n        list: []\n      },\n      mutations: {\n        add (state, { text }) {\n          state.list.push({\n            text,\n            done: false\n          })\n        },\n        remove (state, { todo }) {\n          state.list.splice(state.list.indexOf(todo), 1)\n        },\n        toggle (state, { todo }) {\n          todo.done = !todo.done\n        }\n      }\n    }\n  }\n})\n</code></pre><ul>\n<li>在页面组件 pages/todos.vue， 可以像下面这样使用 todos 模块：</li>\n</ul>\n<pre><code>&lt;template&gt;\n  &lt;ul&gt;\n    &lt;li v-for=&quot;todo in todos&quot;&gt;\n      &lt;input type=&quot;checkbox&quot; :checked=&quot;todo.done&quot; @change=&quot;toggle(todo)&quot;&gt;\n      &lt;span :class=&quot;{ done: todo.done }&quot;&gt;{{ todo.text }}&lt;/span&gt;\n    &lt;/li&gt;\n    &lt;li&gt;&lt;input placeholder=&quot;What needs to be done?&quot; @keyup.enter=&quot;addTodo&quot;&gt;&lt;/li&gt;\n  &lt;/ul&gt;\n&lt;/template&gt;\n&lt;script&gt;\nimport { mapMutations } from &#39;vuex&#39;\n\nexport default {\n  computed: {\n    todos () { return this.$store.state.todos.list }\n  },\n  methods: {\n    addTodo (e) {\n      this.$store.commit(&#39;todos/add&#39;, e.target.value)\n      e.target.value = &#39;&#39;\n    },\n    ...mapMutations({\n      toggle: &#39;todos/toggle&#39;\n    })\n  }\n}\n&lt;/script&gt;\n\n&lt;style&gt;\n.done {\n  text-decoration: line-through;\n}\n&lt;/style&gt;\n</code></pre><ul>\n<li><P style='color:#fff;background-color:#35495e;padding:20px'>你也可以在模块文件里返回Vuex.Store实例,但是这种情况下你需要手工设置应用的状态树</p></li>\n</ul>\n<h3 id=\"fetch方法\"><a href=\"#fetch方法\" class=\"headerlink\" title=\"fetch方法\"></a>fetch方法</h3><ul>\n<li>fetch方法会在渲染页面前被调用，作用是填充状态树 (store) 数据，与 asyncData 方法类似，不同的是它不会设置组件的数据。</li>\n</ul>\n<h3 id=\"nuxtServerInit方法\"><a href=\"#nuxtServerInit方法\" class=\"headerlink\" title=\"nuxtServerInit方法\"></a>nuxtServerInit方法</h3><ul>\n<li><p>如果在状态树中指定了 nuxtServerInit 方法，Nuxt.js 调用它的时候会将页面的上下文对象作为第2个参数传给它（服务端调用时才会酱紫哟）。当我们想将服务端的一些数据传到客户端时，这个方法是非常好用的。</p>\n</li>\n<li><p>举个例子，假设我们服务端的会话状态树里可以通过req.session.user 来访问当前登录的用户。将该登录用户信息传给客户端的状态树，我们只需更新 store/index.js 如下</p>\n</li>\n</ul>\n<pre><code>actions: {\n  nuxtServerInit ({ commit }, { req }) {\n    if (req.session.user) {\n      commit(&#39;user&#39;, req.session.user)\n    }\n  }\n}\n</code></pre><ul>\n<li><p>如果你使用状态树模块化的模式，只有主模块（即 store/index.js）适用设置该方法（其他模块设置了也不会被调用）。</p>\n</li>\n<li><p>nuxtServerInit 方法接收的上下文对象和 fetch 的一样，但不包括 context.redirect() 和 context.error()。</p>\n</li>\n</ul>\n<h3 id=\"命令列表\"><a href=\"#命令列表\" class=\"headerlink\" title=\"命令列表\"></a>命令列表</h3><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">命令</th>\n<th style=\"text-align:center\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">nuxt</td>\n<td style=\"text-align:center\">启动一个热加载的Web服务器（开发模式） localhost:3000。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">nuxt build</td>\n<td style=\"text-align:center\">利用webpack编译应用，压缩JS和CSS资源（发布用）。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">nuxt start</td>\n<td style=\"text-align:center\">以生成模式启动一个Web服务器 (nuxt build 会先被执行)。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">nuxt generate</td>\n<td style=\"text-align:center\">编译应用，并依据路由配置生成对应的HTML文件 (用于静态站点的部署)</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>你可以将这些命令添加至 package.json：</li>\n</ul>\n<pre><code>&quot;scripts&quot;: {\n  &quot;dev&quot;: &quot;nuxt&quot;,\n  &quot;build&quot;: &quot;nuxt build&quot;,\n  &quot;start&quot;: &quot;nuxt start&quot;,\n  &quot;generate&quot;: &quot;nuxt generate&quot;\n}\n</code></pre><ul>\n<li>这样你可以通过 npm run <command> 来执行相应的命令。如: npm run dev。</li>\n</ul>\n<h3 id=\"发布部署\"><a href=\"#发布部署\" class=\"headerlink\" title=\"发布部署\"></a>发布部署</h3><ul>\n<li>Nuxt.js 提供了两种发布部署应用的方式：服务端渲染应用部署 和 静态应用部署</li>\n</ul>\n<h3 id=\"服务端渲染应用部署\"><a href=\"#服务端渲染应用部署\" class=\"headerlink\" title=\"服务端渲染应用部署\"></a>服务端渲染应用部署</h3><ul>\n<li>部署 Nuxt.js 服务端渲染的应用不能直接使用 nuxt 命令，而应该先进行编译构建，然后再启动 Nuxt 服务，可通过以下两个命令来完成：</li>\n</ul>\n<pre><code>nuxt build\nnuxt start\n</code></pre><ul>\n<li>推荐的 package.json 配置如下：</li>\n</ul>\n<pre><code>{\n  &quot;name&quot;: &quot;my-app&quot;,\n  &quot;dependencies&quot;: {\n    &quot;nuxt&quot;: &quot;latest&quot;\n  },\n  &quot;scripts&quot;: {\n    &quot;dev&quot;: &quot;nuxt&quot;,\n    &quot;build&quot;: &quot;nuxt build&quot;,\n    &quot;start&quot;: &quot;nuxt start&quot;\n  }\n}\n</code></pre><h3 id=\"静态应用部署\"><a href=\"#静态应用部署\" class=\"headerlink\" title=\"静态应用部署\"></a>静态应用部署</h3><ul>\n<li><p>Nuxt.js 可依据路由配置将应用静态化，使得我们可以将应用部署至任何一个静态站点主机服务商。</p>\n</li>\n<li><p>可利用下面的命令生成应用的静态目录和文件：</p>\n</li>\n</ul>\n<pre><code>npm run generate\n</code></pre><ul>\n<li><p>这个命令会创建一个 dist 文件夹，所有静态化后的资源文件均在其中。</p>\n</li>\n<li><p>如果你的项目需要用到动态路由，请移步 generate配置API 了解如何让 Nuxt.js 生成此类动态路由的静态文件。</p>\n</li>\n<li><p><P style=\"color:#fff;background-color:#35495e;padding:20px;\">注意：使用 nuxt generate 静态化应用的时候, 传给 asyncData() 和 fetch() 方法的上下文对象 不会包含 req 和 res 两个属性。</p></p>\n</li>\n</ul>\n<h3 id=\"API学习应用\"><a href=\"#API学习应用\" class=\"headerlink\" title=\"API学习应用\"></a>API学习应用</h3><h3 id=\"1-asyncData-方法\"><a href=\"#1-asyncData-方法\" class=\"headerlink\" title=\"1.asyncData 方法\"></a>1.asyncData 方法</h3><blockquote>\n<p>你可能想要在服务器端获取并渲染数据。Nuxt.js添加了asyncData方法使得你能够在渲染组件之前异步获取数据。<br>类型： Function<br>asyncData方法会在组件（限于页面组件）每次加载之前被调用。它可以在服务端或路由更新之前被调用。在这个方法被调用的时候，第一个参数被设定为当前页面的上下文对象，你可以利用 asyncData方法来获取数据并返回给当前组件</p>\n</blockquote>\n<pre><code>export default {\n  data () {\n    return { project: &#39;default&#39; }\n  },\n  asyncData (context) {\n    return { project: &#39;nuxt&#39; }\n  }\n}\n</code></pre><p><p style=\"color:#fff;background-color:#e67e22;padding:20px\">注意：由于asyncData方法是在组件 初始化 前被调用的，所以在方法内是没有办法通过 this 来引用组件的实例对象。</P></p>\n<h3 id=\"上下文对象\"><a href=\"#上下文对象\" class=\"headerlink\" title=\"上下文对象\"></a>上下文对象</h3><ul>\n<li>context 变量的可用属性一览：</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">属性字段</th>\n<th style=\"text-align:center\">类型</th>\n<th style=\"text-align:center\">可用</th>\n<th style=\"text-align:center\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">app</td>\n<td style=\"text-align:center\">根Vue实例</td>\n<td style=\"text-align:center\">客户端服务器</td>\n<td style=\"text-align:center\">包含所有插件的根Vue实例。例如，使用时axios，您可以访问$axios通过context.app.$axios。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">isClient</td>\n<td style=\"text-align:center\">Boolean</td>\n<td style=\"text-align:center\">客户端 &amp; 服务端</td>\n<td style=\"text-align:center\">是否来自客户端渲染</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">isServer</td>\n<td style=\"text-align:center\">Boolean</td>\n<td style=\"text-align:center\">客户端 &amp; 服务端</td>\n<td style=\"text-align:center\">是否来自服务端渲染</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">isDev</td>\n<td style=\"text-align:center\">Boolean</td>\n<td style=\"text-align:center\">客户端 &amp; 服务端</td>\n<td style=\"text-align:center\">是否是开发(dev) 模式，在生产环境的数据缓存中用到</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">route</td>\n<td style=\"text-align:center\">vue-router 路由</td>\n<td style=\"text-align:center\">客户端 &amp; 服务端</td>\n<td style=\"text-align:center\">vue-router 路由实例。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">store</td>\n<td style=\"text-align:center\">vuex 数据流</td>\n<td style=\"text-align:center\">客户端 &amp; 服务端</td>\n<td style=\"text-align:center\">Vuex.Store 实例。只有vuex 数据流存在相关配置时可用。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">env</td>\n<td style=\"text-align:center\">Object</td>\n<td style=\"text-align:center\">客户端 &amp; 服务端</td>\n<td style=\"text-align:center\">nuxt.config.js 中配置的环境变量, 见 环境变量 api</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">params</td>\n<td style=\"text-align:center\">Object</td>\n<td style=\"text-align:center\">客户端 &amp; 服务端</td>\n<td style=\"text-align:center\">route.params 的别名</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">query</td>\n<td style=\"text-align:center\">Object</td>\n<td style=\"text-align:center\">客户端 &amp; 服务端</td>\n<td style=\"text-align:center\">route.query 的别名</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">req</td>\n<td style=\"text-align:center\">http.Request</td>\n<td style=\"text-align:center\">服务端</td>\n<td style=\"text-align:center\">Node.js API 的 Request 对象。如果 nuxt 以中间件形式使用的话，这个对象就根据你所使用的框架而定。nuxt generate 不可用。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">res</td>\n<td style=\"text-align:center\">http.Response</td>\n<td style=\"text-align:center\">服务端</td>\n<td style=\"text-align:center\">Node.js API 的 Response 对象。如果 nuxt 以中间件形式使用的话，这个对象就根据你所使用的框架而定。nuxt generate 不可用。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">redirect</td>\n<td style=\"text-align:center\">Function</td>\n<td style=\"text-align:center\">客户端 &amp; 服务端</td>\n<td style=\"text-align:center\">用这个方法重定向用户请求到另一个路由。状态码在服务端被使用，默认 302。redirect([status,] path [, query])</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">error</td>\n<td style=\"text-align:center\">Function</td>\n<td style=\"text-align:center\">客户端 &amp; 服务端</td>\n<td style=\"text-align:center\">用这个方法展示错误页：error(params)。params 参数应该包含 statusCode 和 message 字段。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"fetch-方法\"><a href=\"#fetch-方法\" class=\"headerlink\" title=\"fetch 方法\"></a>fetch 方法</h3><ul>\n<li>fetch 方法用于在渲染页面前填充应用的状态树（store）数据， 与 asyncData 方法类似，不同的是它不会设置组件的数据</li>\n<li>类型： Function</li>\n<li><p>如果页面组件设置了 fetch 方法，它会在组件每次加载前被调用（在服务端或切换至目标路由之前）。</p>\n</li>\n<li><p>fetch 方法的第一个参数是页面组件的上下文对象 context，我们可以用 fetch 方法来获取数据填充应用的状态树。为了让获取过程可以异步，你需要返回一个 Promise，Nuxt.js 会等这个 promise 完成后再渲染组件。</p>\n</li>\n<li><p>例如 pages/index.vue：</p>\n</li>\n</ul>\n<pre><code>&lt;template&gt;\n  &lt;h1&gt;Stars: {{ $store.state.stars }}&lt;/h1&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nexport default {\n  fetch ({ store, params }) {\n    return axios.get(&#39;http://my-api/stars&#39;)\n    .then((res) =&gt; {\n      store.commit(&#39;setStars&#39;, res.data)\n    })\n  }\n}\n&lt;/script&gt;\n</code></pre><ul>\n<li>你也可以使用 async 或 await 的模式简化代码如下：</li>\n</ul>\n<pre><code>&lt;template&gt;\n  &lt;h1&gt;Stars: {{ $store.state.stars }}&lt;/h1&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nexport default {\n  async fetch ({ store, params }) {\n    let { data } = await axios.get(&#39;http://my-api/stars&#39;)\n    store.commit(&#39;setStars&#39;, data)\n  }\n}\n&lt;/script&gt;\n</code></pre><h3 id=\"head-方法\"><a href=\"#head-方法\" class=\"headerlink\" title=\"head 方法\"></a>head 方法</h3><ul>\n<li>Nuxt.js 使用了 vue-meta 更新应用的 头部标签(Head) 和 html 属性</li>\n<li>类型： Object 或 Function</li>\n<li><p>使用 head 方法设置当前页面的头部标签。</p>\n</li>\n<li><p>在 head 方法里可通过 this 关键字来获取组件的数据，你可以利用页面组件的数据来设置个性化的 meta 标签</p>\n</li>\n</ul>\n<pre><code>&lt;template&gt;\n  &lt;h1&gt;{{ title }}&lt;/h1&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nexport default {\n  data () {\n    return {\n      title: &#39;Hello World!&#39;\n    }\n  },\n  head () {\n    return {\n      title: this.title,\n      meta: [\n        { hid: &#39;description&#39;, name: &#39;description&#39;, content: &#39;My custom description&#39; }\n      ]\n    }\n  }\n}\n&lt;/script&gt;\n</code></pre><ul>\n<li><p style=\"color:#fff;background-color:#e67e22;padding:20px\">注意：为了避免子组件中的meta标签不能正确覆盖父组件中相同的标签而产生重复的现象，建议利用 hid 键为meta标签配一个唯一的标识编号。请阅读关于 vue-meta 的更多信息</P></li>\n</ul>\n<h3 id=\"layout-属性\"><a href=\"#layout-属性\" class=\"headerlink\" title=\"layout 属性\"></a>layout 属性</h3><ul>\n<li><p>layouts 根目录下的所有文件都属于个性化布局文件，可以在页面组件中利用 layout 属性来引用。</p>\n</li>\n<li><p>类型： String 或 Function (默认值： ‘default’)</p>\n</li>\n<li>使用 layout 属性来为页面指定使用哪一个布局文件：在上面的例子中,Nuxt.js 会使用 layouts/blog.vue 作为当前页面组件的布局文件。</li>\n</ul>\n<pre><code>export default {\n  layout: &#39;blog&#39;,\n  // 或\n  layout (context) {\n    return &#39;blog&#39;\n  }\n}\n</code></pre><h3 id=\"middleware-属性\"><a href=\"#middleware-属性\" class=\"headerlink\" title=\"middleware 属性\"></a>middleware 属性</h3><ul>\n<li><p>中间件属性</p>\n<blockquote>\n<p>类型：String或Array<br>项目： String<br>为应用程序的特定页面设置中间件。</p>\n</blockquote>\n</li>\n<li><p>例：pages/secret.vue：</p>\n</li>\n</ul>\n<pre><code>&lt;template&gt;\n  &lt;h1&gt;Secret page&lt;/h1&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nexport default {\n  middleware: &#39;authenticated&#39;\n}\n&lt;/script&gt;\n</code></pre><ul>\n<li>middleware/authenticated.js：</li>\n</ul>\n<pre><code>export default function ({ store, redirect }) {\n  // If the user is not authenticated\n  if (!store.state.authenticated) {\n    return redirect(&#39;/login&#39;)\n  }\n}\n</code></pre><h3 id=\"scrollToTop属性\"><a href=\"#scrollToTop属性\" class=\"headerlink\" title=\"scrollToTop属性\"></a>scrollToTop属性</h3><ul>\n<li><p>使用scrollToTop属性可以告诉nuxt.js在呈现页面之前滚动到顶部。</p>\n</li>\n<li><p>类型： Boolean（默认：false）</p>\n</li>\n<li>默认情况下，当你转到另一个页面时，Nuxt.js会滚动到顶部，但是对于子路径，Nuxt.js将保持滚动位置。如果你想告诉Nuxt.js在渲染子路径时滚动到顶部，请设置scrollToTop: true：</li>\n</ul>\n<pre><code>&lt;template&gt;\n  &lt;h1&gt;My child component&lt;/h1&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nexport default {\n  scrollToTop: true\n}\n&lt;/script&gt;\n</code></pre><h3 id=\"transition-属性\"><a href=\"#transition-属性\" class=\"headerlink\" title=\"transition 属性\"></a>transition 属性</h3><ul>\n<li><p>Nuxt.js 使用 Vue.js 的<transition>组件来实现路由切换时的过渡动效。</p>\n</li>\n<li><p>类型： String 或 Object 或 Function</p>\n</li>\n<li>如果想给某个页面自定义过渡特效的话，只要在该页面组件中配置 transition 字段即可：</li>\n</ul>\n<pre><code>export default {\n  // 可以是字符\n  transition: &#39;&#39;\n  // 或对象\n  transition: {}\n  // 或函数\n  transition (to, from) {}\n}\n</code></pre><h3 id=\"String-字符\"><a href=\"#String-字符\" class=\"headerlink\" title=\"String 字符\"></a>String 字符</h3><ul>\n<li>如果 transition 属性的值类型是字符类型， 相当于设置了动效配置对象的 name 属性：transition.name。</li>\n</ul>\n<pre><code>export default {\n  transition: &#39;test&#39;\n}\n</code></pre><ul>\n<li>Nuxt.js 将使用上面的配置来设置 Vue.js transition 组件，如下：</li>\n</ul>\n<pre><code>&lt;transition name=&quot;test&quot;&gt;\n</code></pre><h3 id=\"Object对象\"><a href=\"#Object对象\" class=\"headerlink\" title=\"Object对象\"></a>Object对象</h3><ul>\n<li>如果 transition 属性的值类型是对象类型：</li>\n</ul>\n<pre><code>export default {\n  transition: {\n    name: &#39;test&#39;,\n    mode: &#39;out-in&#39;\n  }\n}\n</code></pre><ul>\n<li>Nuxt.js 将使用上面的配置来设置 Vue.js transition 组件，如下：</li>\n</ul>\n<pre><code>&lt;transition name=&quot;test&quot; mode=&quot;out-in&quot;&gt;\n</code></pre><ul>\n<li>transition 允许配置的字段介绍：</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">属性字段</th>\n<th style=\"text-align:center\">类型</th>\n<th style=\"text-align:center\">默认值</th>\n<th style=\"text-align:center\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">name</td>\n<td style=\"text-align:center\">String</td>\n<td style=\"text-align:center\">“page”</td>\n<td style=\"text-align:center\">所有路由过渡都会用到的过渡名称。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">mode</td>\n<td style=\"text-align:center\">String</td>\n<td style=\"text-align:center\">“out-in”</td>\n<td style=\"text-align:center\">所有路由都用到的过渡模式，见 Vue.js transition 使用文档。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">css</td>\n<td style=\"text-align:center\">Boolean</td>\n<td style=\"text-align:center\">true</td>\n<td style=\"text-align:center\">是否给页面组件根元素添加 CSS 过渡类名。如果值为false，路由过渡时将触发页面组件事件注册的 Javascript 钩子方法。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">type</td>\n<td style=\"text-align:center\">String</td>\n<td style=\"text-align:center\">n/a</td>\n<td style=\"text-align:center\">指定过滤动效事件的类型，用于判断过渡结束的时间点。值可以是 “transition” 或 “animation”。 默认情况下, Nuxt.js 会自动侦测动效事件的类型。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">enterClass</td>\n<td style=\"text-align:center\">String</td>\n<td style=\"text-align:center\">n/a</td>\n<td style=\"text-align:center\">目标路由动效开始时的类名。 详情请参考 Vue.js transition 使用文档 。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">enterToClass</td>\n<td style=\"text-align:center\">String</td>\n<td style=\"text-align:center\">n/a</td>\n<td style=\"text-align:center\">目标路由动效结束时的类名。 详情请参考 Vue.js transition 使用文档 。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">enterActiveClass</td>\n<td style=\"text-align:center\">String</td>\n<td style=\"text-align:center\">n/a</td>\n<td style=\"text-align:center\">目标路由过渡过程中的类名。详情请参考 Vue.js transition 使用文档</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">leaveClass</td>\n<td style=\"text-align:center\">String</td>\n<td style=\"text-align:center\">n/a</td>\n<td style=\"text-align:center\">当前路由动效开始时的类名。 详情请参考 Vue.js transition 使用文档 。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">leaveToClass</td>\n<td style=\"text-align:center\">String</td>\n<td style=\"text-align:center\">n/a</td>\n<td style=\"text-align:center\">当前路由动效结束时的类名。 详情请参考 Vue.js transition 使用文档 。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">leaveActiveClass</td>\n<td style=\"text-align:center\">String</td>\n<td style=\"text-align:center\">n/a</td>\n<td style=\"text-align:center\">当前路由动效过程中的类名。详情请参考 Vue.js transition 使用文档</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"validate-方法\"><a href=\"#validate-方法\" class=\"headerlink\" title=\"validate 方法\"></a>validate 方法</h3><ul>\n<li>Nuxt.js 可以让你在动态路由对应的页面组件中配置一个校验方法用于校验动态路由参数的有效性。</li>\n<li>类型： Function</li>\n</ul>\n<pre><code>validate({ params, query }) {\n  return true // 如果参数有效\n  return false // 参数无效，Nuxt.js 停止渲染当前页面并显示错误页面\n}\n</code></pre><ul>\n<li>Nuxt.js 可以让你在动态路由对应的页面组件（本例为： pages/users/_id.vue）中配置一个校验方法</li>\n<li>如果校验方法返回的值不为 true， Nuxt.js 将自动加载显示 404 错误页面</li>\n</ul>\n<pre><code>export default {\n  validate ({ params }) {\n    // Must be a number\n    return /^\\d+$/.test(params.id)\n  }\n}\n</code></pre><ul>\n<li><p>你也可以在validate 方法中校验 store 的数据 (如果 store 此前在 nuxtServerInit 方法 中被设置了的话):</p>\n</li>\n<li><p>你也可以在validate 方法中校验 store 的数据 (如果 store 此前在 nuxtServerInit 方法 中被设置了的话):</p>\n<pre><code>export default {\nvalidate ({ params, store }) {\n  // 校验 `params.id` 是否存在\n  return store.state.categories.some((category) =&gt; category.id === params.id)\n}\n}\n</code></pre></li>\n</ul>\n","updated":"2018-04-03T04:57:22.000Z","comments":true,"link":"","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://yoursite.com/categories/前端开发/"}],"tags":[{"name":"Nuxt","slug":"Nuxt","permalink":"http://yoursite.com/tags/Nuxt/"}]},{"title":"vue项目使用flexible+rem实现移动端自适应","date":"2018-02-26T08:03:58.000Z","path":"2018/02/26/flexibleRem/","text":"项目安装flexible px2remnpm i lib-flexible –savenpm i px2rem-loader –save-dev 入口文件引入flexible main.js文件 import ‘lib-flexible’ webpack生成的vue-cli项目更改配置 文件 build/utils.js 修改 const cssLoader = { loader: &#39;css-loader&#39;, options: { sourceMap: options.sourceMap, importLoaders: 2 } } 增加 const px2remLoader = { loader: &#39;px2rem-loader&#39;, options: { remUnit: 75 } } remUnit的值根据设计稿来，这里是750的设计稿 修改 const loaders = options.usePostCSS ? [cssLoader, postcssLoader,px2remLoader] : [cssLoader,px2remLoader]","content":"<blockquote>\n<p>项目安装flexible px2rem<br>npm i lib-flexible –save<br>npm i px2rem-loader –save-dev</p>\n</blockquote>\n<ul>\n<li>入口文件引入flexible</li>\n<li><p>main.js文件 import ‘lib-flexible’</p>\n</li>\n<li><p>webpack生成的vue-cli项目更改配置</p>\n</li>\n<li>文件 build/utils.js</li>\n<li>修改</li>\n</ul>\n<pre><code>const cssLoader = {\n    loader: &#39;css-loader&#39;,\n    options: {\n      sourceMap: options.sourceMap,\n      importLoaders: 2\n    }\n  }\n</code></pre><ul>\n<li>增加</li>\n</ul>\n<pre><code>const px2remLoader = {\n    loader: &#39;px2rem-loader&#39;,\n    options: {\n      remUnit: 75\n    }\n  }\n</code></pre><ul>\n<li><p>remUnit的值根据设计稿来，这里是750的设计稿</p>\n</li>\n<li><p>修改</p>\n</li>\n<li>const loaders = options.usePostCSS ? [cssLoader, postcssLoader,px2remLoader] : [cssLoader,px2remLoader]</li>\n</ul>\n","updated":"2018-03-06T01:19:38.000Z","comments":true,"link":"","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://yoursite.com/categories/前端开发/"}],"tags":[{"name":"css,js","slug":"css-js","permalink":"http://yoursite.com/tags/css-js/"}]},{"title":"rem自适应布局-移动端自适应必备:flexible.js","date":"2018-02-26T07:03:58.000Z","path":"2018/02/26/flexible/","text":"由于移动端特殊性，本文讲的是如何使用rem实现自适应，或叫rem响应式布局，通过使用一个脚本就可以rem自适应，不用再为各种设备宽度不同而烦恼如何实现自适应的问题。 rem是相对于根元素，这样就意味着，我们只需要在根元素确定一个px字号，则可以来算出元素的宽高。1rem=16px(浏览器html的像素，可以设定这个基准值），假如浏览器的html设为64px，则下面的元素则1rem=64px来运算。 阿里团队开源的一个库。使用flexible.js轻松搞定各种不同的移动端设备兼容自适应问题。 实现方法： 通过js来调整html的字体大小，而在页面中的制作稿则统一使用rem这个单位来制作。关键代码如下： ;(function(win, lib) { var doc = win.document; var docEl = doc.documentElement; var metaEl = doc.querySelector(&#39;meta[name=&quot;viewport&quot;]&#39;); var flexibleEl = doc.querySelector(&#39;meta[name=&quot;flexible&quot;]&#39;); var dpr = 0; var scale = 0; var tid; var flexible = lib.flexible || (lib.flexible = {}); if (metaEl) { console.warn(&#39;将根据已有的meta标签来设置缩放比例&#39;); var match = metaEl.getAttribute(&#39;content&#39;).match(/initial\\-scale=([\\d\\.]+)/); if (match) { scale = parseFloat(match[1]); dpr = parseInt(1 / scale); } } else if (flexibleEl) { var content = flexibleEl.getAttribute(&#39;content&#39;); if (content) { var initialDpr = content.match(/initial\\-dpr=([\\d\\.]+)/); var maximumDpr = content.match(/maximum\\-dpr=([\\d\\.]+)/); if (initialDpr) { dpr = parseFloat(initialDpr[1]); scale = parseFloat((1 / dpr).toFixed(2)); } if (maximumDpr) { dpr = parseFloat(maximumDpr[1]); scale = parseFloat((1 / dpr).toFixed(2)); } } } if (!dpr &amp;&amp; !scale) { var isAndroid = win.navigator.appVersion.match(/android/gi); var isIPhone = win.navigator.appVersion.match(/iphone/gi); var devicePixelRatio = win.devicePixelRatio; if (isIPhone) { // iOS下，对于2和3的屏，用2倍的方案，其余的用1倍方案 if (devicePixelRatio &gt;= 3 &amp;&amp; (!dpr || dpr &gt;= 3)) { dpr = 3; } else if (devicePixelRatio &gt;= 2 &amp;&amp; (!dpr || dpr &gt;= 2)){ dpr = 2; } else { dpr = 1; } } else { // 其他设备下，仍旧使用1倍的方案 dpr = 1; } scale = 1 / dpr; } docEl.setAttribute(&#39;data-dpr&#39;, dpr); if (!metaEl) { metaEl = doc.createElement(&#39;meta&#39;); metaEl.setAttribute(&#39;name&#39;, &#39;viewport&#39;); metaEl.setAttribute(&#39;content&#39;, &#39;initial-scale=&#39; + scale + &#39;, maximum-scale=&#39; + scale + &#39;, minimum-scale=&#39; + scale + &#39;, user-scalable=no&#39;); if (docEl.firstElementChild) { docEl.firstElementChild.appendChild(metaEl); } else { var wrap = doc.createElement(&#39;div&#39;); wrap.appendChild(metaEl); doc.write(wrap.innerHTML); } } function refreshRem(){ var width = docEl.getBoundingClientRect().width; if (width / dpr &gt; 540) { width = 540 * dpr; } var rem = width / 10; docEl.style.fontSize = rem + &#39;px&#39;; flexible.rem = win.rem = rem; } win.addEventListener(&#39;resize&#39;, function() { clearTimeout(tid); tid = setTimeout(refreshRem, 300); }, false); win.addEventListener(&#39;pageshow&#39;, function(e) { if (e.persisted) { clearTimeout(tid); tid = setTimeout(refreshRem, 300); } }, false); if (doc.readyState === &#39;complete&#39;) { doc.body.style.fontSize = 12 * dpr + &#39;px&#39;; } else { doc.addEventListener(&#39;DOMContentLoaded&#39;, function(e) { doc.body.style.fontSize = 12 * dpr + &#39;px&#39;; }, false); } refreshRem(); flexible.dpr = win.dpr = dpr; flexible.refreshRem = refreshRem; flexible.rem2px = function(d) { var val = parseFloat(d) * this.rem; if (typeof d === &#39;string&#39; &amp;&amp; d.match(/rem$/)) { val += &#39;px&#39;; } return val; } flexible.px2rem = function(d) { var val = parseFloat(d) / this.rem; if (typeof d === &#39;string&#39; &amp;&amp; d.match(/px$/)) { val += &#39;rem&#39;; } return val; } })(window, window[&#39;lib&#39;] || (window[&#39;lib&#39;] = {})); 从上面的代码，主要是改变了dpx和document的font-size大小。大小为docEl.getBoundingClientRect().width / 10 + ‘px’; 假设我们的设计稿宽是640的，则html的字体大小则被设为64px.则相当于1rem=64px。 假如一个元素的宽是160px,在平时，我们可以采用百分比可以做到自适应，假如使用响应式的话，可能需要设置多个，比如在320px，输出80px，而在640px输出160px等。 而采用以上rem的方法，则只需要输出2.5rem就能实现统一，如下表格： 设备宽度 320px 360px 414px 640px Html字体大小 32px 36px 41.4 64px 实际输出 1rem 1rem 1rem 1rem 设计稿缩放大小 80px 90px 103.5px 160px 实际输出 2.5rem 2.5rem 2.5rem 2.5rem 以上的2.5rem是怎么得出的呢？ 160/64（1rem的基数为64px）=2.5rem;按照官方的说法（640px举例） Flexible会将视觉稿分成100份（主要为了以后能更好的兼容vh和vw），而每一份被称为一个单位a。同时1rem单位被认定为10a。针对我们这份视觉稿可以计算出：(设计稿为750px为例） 1a = 7.5px1rem = 75px 那么我们这个示例的稿子就分成了10a，也就是整个宽度为10rem，对应的font-size为75px","content":"<ul>\n<li><p>由于移动端特殊性，本文讲的是如何使用rem实现自适应，或叫rem响应式布局，通过使用一个脚本就可以rem自适应，不用再为各种设备宽度不同而烦恼如何实现自适应的问题。</p>\n</li>\n<li><p>rem是相对于根元素<html>，这样就意味着，我们只需要在根元素确定一个px字号，则可以来算出元素的宽高。1rem=16px(浏览器html的像素，可以设定这个基准值），假如浏览器的html设为64px，则下面的元素则1rem=64px来运算。</p>\n</li>\n<li><p>阿里团队开源的一个库。使用flexible.js轻松搞定各种不同的移动端设备兼容自适应问题。</p>\n</li>\n</ul>\n<h3 id=\"实现方法：\"><a href=\"#实现方法：\" class=\"headerlink\" title=\"实现方法：\"></a>实现方法：</h3><ul>\n<li>通过js来调整html的字体大小，而在页面中的制作稿则统一使用rem这个单位来制作。关键代码如下：</li>\n</ul>\n<pre><code>;(function(win, lib) {\n    var doc = win.document;\n    var docEl = doc.documentElement;\n    var metaEl = doc.querySelector(&#39;meta[name=&quot;viewport&quot;]&#39;);\n    var flexibleEl = doc.querySelector(&#39;meta[name=&quot;flexible&quot;]&#39;);\n    var dpr = 0;\n    var scale = 0;\n    var tid;\n    var flexible = lib.flexible || (lib.flexible = {});\n\n    if (metaEl) {\n        console.warn(&#39;将根据已有的meta标签来设置缩放比例&#39;);\n        var match = metaEl.getAttribute(&#39;content&#39;).match(/initial\\-scale=([\\d\\.]+)/);\n        if (match) {\n            scale = parseFloat(match[1]);\n            dpr = parseInt(1 / scale);\n        }\n    } else if (flexibleEl) {\n        var content = flexibleEl.getAttribute(&#39;content&#39;);\n        if (content) {\n            var initialDpr = content.match(/initial\\-dpr=([\\d\\.]+)/);\n            var maximumDpr = content.match(/maximum\\-dpr=([\\d\\.]+)/);\n            if (initialDpr) {\n                dpr = parseFloat(initialDpr[1]);\n                scale = parseFloat((1 / dpr).toFixed(2));    \n            }\n            if (maximumDpr) {\n                dpr = parseFloat(maximumDpr[1]);\n                scale = parseFloat((1 / dpr).toFixed(2));    \n            }\n        }\n    }\n\n    if (!dpr &amp;&amp; !scale) {\n        var isAndroid = win.navigator.appVersion.match(/android/gi);\n        var isIPhone = win.navigator.appVersion.match(/iphone/gi);\n        var devicePixelRatio = win.devicePixelRatio;\n        if (isIPhone) {\n            // iOS下，对于2和3的屏，用2倍的方案，其余的用1倍方案\n            if (devicePixelRatio &gt;= 3 &amp;&amp; (!dpr || dpr &gt;= 3)) {                \n                dpr = 3;\n            } else if (devicePixelRatio &gt;= 2 &amp;&amp; (!dpr || dpr &gt;= 2)){\n                dpr = 2;\n            } else {\n                dpr = 1;\n            }\n        } else {\n            // 其他设备下，仍旧使用1倍的方案\n            dpr = 1;\n        }\n        scale = 1 / dpr;\n    }\n\n    docEl.setAttribute(&#39;data-dpr&#39;, dpr);\n    if (!metaEl) {\n        metaEl = doc.createElement(&#39;meta&#39;);\n        metaEl.setAttribute(&#39;name&#39;, &#39;viewport&#39;);\n        metaEl.setAttribute(&#39;content&#39;, &#39;initial-scale=&#39; + scale + &#39;, maximum-scale=&#39; + scale + &#39;, minimum-scale=&#39; + scale + &#39;, user-scalable=no&#39;);\n        if (docEl.firstElementChild) {\n            docEl.firstElementChild.appendChild(metaEl);\n        } else {\n            var wrap = doc.createElement(&#39;div&#39;);\n            wrap.appendChild(metaEl);\n            doc.write(wrap.innerHTML);\n        }\n    }\n\n    function refreshRem(){\n        var width = docEl.getBoundingClientRect().width;\n        if (width / dpr &gt; 540) {\n            width = 540 * dpr;\n        }\n        var rem = width / 10;\n        docEl.style.fontSize = rem + &#39;px&#39;;\n        flexible.rem = win.rem = rem;\n    }\n\n    win.addEventListener(&#39;resize&#39;, function() {\n        clearTimeout(tid);\n        tid = setTimeout(refreshRem, 300);\n    }, false);\n    win.addEventListener(&#39;pageshow&#39;, function(e) {\n        if (e.persisted) {\n            clearTimeout(tid);\n            tid = setTimeout(refreshRem, 300);\n        }\n    }, false);\n\n    if (doc.readyState === &#39;complete&#39;) {\n        doc.body.style.fontSize = 12 * dpr + &#39;px&#39;;\n    } else {\n        doc.addEventListener(&#39;DOMContentLoaded&#39;, function(e) {\n            doc.body.style.fontSize = 12 * dpr + &#39;px&#39;;\n        }, false);\n    }\n\n\n    refreshRem();\n\n    flexible.dpr = win.dpr = dpr;\n    flexible.refreshRem = refreshRem;\n    flexible.rem2px = function(d) {\n        var val = parseFloat(d) * this.rem;\n        if (typeof d === &#39;string&#39; &amp;&amp; d.match(/rem$/)) {\n            val += &#39;px&#39;;\n        }\n        return val;\n    }\n    flexible.px2rem = function(d) {\n        var val = parseFloat(d) / this.rem;\n        if (typeof d === &#39;string&#39; &amp;&amp; d.match(/px$/)) {\n            val += &#39;rem&#39;;\n        }\n        return val;\n    }\n\n})(window, window[&#39;lib&#39;] || (window[&#39;lib&#39;] = {}));\n</code></pre><ul>\n<li>从上面的代码，主要是改变了dpx和document的font-size大小。大小为docEl.getBoundingClientRect().width / 10 + ‘px’;</li>\n</ul>\n<p><strong> 假设我们的设计稿宽是640的，则html的字体大小则被设为64px.则相当于1rem=64px。 </strong></p>\n<ul>\n<li><p>假如一个元素的宽是160px,在平时，我们可以采用百分比可以做到自适应，假如使用响应式的话，可能需要设置多个，比如在320px，输出80px，而在640px输出160px等。</p>\n</li>\n<li><p>而采用以上rem的方法，则只需要输出2.5rem就能实现统一，如下表格：</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>设备宽度</th>\n<th style=\"text-align:right\">320px</th>\n<th style=\"text-align:right\">360px</th>\n<th style=\"text-align:right\">414px</th>\n<th style=\"text-align:center\">640px</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><font color=#ff0000 >Html字体大小</font></td>\n<td style=\"text-align:right\"><font color=#ff0000 >32px</font></td>\n<td style=\"text-align:right\"><font color=#ff0000 >36px</font></td>\n<td style=\"text-align:right\"><font color=#ff0000 >41.4</font></td>\n<td style=\"text-align:center\"><font color=#ff0000 >64px</font></td>\n</tr>\n<tr>\n<td>实际输出</td>\n<td style=\"text-align:right\">1rem</td>\n<td style=\"text-align:right\">1rem</td>\n<td style=\"text-align:right\">1rem</td>\n<td style=\"text-align:center\">1rem</td>\n</tr>\n<tr>\n<td>设计稿缩放大小</td>\n<td style=\"text-align:right\">80px</td>\n<td style=\"text-align:right\">90px</td>\n<td style=\"text-align:right\">103.5px</td>\n<td style=\"text-align:center\">160px</td>\n</tr>\n<tr>\n<td><font color=#ff0000 >实际输出</font></td>\n<td style=\"text-align:right\"><font color=#ff0000 >2.5rem</font></td>\n<td style=\"text-align:right\"><font color=#ff0000 >2.5rem</font></td>\n<td style=\"text-align:right\"><font color=#ff0000 >2.5rem</font></td>\n<td style=\"text-align:center\"><font color=#ff0000 >2.5rem</font></td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><p>以上的2.5rem是怎么得出的呢？</p>\n</li>\n<li><p>160/64（1rem的基数为64px）=2.5rem;按照官方的说法（640px举例）</p>\n</li>\n<li><p>Flexible会将视觉稿分成100份（主要为了以后能更好的兼容vh和vw），而每一份被称为一个单位a。同时1rem单位被认定为10a。针对我们这份视觉稿可以计算出：(设计稿为750px为例）</p>\n</li>\n</ul>\n<blockquote>\n<p>1a   = 7.5px<br>1rem = 75px </p>\n</blockquote>\n<ul>\n<li>那么我们这个示例的稿子就分成了10a，也就是整个宽度为10rem，<html>对应的font-size为75px</li>\n</ul>\n","updated":"2018-04-26T09:40:52.000Z","comments":true,"link":"","categories":[{"name":"移动端自适应","slug":"移动端自适应","permalink":"http://yoursite.com/categories/移动端自适应/"}],"tags":[{"name":"flexible","slug":"flexible","permalink":"http://yoursite.com/tags/flexible/"}]},{"title":"判断浏览器为PC还是移动端","date":"2018-02-26T07:03:58.000Z","path":"2018/02/26/userAgent/","text":"判断浏览器为PC还是移动端 判断userAgent、根据正则、找出对应的设备或者浏览器 &lt;script type=&quot;text/javascript&quot;&gt; function browserRedirect() { var sUserAgent = navigator.userAgent.toLowerCase(); var bIsIpad = sUserAgent.match(/ipad/i) == &quot;ipad&quot;; var bIsIphoneOs = sUserAgent.match(/iphone os/i) == &quot;iphone os&quot;; var bIsMidp = sUserAgent.match(/midp/i) == &quot;midp&quot;; var bIsUc7 = sUserAgent.match(/rv:1.2.3.4/i) == &quot;rv:1.2.3.4&quot;; var bIsUc = sUserAgent.match(/ucweb/i) == &quot;ucweb&quot;; var bIsAndroid = sUserAgent.match(/android/i) == &quot;android&quot;; var bIsCE = sUserAgent.match(/windows ce/i) == &quot;windows ce&quot;; var bIsWM = sUserAgent.match(/windows mobile/i) == &quot;windows mobile&quot;; document.writeln(&quot;您的浏览设备为：&quot;); if (bIsIpad || bIsIphoneOs || bIsMidp || bIsUc7 || bIsUc || bIsAndroid || bIsCE || bIsWM) { document.writeln(&quot;phone&quot;); } else { document.writeln(&quot;pc&quot;); } } browserRedirect(); &lt;/script&gt; 判断滚动条是向上还是向下 在写wap中遇到了这个需求、把代码记录下来吧 $(document).ready(function(){ var position=0,top=0; $(window).scroll(function(e){ position = $(this).scrollTop(); if(top&lt;=position){//下滚 ....... } else{//上滚 ....... } setTimeout(function(){top = position;},0); }); }); 制作两端对齐响应式布局 制作这个布局主要用到了text-align: justify 大家应该知道、这是文字两端对齐的css样式 但是注意了（敲敲黑板） 没有换行的文本不会生效 那么这里有一个投机的办法、就是用:after的content属性为它创造换行的环境 用到这个、我还想起了一个和他很像的属性text-align-last: justify 但是text-align-last 只有IE和Firefox支持 那么就不考虑、喜欢尝试的同学可以下去自己试一下 那么只需要把元素设为inline-block并且加上after伪类就可以了 &lt;style&gt; .test{ text-align: justify; } .test .box{ display: inline-block; width: 100px; height: 100px; background: red; } .test:after {width: 100%;height: 0;margin: 0;display: inline-block;overflow: hidden;content: &#39;&#39;;} &lt;/style&gt; &lt;div class=&quot;test&quot;&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;text-center&quot;&gt;试着放大缩小窗口&lt;/div&gt;","content":"<h3 id=\"判断浏览器为PC还是移动端\"><a href=\"#判断浏览器为PC还是移动端\" class=\"headerlink\" title=\"判断浏览器为PC还是移动端\"></a>判断浏览器为PC还是移动端</h3><ul>\n<li>判断userAgent、根据正则、找出对应的设备或者浏览器</li>\n</ul>\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\n    function browserRedirect() {\n        var sUserAgent = navigator.userAgent.toLowerCase();\n        var bIsIpad = sUserAgent.match(/ipad/i) == &quot;ipad&quot;;\n        var bIsIphoneOs = sUserAgent.match(/iphone os/i) == &quot;iphone os&quot;;\n        var bIsMidp = sUserAgent.match(/midp/i) == &quot;midp&quot;;\n        var bIsUc7 = sUserAgent.match(/rv:1.2.3.4/i) == &quot;rv:1.2.3.4&quot;;\n        var bIsUc = sUserAgent.match(/ucweb/i) == &quot;ucweb&quot;;\n        var bIsAndroid = sUserAgent.match(/android/i) == &quot;android&quot;;\n        var bIsCE = sUserAgent.match(/windows ce/i) == &quot;windows ce&quot;;\n        var bIsWM = sUserAgent.match(/windows mobile/i) == &quot;windows mobile&quot;;\n        document.writeln(&quot;您的浏览设备为：&quot;);\n        if (bIsIpad || bIsIphoneOs || bIsMidp || bIsUc7 || bIsUc || bIsAndroid || bIsCE || bIsWM) {\n            document.writeln(&quot;phone&quot;);\n        } else {\n            document.writeln(&quot;pc&quot;);\n        }\n    }\n\n    browserRedirect();\n&lt;/script&gt;\n</code></pre><h3 id=\"判断滚动条是向上还是向下\"><a href=\"#判断滚动条是向上还是向下\" class=\"headerlink\" title=\"判断滚动条是向上还是向下\"></a>判断滚动条是向上还是向下</h3><ul>\n<li>在写wap中遇到了这个需求、把代码记录下来吧</li>\n</ul>\n<pre><code>$(document).ready(function(){\n    var position=0,top=0;\n\n    $(window).scroll(function(e){\n            position = $(this).scrollTop();\n\n            if(top&lt;=position){//下滚\n                .......\n            }\n\n            else{//上滚\n                .......\n            }\n            setTimeout(function(){top = position;},0);\n    });\n});\n</code></pre><h3 id=\"制作两端对齐响应式布局\"><a href=\"#制作两端对齐响应式布局\" class=\"headerlink\" title=\"制作两端对齐响应式布局\"></a>制作两端对齐响应式布局</h3><blockquote>\n<p>制作这个布局主要用到了text-align: justify</p>\n<p>大家应该知道、这是文字两端对齐的css样式</p>\n<p>但是注意了（敲敲黑板） 没有换行的文本不会生效</p>\n<p>那么这里有一个投机的办法、就是用:after的content属性为它创造换行的环境</p>\n<p>用到这个、我还想起了一个和他很像的属性text-align-last: justify</p>\n<p>但是text-align-last 只有IE和Firefox支持</p>\n<p>那么就不考虑、喜欢尝试的同学可以下去自己试一下</p>\n<p>那么只需要把元素设为inline-block并且加上after伪类就可以了</p>\n</blockquote>\n<pre><code>&lt;style&gt;\n  .test{\n    text-align: justify;\n  }\n  .test .box{\n    display: inline-block;\n    width: 100px;\n    height: 100px;\n    background: red;\n  }\n  .test:after {width: 100%;height: 0;margin: 0;display: inline-block;overflow: hidden;content: &#39;&#39;;}\n&lt;/style&gt;\n\n&lt;div class=&quot;test&quot;&gt;\n  &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n  &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n  &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n  &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n  &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n  &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n  &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n&lt;/div&gt;\n&lt;div class=&quot;text-center&quot;&gt;试着放大缩小窗口&lt;/div&gt;\n</code></pre>","updated":"2020-05-11T02:44:55.305Z","comments":true,"link":"","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://yoursite.com/categories/前端开发/"}],"tags":[{"name":"css,js","slug":"css-js","permalink":"http://yoursite.com/tags/css-js/"}]},{"title":"rem是如何实现自适应布局的","date":"2018-02-26T02:03:58.000Z","path":"2018/02/26/rem/","text":"摘要：rem是相对于根元素html，这样就意味着，我们只需要在根元素确定一个px字号，则可以来算出元素的宽高。本文讲的是如何使用rem实现自适应。 rem这是个低调的css单位，近一两年开始崭露头角，有许多同学对rem的评价不一，有的在尝试使用，有的在使用过程中遇到坑就弃用了。但是我对rem综合评价是用来做web app它绝对是最合适的人选之一。 rem是什么？ rem（font size of the root element）是指相对于根元素的字体大小的单位。简单的说它就是一个相对单位。看到rem大家一定会想起em单位，em（font size of the element）是指相对于父元素的字体大小的单位。它们之间其实很相似，只不过一个计算的规则是依赖根元素一个是依赖父元素计算。 rem能等比例适配所有屏幕 接下来讲下rem是如何工作的。上面说过rem是通过根元素进行适配的，网页中的根元素指的是html我们通过设置html的字体大小就可以控制rem的大小。举个例子： html{ font-size:20px; } .btn { width: 6rem; height: 3rem; line-height: 3rem; font-size: 1.2rem; display: inline-block; background: #06c; color: #fff; border-radius: .5rem; text-decoration: none; text-align: center; } Demo 上面代码结果按钮大小如下图： 我把html设置成10px是为了方便我们计算，为什么6rem等于60px。如果这个时候我们的.btn的样式不变，我们再改变html的font-size的值，看看按钮发生上面变化: html{ font-size:40px; } 结果按钮的大小发生了变化，大小如下： 上面的width，height变成了上面结果的两倍，我们只改变了html的font-size，但.btn样式的width,height的rem设置的属性不变的情况下就改变了按钮在web中的大小。 其实从上面两个案例中我们就可以计算出1px多少rem: 第一个例子： 120px = 6rem * 20px(根元素设置大值) 第二个例子： 240px = 6rem * 40px(根元素设置大值) 推算出： 10px = 1rem 在根元素（font-size = 10px的时候）； 20px = 1rem 在根元素（font-size = 20px的时候）； 40px = 1rem 在根元素（font-size = 40px的时候）； 我是通过JS去动态计算根元素的font-size，这样的好处是所有设备分辨率都能兼容适配，淘宝首页目前就是用的JS计算。但其实不用JS我们也可以做适配，一般我们在做webapp都会先统计自己网站有哪些主流的屏幕设备，然后去针对那些设备去做media query设置也可以实现适配，例如下面这样： html { font-size : 20px; } @media only screen and (min-width: 401px){ html { font-size: 25px !important; } } @media only screen and (min-width: 428px){ html { font-size: 26.75px !important; } } @media only screen and (min-width: 481px){ html { font-size: 30px !important; } } @media only screen and (min-width: 569px){ html { font-size: 35px !important; } } @media only screen and (min-width: 641px){ html { font-size: 40px !important; } } REM自适应JS//designWidth:设计稿的实际宽度值，需要根据实际设置 //maxWidth:制作稿的最大宽度值，需要根据实际设置 //这段js的最后面有两个参数记得要设置，一个为设计稿实际宽度，一个为制作稿最大宽度，例如设计稿为750，最大宽度为750，则为(750,750) ;(function(designWidth, maxWidth) { var doc = document, win = window, docEl = doc.documentElement, remStyle = document.createElement(&quot;style&quot;), tid; function refreshRem() { var width = docEl.getBoundingClientRect().width; maxWidth = maxWidth || 540; width&gt;maxWidth &amp;&amp; (width=maxWidth); var rem = width * 100 / designWidth; remStyle.innerHTML = &#39;html{font-size:&#39; + rem + &#39;px;}&#39;; } if (docEl.firstElementChild) { docEl.firstElementChild.appendChild(remStyle); } else { var wrap = doc.createElement(&quot;div&quot;); wrap.appendChild(remStyle); doc.write(wrap.innerHTML); wrap = null; } //要等 wiewport 设置好后才能执行 refreshRem，不然 refreshRem 会执行2次； refreshRem(); win.addEventListener(&quot;resize&quot;, function() { clearTimeout(tid); //防止执行两次 tid = setTimeout(refreshRem, 300); }, false); win.addEventListener(&quot;pageshow&quot;, function(e) { if (e.persisted) { // 浏览器后退的时候重新计算 clearTimeout(tid); tid = setTimeout(refreshRem, 300); } }, false); if (doc.readyState === &quot;complete&quot;) { doc.body.style.fontSize = &quot;16px&quot;; } else { doc.addEventListener(&quot;DOMContentLoaded&quot;, function(e) { doc.body.style.fontSize = &quot;16px&quot;; }, false); } })(750, 750);","content":"<ul>\n<li><p>摘要：rem是相对于根元素html，这样就意味着，我们只需要在根元素确定一个px字号，则可以来算出元素的宽高。本文讲的是如何使用rem实现自适应。</p>\n</li>\n<li><p>rem这是个低调的css单位，近一两年开始崭露头角，有许多同学对rem的评价不一，有的在尝试使用，有的在使用过程中遇到坑就弃用了。但是我对rem综合评价是用来做web app它绝对是最合适的人选之一。</p>\n</li>\n</ul>\n<h3 id=\"rem是什么？\"><a href=\"#rem是什么？\" class=\"headerlink\" title=\"rem是什么？\"></a>rem是什么？</h3><ul>\n<li>rem（font size of the root element）是指相对于根元素的字体大小的单位。简单的说它就是一个相对单位。看到rem大家一定会想起em单位，em（font size of the element）是指相对于父元素的字体大小的单位。它们之间其实很相似，只不过一个计算的规则是依赖根元素一个是依赖父元素计算。</li>\n</ul>\n<h3 id=\"rem能等比例适配所有屏幕\"><a href=\"#rem能等比例适配所有屏幕\" class=\"headerlink\" title=\"rem能等比例适配所有屏幕\"></a>rem能等比例适配所有屏幕</h3><ul>\n<li>接下来讲下rem是如何工作的。上面说过rem是通过根元素进行适配的，网页中的根元素指的是html我们通过设置html的字体大小就可以控制rem的大小。举个例子：</li>\n</ul>\n<pre><code class=\"bash\">\nhtml{\n    font-size:20px;\n}\n.btn {\n    width: 6rem;\n    height: 3rem;\n    line-height: 3rem;\n    font-size: 1.2rem;\n    display: inline-block;\n    background: #06c;\n    color: #fff;\n    border-radius: .5rem;\n    text-decoration: none;\n    text-align: center;    \n}\n</code></pre>\n<ul>\n<li>Demo 上面代码结果按钮大小如下图：</li>\n</ul>\n<p><img src=\"http://img.caibaojian.com/uploads/2015/12/1418899506.jpeg\" alt=\"图片\"></p>\n<ul>\n<li>我把html设置成10px是为了方便我们计算，为什么6rem等于60px。如果这个时候我们的.btn的样式不变，我们再改变html的font-size的值，看看按钮发生上面变化:</li>\n</ul>\n<pre><code>html{\n    font-size:40px;\n}\n</code></pre><ul>\n<li>结果按钮的大小发生了变化，大小如下：</li>\n</ul>\n<p><img src=\"http://img.caibaojian.com/uploads/2015/12/1418898055.jpeg\" alt=\"图片\"></p>\n<ul>\n<li><p>上面的width，height变成了上面结果的两倍，我们只改变了html的font-size，但.btn样式的width,height的rem设置的属性不变的情况下就改变了按钮在web中的大小。</p>\n</li>\n<li><p>其实从上面两个案例中我们就可以计算出1px多少rem:</p>\n</li>\n<li><p>第一个例子：</p>\n</li>\n<li><p>120px = 6rem * 20px(根元素设置大值)</p>\n</li>\n<li><p>第二个例子：</p>\n</li>\n<li><p>240px = 6rem * 40px(根元素设置大值)</p>\n</li>\n<li><p>推算出：</p>\n</li>\n<li><p>10px  = 1rem 在根元素（font-size = 10px的时候）；</p>\n</li>\n<li><p>20px  = 1rem 在根元素（font-size = 20px的时候）；</p>\n</li>\n<li><p>40px  = 1rem 在根元素（font-size = 40px的时候）；</p>\n</li>\n<li><p>我是通过JS去动态计算根元素的font-size，这样的好处是所有设备分辨率都能兼容适配，淘宝首页目前就是用的JS计算。但其实不用JS我们也可以做适配，一般我们在做webapp都会先统计自己网站有哪些主流的屏幕设备，然后去针对那些设备去做media query设置也可以实现适配，例如下面这样：</p>\n</li>\n</ul>\n<pre><code>html {\n    font-size : 20px;\n}\n@media only screen and (min-width: 401px){\n    html {\n        font-size: 25px !important;\n    }\n}\n@media only screen and (min-width: 428px){\n    html {\n        font-size: 26.75px !important;\n    }\n}\n@media only screen and (min-width: 481px){\n    html {\n        font-size: 30px !important; \n    }\n}\n@media only screen and (min-width: 569px){\n    html {\n        font-size: 35px !important; \n    }\n}\n@media only screen and (min-width: 641px){\n    html {\n        font-size: 40px !important; \n    }\n}\n</code></pre><h3 id=\"REM自适应JS\"><a href=\"#REM自适应JS\" class=\"headerlink\" title=\"REM自适应JS\"></a>REM自适应JS</h3><pre><code>//designWidth:设计稿的实际宽度值，需要根据实际设置\n//maxWidth:制作稿的最大宽度值，需要根据实际设置\n//这段js的最后面有两个参数记得要设置，一个为设计稿实际宽度，一个为制作稿最大宽度，例如设计稿为750，最大宽度为750，则为(750,750)\n;(function(designWidth, maxWidth) {\n    var doc = document,\n    win = window,\n    docEl = doc.documentElement,\n    remStyle = document.createElement(&quot;style&quot;),\n    tid;\n\n    function refreshRem() {\n        var width = docEl.getBoundingClientRect().width;\n        maxWidth = maxWidth || 540;\n        width&gt;maxWidth &amp;&amp; (width=maxWidth);\n        var rem = width * 100 / designWidth;\n        remStyle.innerHTML = &#39;html{font-size:&#39; + rem + &#39;px;}&#39;;\n    }\n\n    if (docEl.firstElementChild) {\n        docEl.firstElementChild.appendChild(remStyle);\n    } else {\n        var wrap = doc.createElement(&quot;div&quot;);\n        wrap.appendChild(remStyle);\n        doc.write(wrap.innerHTML);\n        wrap = null;\n    }\n    //要等 wiewport 设置好后才能执行 refreshRem，不然 refreshRem 会执行2次；\n    refreshRem();\n\n    win.addEventListener(&quot;resize&quot;, function() {\n        clearTimeout(tid); //防止执行两次\n        tid = setTimeout(refreshRem, 300);\n    }, false);\n\n    win.addEventListener(&quot;pageshow&quot;, function(e) {\n        if (e.persisted) { // 浏览器后退的时候重新计算\n            clearTimeout(tid);\n            tid = setTimeout(refreshRem, 300);\n        }\n    }, false);\n\n    if (doc.readyState === &quot;complete&quot;) {\n        doc.body.style.fontSize = &quot;16px&quot;;\n    } else {\n        doc.addEventListener(&quot;DOMContentLoaded&quot;, function(e) {\n            doc.body.style.fontSize = &quot;16px&quot;;\n        }, false);\n    }\n})(750, 750);\n</code></pre>","updated":"2018-04-24T10:03:26.000Z","comments":true,"link":"","categories":[{"name":"移动端自适应","slug":"移动端自适应","permalink":"http://yoursite.com/categories/移动端自适应/"}],"tags":[{"name":"H5,rem","slug":"H5-rem","permalink":"http://yoursite.com/tags/H5-rem/"}]},{"title":"HTML5实现刮奖效果","date":"2018-02-12T02:03:58.000Z","path":"2018/02/12/imgtransform/","text":"要实现刮奖效果，最重要的是要找到一种方法：当刮开上层的涂层是就能看到下层的结果。而HTML5的canvas API中有一个属性globalCompositeOperation，这个属性有多个值，而实现刮奖效果要用到的值就是destination-out。意思就是：在已有内容和新图形不重叠的地方，已有内容保留，所有其他内容成为透明。这样可能不好理解，后面实现的时候会解释。有了globalCompositeOperation这个属性，实现过程就很简单了。 我们需要有两个层，上面一层肯定是一个canvas元素，因为要能刮开就要用到画布。下面一层其实用什么元素都可以，既然上层用的是canvas元素，下层我们也用canvas元素，下面是html内容： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;刮刮乐&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;canvas id=&quot;underCanvas&quot; width=300 height=300 style=&quot;position: absolute; left: 0;top: 0;&quot;&gt;&lt;/canvas&gt; &lt;canvas id=&quot;upCanvas&quot; width=300 height=300 style=&quot;position: absolute; left: 0; top: 0;&quot;&gt;&lt;/canvas&gt; &lt;script src=&quot;./scratch.js&quot;&gt;&lt;/script&gt; &lt;script&gt; // 可能变化的值放在options中，方便修改 var options = { text: { fontWeight: &quot;bold&quot;, fontSize: 30, fontFamily: &quot;Arial&quot;, align: &quot;center&quot;, color: &#39;#F60&#39; }, maskColor: &quot;red&quot;, radius: 30, awards: [&quot;一等奖&quot;, &quot;二等奖&quot;, &quot;三等奖&quot;, &quot;谢谢！&quot;] }; new Scratch(options).init(); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 先实现一个构造函数： var Scratch = function (options) { // 下层画布元素 this.underCanvas = doc.getElementById(&quot;underCanvas&quot;); // 上层画布元素 this.upCanvas = doc.getElementById(&quot;upCanvas&quot;); // 获取下层画布绘图上下文 this.underCtx = this.underCanvas.getContext(&quot;2d&quot;); // 获取上层画布绘图上下文 this.upCtx = this.upCanvas.getContext(&quot;2d&quot;); // 画布宽度 this.width = this.upCanvas.width; // 画布高度 this.height = this.upCanvas.height; // 自定义选项 this.options = options; this.award = null; }; 在下层画布上画上刮奖的内容： drawText: function () { var ctx = this.underCtx; var text = this.options.text; ctx.font = text.fontWeight + &quot; &quot; + text.fontSize + &#39;px &#39; + text.fontFamily; ctx.textAlign = text.align; ctx.fillStyle = text.color; this.award = this.options.awards[(Math.random() * this.options.awards.length) | 0]; //随机抽奖 ctx.fillText(this.award, this.width / 2, this.height / 2 + text.fontSize / 2); } 这边奖的内容是随机出现的，因为奖肯定有很多种，可以用一个数组来存放奖的内容，然后随机显示 this.award = this.options.awards[(Math.random() * this.options.awards.length) | 0]; 然后在上层画布中画一层涂层： drawMask: function () { var ctx = this.upCtx; ctx.fillStyle = this.options.maskColor; ctx.fillRect(0, 0, this.width, this.height); ctx.globalCompositeOperation = &#39;destination-out&#39;; } 在上层画布中用了globalCompositeOperation这个属性，当再在画布上画东西时，那么后面画的内容和涂层重合的部分将变透明，而其余涂层部分不变。就是利用了这个原理实现了刮奖效果。 需要刮开上层的涂层，就需要在上层画布上绑定事件： addEvent: function () { var that = this; var upCanvas = this.upCanvas; var callback1, callback2, callback3; upCanvas.addEventListener(&quot;mousedown&quot;, callback1 = function (evt) { upCanvas.addEventListener(&quot;mousemove&quot;, callback2 = function (evt) { var x = evt.clientX - upCanvas.offsetLeft; var y = evt.clientY - upCanvas.offsetTop; var ctx = that.upCtx; var options = that.options; ctx.beginPath(); var gradient = ctx.createRadialGradient(x, y, 0, x, y, options.radius); // 其实这边的颜色值是可以随便写的，因为都会变成透明，重要的是透明度 gradient.addColorStop(0, &quot;rgba(255, 255, 255, 0.5)&quot;); gradient.addColorStop(1, &quot;rgba(255, 255, 255, 0)&quot;); // 也可以不用渐变，直接用一种颜色，但渐变效果更好 ctx.fillStyle = gradient; ctx.arc(x, y, options.radius, 0, Math.PI * 2, true); ctx.fill(); ctx.closePath(); // 当刮开部分&gt;80%的时候提醒刮奖结果，这个可以自己设置 if (that.result() &gt; 0.8) { alert(that.award); upCanvas.removeEventListener(&quot;mousemove&quot;, callback2); } }, false); doc.addEventListener(&quot;mouseup&quot;, callback3 = function () { upCanvas.removeEventListener(&quot;mousemove&quot;, callback2); doc.removeEventListener(&quot;mouseup&quot;, callback3); }, false); }, false); } 我们需要在刮到一定程度时提醒刮奖的结果: result: function () { // 获取文字部分的宽、高 var textWidth = this.options.text.fontSize * this.award.length; var textHeight = this.options.text.fontSize; // 获取文字部分的像素，这样可以根据刮开文字的部分占全部文字部分的百分比来提示结果， 比如说在刮开80%的时候提示刮奖结果 var imgData = this.upCtx.getImageData(this.width / 2 - textWidth / 2, this.height / 2 - textHeight / 2, textWidth, textHeight); var pixelsArr = imgData.data; var transPixelsArr = []; for (var i = 0, j = pixelsArr.length; i &lt; j; i += 4) { // a代表透明度 var a = pixelsArr[i + 3]; // 渐变的透明度＜=0.5，其实透明度的值是介于0~255之间的，0.5 * 255 = 127.5就是a的值 if (a &lt; 128) { transPixelsArr.push(a); } } // 小于128的透明度的值的个数占总透明度的的个数的百分比 return transPixelsArr.length / (pixelsArr.length / 4); } 上面用到了getImageData()方法，这个方法返回像素数据。重要的是我们只是获取了下层文字部分的像素数据，因为我们只需要知道刮开的文字部分占全部文字部分的百分比。 调用构造函数时，把可能改变的东西放在一个对象options中传递给构造函数： // 可能变化的值放在options中，方便修改 var options = { // 文字部分的样式 text: { fontWeight: &quot;bold&quot;, fontSize: 30, fontFamily: &quot;Arial&quot;, align: &quot;center&quot;, color: &#39;#F60&#39; }, // 图层颜色 maskColor: &quot;red&quot;, // 画逼半径 radius: 20, // 奖项 awards: [&quot;一等奖&quot;, &quot;二等奖&quot;, &quot;三等奖&quot;, &quot;谢谢！&quot;] }; new Scratch(options).init(); DEMO：http://lwzhang.github.io/scratch/scratch.html","content":"<ul>\n<li><p>要实现刮奖效果，最重要的是要找到一种方法：当刮开上层的涂层是就能看到下层的结果。而HTML5的canvas API中有一个属性globalCompositeOperation，这个属性有多个值，而实现刮奖效果要用到的值就是destination-out。意思就是：在已有内容和新图形不重叠的地方，已有内容保留，所有其他内容成为透明。这样可能不好理解，后面实现的时候会解释。有了globalCompositeOperation这个属性，实现过程就很简单了。</p>\n</li>\n<li><p>我们需要有两个层，上面一层肯定是一个canvas元素，因为要能刮开就要用到画布。下面一层其实用什么元素都可以，既然上层用的是canvas元素，下层我们也用canvas元素，下面是html内容：</p>\n</li>\n</ul>\n<pre><code class=\"bash\"> &lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot; /&gt;\n    &lt;title&gt;刮刮乐&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;canvas id=&quot;underCanvas&quot; width=300 height=300 style=&quot;position: absolute; left: 0;top: 0;&quot;&gt;&lt;/canvas&gt;\n    &lt;canvas id=&quot;upCanvas&quot; width=300 height=300 style=&quot;position: absolute; left: 0; top: 0;&quot;&gt;&lt;/canvas&gt;\n    &lt;script src=&quot;./scratch.js&quot;&gt;&lt;/script&gt;\n    &lt;script&gt;\n        // 可能变化的值放在options中，方便修改\n        var options = {\n            text: {\n                fontWeight: &quot;bold&quot;,\n                fontSize: 30,\n                fontFamily: &quot;Arial&quot;,\n                align: &quot;center&quot;,\n                color: &#39;#F60&#39;\n            },\n            maskColor: &quot;red&quot;,\n            radius: 30,\n            awards: [&quot;一等奖&quot;, &quot;二等奖&quot;, &quot;三等奖&quot;, &quot;谢谢！&quot;]\n        };\n\n        new Scratch(options).init();\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<ul>\n<li>先实现一个构造函数：</li>\n</ul>\n<pre><code class=\"bash\">    var Scratch = function (options) {\n    // 下层画布元素\n    this.underCanvas = doc.getElementById(&quot;underCanvas&quot;);\n    // 上层画布元素\n    this.upCanvas = doc.getElementById(&quot;upCanvas&quot;);\n    // 获取下层画布绘图上下文\n    this.underCtx = this.underCanvas.getContext(&quot;2d&quot;);\n    // 获取上层画布绘图上下文\n    this.upCtx = this.upCanvas.getContext(&quot;2d&quot;);\n       // 画布宽度\n    this.width = this.upCanvas.width;\n    // 画布高度\n    this.height = this.upCanvas.height;\n    // 自定义选项\n    this.options = options;\n    this.award = null;\n};\n</code></pre>\n<ul>\n<li>在下层画布上画上刮奖的内容：</li>\n</ul>\n<pre><code>drawText: function () {\n    var ctx = this.underCtx;\n    var text = this.options.text;\n    ctx.font = text.fontWeight + &quot; &quot; + text.fontSize + &#39;px &#39; + text.fontFamily;\n    ctx.textAlign = text.align;\n    ctx.fillStyle = text.color;\n    this.award = this.options.awards[(Math.random() * this.options.awards.length) | 0]; //随机抽奖\n    ctx.fillText(this.award, this.width / 2, this.height / 2 + text.fontSize / 2);\n}\n</code></pre><ul>\n<li>这边奖的内容是随机出现的，因为奖肯定有很多种，可以用一个数组来存放奖的内容，然后随机显示</li>\n</ul>\n<pre><code>this.award = this.options.awards[(Math.random() * this.options.awards.length) | 0];\n</code></pre><ul>\n<li>然后在上层画布中画一层涂层：</li>\n</ul>\n<pre><code>drawMask: function () {\n    var ctx = this.upCtx;\n    ctx.fillStyle = this.options.maskColor;\n    ctx.fillRect(0, 0, this.width, this.height);\n    ctx.globalCompositeOperation = &#39;destination-out&#39;;\n}\n</code></pre><ul>\n<li><p>在上层画布中用了globalCompositeOperation这个属性，当再在画布上画东西时，那么后面画的内容和涂层重合的部分将变透明，而其余涂层部分不变。就是利用了这个原理实现了刮奖效果。</p>\n</li>\n<li><p>需要刮开上层的涂层，就需要在上层画布上绑定事件：</p>\n</li>\n</ul>\n<pre><code>addEvent: function () {\n    var that = this;\n    var upCanvas = this.upCanvas;\n    var callback1, callback2, callback3;\n    upCanvas.addEventListener(&quot;mousedown&quot;, callback1 = function (evt) {\n        upCanvas.addEventListener(&quot;mousemove&quot;, callback2 = function (evt) {\n            var x = evt.clientX - upCanvas.offsetLeft;\n            var y = evt.clientY - upCanvas.offsetTop;\n            var ctx = that.upCtx;\n            var options = that.options;\n            ctx.beginPath();\n            var gradient = ctx.createRadialGradient(x, y, 0, x, y, options.radius);\n            // 其实这边的颜色值是可以随便写的，因为都会变成透明，重要的是透明度\n            gradient.addColorStop(0, &quot;rgba(255, 255, 255, 0.5)&quot;);\n            gradient.addColorStop(1, &quot;rgba(255, 255, 255, 0)&quot;);\n            // 也可以不用渐变，直接用一种颜色，但渐变效果更好\n            ctx.fillStyle = gradient;\n            ctx.arc(x, y, options.radius, 0, Math.PI * 2, true);\n            ctx.fill();\n            ctx.closePath();\n            // 当刮开部分&gt;80%的时候提醒刮奖结果，这个可以自己设置\n            if (that.result() &gt; 0.8) {\n                alert(that.award);\n                upCanvas.removeEventListener(&quot;mousemove&quot;, callback2);\n            }\n        }, false);\n        doc.addEventListener(&quot;mouseup&quot;, callback3 = function () {\n            upCanvas.removeEventListener(&quot;mousemove&quot;, callback2);\n            doc.removeEventListener(&quot;mouseup&quot;, callback3);\n        }, false);\n    }, false);\n}\n</code></pre><ul>\n<li>我们需要在刮到一定程度时提醒刮奖的结果:</li>\n</ul>\n<pre><code>result: function () {\n    // 获取文字部分的宽、高\n    var textWidth = this.options.text.fontSize * this.award.length;\n    var textHeight = this.options.text.fontSize;\n    // 获取文字部分的像素，这样可以根据刮开文字的部分占全部文字部分的百分比来提示结果，\n    比如说在刮开80%的时候提示刮奖结果\n    var imgData = this.upCtx.getImageData(this.width / 2 - textWidth / 2, \n    this.height / 2 - textHeight / 2, textWidth, textHeight);\n    var pixelsArr = imgData.data;\n    var transPixelsArr = [];\n    for (var i = 0, j = pixelsArr.length; i &lt; j; i += 4) {\n        // a代表透明度\n        var a = pixelsArr[i + 3];\n        // 渐变的透明度＜=0.5，其实透明度的值是介于0~255之间的，0.5 * 255 = 127.5就是a的值\n        if (a &lt; 128) {\n            transPixelsArr.push(a);\n        }\n    }\n    // 小于128的透明度的值的个数占总透明度的的个数的百分比\n    return transPixelsArr.length / (pixelsArr.length / 4);\n}\n</code></pre><ul>\n<li><p>上面用到了getImageData()方法，这个方法返回像素数据。重要的是我们只是获取了下层文字部分的像素数据，因为我们只需要知道刮开的文字部分占全部文字部分的百分比。</p>\n</li>\n<li><p>调用构造函数时，把可能改变的东西放在一个对象options中传递给构造函数：</p>\n</li>\n</ul>\n<pre><code>// 可能变化的值放在options中，方便修改\nvar options = {\n    // 文字部分的样式\n    text: {\n        fontWeight: &quot;bold&quot;,\n        fontSize: 30,\n        fontFamily: &quot;Arial&quot;,\n        align: &quot;center&quot;,\n        color: &#39;#F60&#39;\n    },\n    // 图层颜色\n    maskColor: &quot;red&quot;,\n    // 画逼半径\n    radius: 20,\n    // 奖项\n    awards: [&quot;一等奖&quot;, &quot;二等奖&quot;, &quot;三等奖&quot;, &quot;谢谢！&quot;]\n};\n\nnew Scratch(options).init();\n</code></pre><ul>\n<li>DEMO：<a href=\"http://lwzhang.github.io/scratch/scratch.html\">http://lwzhang.github.io/scratch/scratch.html</a></li>\n</ul>\n","updated":"2018-03-06T01:20:06.000Z","comments":true,"link":"","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://yoursite.com/categories/前端开发/"}],"tags":[{"name":"css3,canvas,HTML5","slug":"css3-canvas-HTML5","permalink":"http://yoursite.com/tags/css3-canvas-HTML5/"}]},{"title":"利用box-shadow制作loading图","date":"2018-02-12T02:03:58.000Z","path":"2018/02/12/loding/","text":"我们见过很多利用css3做的loading图，像下面这种应该是很常见的。通常制作这种loading，我们会一个标签对应一个圆，八个圆就要八个标签。但是这种做法很浪费资源。我们可以只用一个标签，然后利用box—shadow来制作一个loading图。 首先，需要一个标签： &lt;div class=&quot;loading&quot;&gt;&lt;/div&gt; 然后是css： $fontSize: 30px; $radius: 2em; .loading { font-size: $fontSize; width: 1em; height: 1em; border-radius: 50%; margin: 100px auto; box-shadow: 0 -2em rgba(255, 0, 0, 1), 1.414em -1.414em rgba(255, 0, 0, 0.875), 2em 0 rgba(255, 0, 0, 0.75), 1.414em 1.414em rgba(255, 0, 0, 0.625), 0 2em rgba(255, 0, 0, 0.5), -1.414em 1.414em rgba(255, 0, 0, 0.375), -2em 0 rgba(255, 0, 0, 0.25), -1.414em -1.414em rgba(255, 0, 0, 0.125); } 单位用的是em，这样如果要修改圆的大小，就只需要修改font-size就可以了，如果用px的话，一旦需要修改大小，那么涉及单位的就都要修改了。 box-shadow: 0 -2em rgba(255, 0, 0, 1), 1.414em -1.414em rgba(255, 0, 0, 0.875), 2em 0 rgba(255, 0, 0, 0.75), 1.414em 1.414em rgba(255, 0, 0, 0.625), 0 2em rgba(255, 0, 0, 0.5), -1.414em 1.414em rgba(255, 0, 0, 0.375), -2em 0 rgba(255, 0, 0, 0.25), -1.414em -1.414em rgba(255, 0, 0, 0.125); 需要用到多重阴影，每一个阴影就是一个圆了。设置它们的坐标需要用到三角函数。先要设定一个半径(如2em)，然后360度平均分成8份，每份是45度，利用三角函数就可以计算阴影的偏移位置了。还有就是圆的颜色渐变，就是设置它们的不同透明度。 上面做出来的是静态的，还需要让它动起来: $fontSize: 30px; $radius: 2em; .loading { font-size: $fontSize; width: 1em; height: 1em; border-radius: 50%; margin: 100px auto; box-shadow: 0 -2em rgba(255, 0, 0, 1), 1.414em -1.414em rgba(255, 0, 0, 0.875), 2em 0 rgba(255, 0, 0, 0.75), 1.414em 1.414em rgba(255, 0, 0, 0.625), 0 2em rgba(255, 0, 0, 0.5), -1.414em 1.414em rgba(255, 0, 0, 0.375), -2em 0 rgba(255, 0, 0, 0.25), -1.414em -1.414em rgba(255, 0, 0, 0.125); animation: rotate 1s infinite forwards steps(8, end); } @keyframes rotate { 100% { transform: rotate(360deg); } } steps()这个函数可以让动画分步进行，而不是连贯性的。 好了，上面就是全部的代码了，很少。上面的box-shadow其实我是手算的，本来我想利用sass的for循环计算的。","content":"<p>我们见过很多利用css3做的loading图，像下面这种应该是很常见的。通常制作这种loading，我们会一个标签对应一个圆，八个圆就要八个标签。但是这种做法很浪费资源。我们可以只用一个标签，然后利用box—shadow来制作一个loading图。</p>\n<ul>\n<li>首先，需要一个标签：</li>\n</ul>\n<pre><code class=\"bash\">&lt;div class=&quot;loading&quot;&gt;&lt;/div&gt;\n</code></pre>\n<ul>\n<li>然后是css：</li>\n</ul>\n<pre><code class=\"bash\">$fontSize: 30px;\n$radius: 2em;\n.loading {\nfont-size: $fontSize;\nwidth: 1em;\nheight: 1em;\nborder-radius: 50%;\nmargin: 100px auto;\nbox-shadow: 0 -2em rgba(255, 0, 0, 1), \n1.414em -1.414em rgba(255, 0, 0, 0.875), \n2em 0 rgba(255, 0, 0, 0.75), \n1.414em 1.414em rgba(255, 0, 0, 0.625), \n0 2em rgba(255, 0, 0, 0.5), \n-1.414em 1.414em rgba(255, 0, 0, 0.375), \n-2em 0 rgba(255, 0, 0, 0.25), \n-1.414em -1.414em rgba(255, 0, 0, 0.125);\n}\n</code></pre>\n<ul>\n<li>单位用的是em，这样如果要修改圆的大小，就只需要修改font-size就可以了，如果用px的话，一旦需要修改大小，那么涉及单位的就都要修改了。</li>\n</ul>\n<pre><code class=\"bash\">    box-shadow: 0 -2em rgba(255, 0, 0, 1), \n    1.414em -1.414em rgba(255, 0, 0, 0.875), \n    2em 0 rgba(255, 0, 0, 0.75), \n    1.414em 1.414em rgba(255, 0, 0, 0.625), \n    0 2em rgba(255, 0, 0, 0.5), \n    -1.414em 1.414em rgba(255, 0, 0, 0.375), \n    -2em 0 rgba(255, 0, 0, 0.25), \n    -1.414em -1.414em rgba(255, 0, 0, 0.125);\n</code></pre>\n<ul>\n<li><p>需要用到多重阴影，每一个阴影就是一个圆了。设置它们的坐标需要用到三角函数。先要设定一个半径(如2em)，然后360度平均分成8份，每份是45度，利用三角函数就可以计算阴影的偏移位置了。还有就是圆的颜色渐变，就是设置它们的不同透明度。</p>\n</li>\n<li><p>上面做出来的是静态的，还需要让它动起来:</p>\n</li>\n</ul>\n<pre><code class=\"bash\">$fontSize: 30px;\n$radius: 2em;\n\n.loading {\n  font-size: $fontSize;\n  width: 1em;\n  height: 1em;\n  border-radius: 50%;\n  margin: 100px auto;\n  box-shadow: 0 -2em rgba(255, 0, 0, 1), \n  1.414em -1.414em rgba(255, 0, 0, 0.875), \n  2em 0 rgba(255, 0, 0, 0.75), \n  1.414em 1.414em rgba(255, 0, 0, 0.625),\n   0 2em rgba(255, 0, 0, 0.5), \n   -1.414em 1.414em rgba(255, 0, 0, 0.375), \n   -2em 0 rgba(255, 0, 0, 0.25), \n   -1.414em -1.414em rgba(255, 0, 0, 0.125);\n\n  animation: rotate 1s infinite forwards steps(8, end);\n}\n\n@keyframes rotate {\n   100% {\n       transform: rotate(360deg);\n   }\n}\n</code></pre>\n<ul>\n<li><p>steps()这个函数可以让动画分步进行，而不是连贯性的。</p>\n</li>\n<li><p>好了，上面就是全部的代码了，很少。上面的box-shadow其实我是手算的，本来我想利用sass的for循环计算的。</p>\n</li>\n</ul>\n","updated":"2018-03-06T01:20:20.000Z","comments":true,"link":"","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://yoursite.com/categories/前端开发/"}],"tags":[{"name":"css3,loading","slug":"css3-loading","permalink":"http://yoursite.com/tags/css3-loading/"}]},{"title":"HTML5 canvas制作大风车","date":"2018-02-10T03:33:58.000Z","path":"2018/02/10/canvas/","text":"下面就来介绍制作风车的过程。先上代码吧： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;canvas id = &quot;canvas&quot; width=&quot;300&quot; height=&quot;300&quot;&gt;&lt;/canvas&gt; &lt;script&gt; (function () { var Pinwheel = function (canvas, options) { this.canvas = document.getElementById(canvas); this.options = options; }; Pinwheel.prototype = { constructor: Pinwheel, show: function () { var canvas = this.canvas,//取得canvas元素 width = canvas.width,//canvas元素的宽度 height = canvas.height,//canvas元素的高度 color = this.options.color,//风车叶子的颜色 radius = this.options.radius,//整个风车的半径 wheelRadius = this.options.wheelRadius,//风车叶子的半径 part = this.options.part,//PI/2分成几份 ctx = canvas.getContext(&quot;2d&quot;),//获取上下文 num = this.options.num,//叶子数量 center = {x: width / 2, y: height / 2},//绘图区域的中心 point, //叶子圆心位置 start = 0,//绘制叶子的开始角 angle = 0,//start = angle end = Math.PI,//绘制叶子的结束角 offset = Math.PI * (360 / num) / 180,//两个相邻叶子之间的角度 rotateAngle = offset / part;//每次旋转的角度 // window.timer = setInterval(function () { ctx.clearRect(0, 0, width, height); for (var i = 0; i &lt; num; i += 1) { ctx.beginPath();//开始绘制叶子 var wheelGradient = ctx.createRadialGradient(center.x, center.y, 100, center.x, center.y, 0);//创建径向渐变 wheelGradient.addColorStop(0, color[i]);//起始颜色 wheelGradient.addColorStop(1, &quot;#000&quot;);//结束颜色 ctx.fillStyle = wheelGradient;//填充渐变样式 point = {x: center.x + Math.cos(offset * i + angle) * radius, y: center.y + Math.sin(offset * i + angle) * radius};//叶子圆心位置 var x = start + offset * i;//绘制叶子的开始角 var y = end + offset * i;//绘制叶子的结束角 ctx.arc(point.x, point.y, wheelRadius, x, y, false);//绘制 ctx.fill();//填充 ctx.closePath();//结束绘制 } ctx.beginPath(); var dotGradient = ctx.createRadialGradient(center.x, center.y, 0, center.x, center.y, 40); dotGradient.addColorStop(0, &quot;#fff&quot;); dotGradient.addColorStop(1, &quot;#666&quot;); ctx.fillStyle = dotGradient; ctx.arc(center.x, center.y, 25, 0, 2 * Math.PI, false); ctx.fill(); ctx.closePath(); angle += rotateAngle; start = angle; end = Math.PI + angle; // }, 20) }, hide: function () { clearInterval(window.timer); } }; var options = { num: 4, color: [&quot;red&quot;, &quot;yellow&quot;, &quot;blue&quot;, &quot;green&quot;], radius: 50, wheelRadius: 50, part: 50 }; var a = new Pinwheel(&quot;canvas&quot;, options); a.show(); }()); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 首先，确定需要的各项参数： var canvas = this.canvas,//取得canvas元素 width = canvas.width,//canvas元素的宽度 height = canvas.height,//canvas元素的高度 color = this.options.color,//风车叶子的颜色 radius = this.options.radius,//整个风车的半径 wheelRadius = this.options.wheelRadius,//风车叶子的半径 part = this.options.part,//PI/2分成几份 ctx = canvas.getContext(&quot;2d&quot;),//获取上下文 num = this.options.num,//叶子数量 center = {x: width / 2, y: height / 2},//绘图区域的中心 point, //叶子圆心位置 start = 0,//绘制叶子的开始角 angle = 0,//start = angle end = Math.PI,//绘制叶子的结束角 offset = Math.PI * (360 / num) / 180,//两个相邻叶子之间的角度 rotateAngle = offset / part;//每次旋转的角度 循环绘制每个叶子： for (var i = 0; i &lt; num; i += 1) { ctx.beginPath();//开始绘制叶子 var wheelGradient = ctx.createRadialGradient(center.x, center.y, 100, center.x, center.y, 0); //创建径向渐变 wheelGradient.addColorStop(0, color[i]);//起始颜色 wheelGradient.addColorStop(1, &quot;#000&quot;);//结束颜色 ctx.fillStyle = wheelGradient;//填充渐变样式 point = {x: center.x + Math.cos(offset * i + angle) * radius, y: center.y + Math.sin(offset * i + angle) * radius};//叶子圆心位置 var x = start + offset * i;//绘制叶子的开始角 var y = end + offset * i;//绘制叶子的结束角 ctx.arc(point.x, point.y, wheelRadius, x, y, false);//绘制 ctx.fill();//填充 ctx.closePath();//结束绘制 } 绘制中间的大圆点： ctx.beginPath(); var dotGradient = ctx.createRadialGradient(center.x, center.y, 0, center.x, center.y, 40); dotGradient.addColorStop(0, &quot;#fff&quot;); dotGradient.addColorStop(1, &quot;#666&quot;); ctx.fillStyle = dotGradient; ctx.arc(center.x, center.y, 25, 0, 2 * Math.PI, false); ctx.fill(); ctx.closePath(); 上面的代码已经可以制作静态的风车了，但是我们要做的是动态的，于是我们需要一个计时器。下面是计时器代码： window.timer = setInterval(function () { ctx.clearRect(0, 0, width, height);//每次调用计时器需要重绘 for (var i = 0; i &lt; num; i += 1) { ctx.beginPath();//开始绘制叶子 var wheelGradient = ctx.createRadialGradient(center.x, center.y, 100, center.x, center.y, 0); //创建径向渐变 wheelGradient.addColorStop(0, color[i]);//起始颜色 wheelGradient.addColorStop(1, &quot;#000&quot;);//结束颜色 ctx.fillStyle = wheelGradient;//填充渐变样式 point = {x: center.x + Math.cos(offset * i + angle) * radius, y: center.y + Math.sin(offset * i + angle) * radius};//叶子圆心位置 var x = start + offset * i;//绘制叶子的开始角 var y = end + offset * i;//绘制叶子的结束角 ctx.arc(point.x, point.y, wheelRadius, x, y, false);//绘制 ctx.fill();//填充 ctx.closePath();//结束绘制 } ctx.beginPath(); var dotGradient = ctx.createRadialGradient(center.x, center.y, 0, center.x, center.y, 40); dotGradient.addColorStop(0, &quot;#fff&quot;); dotGradient.addColorStop(1, &quot;#666&quot;); ctx.fillStyle = dotGradient; ctx.arc(center.x, center.y, 25, 0, 2 * Math.PI, false); ctx.fill(); ctx.closePath(); angle += rotateAngle; start = angle; end = Math.PI + angle; }, 20) 动态的风车基本上就做完了，这是运行大风车代码： var options = { num: 4, color: [&quot;red&quot;, &quot;yellow&quot;, &quot;blue&quot;, &quot;green&quot;], radius: 50, wheelRadius: 50, part: 50 }; var a = new Pinwheel(&quot;canvas&quot;, options); a.show(); 修改options对象的属性就会改变风车的状态。 需要停止风车运转调用这个函数： hide: function () { clearInterval(window.timer); }","content":"<ul>\n<li>下面就来介绍制作风车的过程。先上代码吧：</li>\n</ul>\n<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;canvas id = &quot;canvas&quot; width=&quot;300&quot; height=&quot;300&quot;&gt;&lt;/canvas&gt;\n\n    &lt;script&gt;\n        (function () {\n            var Pinwheel = function (canvas, options) {\n                this.canvas = document.getElementById(canvas);\n                this.options = options;\n            };\n            Pinwheel.prototype = {\n                constructor: Pinwheel,\n                show: function () {\n                    var canvas = this.canvas,//取得canvas元素\n                            width = canvas.width,//canvas元素的宽度\n                            height = canvas.height,//canvas元素的高度\n                            color = this.options.color,//风车叶子的颜色\n                            radius = this.options.radius,//整个风车的半径\n                            wheelRadius = this.options.wheelRadius,//风车叶子的半径\n                            part = this.options.part,//PI/2分成几份\n                            ctx = canvas.getContext(&quot;2d&quot;),//获取上下文\n                            num = this.options.num,//叶子数量\n                            center = {x: width / 2, y: height / 2},//绘图区域的中心\n                            point, //叶子圆心位置\n                            start = 0,//绘制叶子的开始角\n                            angle = 0,//start = angle\n                            end = Math.PI,//绘制叶子的结束角\n                            offset = Math.PI * (360 / num) / 180,//两个相邻叶子之间的角度\n                            rotateAngle = offset / part;//每次旋转的角度\n//                    window.timer = setInterval(function () {\n                        ctx.clearRect(0, 0, width, height);\n                        for (var i = 0; i &lt; num; i += 1) {\n                            ctx.beginPath();//开始绘制叶子\n                            var wheelGradient = ctx.createRadialGradient(center.x, center.y,\n                             100, center.x, center.y, 0);//创建径向渐变\n                            wheelGradient.addColorStop(0, color[i]);//起始颜色\n                            wheelGradient.addColorStop(1, &quot;#000&quot;);//结束颜色\n                            ctx.fillStyle = wheelGradient;//填充渐变样式\n                            point = {x: center.x + Math.cos(offset * i + angle) * radius, \n                            y: center.y + Math.sin(offset * i + angle) * radius};//叶子圆心位置\n                            var x = start + offset * i;//绘制叶子的开始角\n                            var y = end + offset * i;//绘制叶子的结束角\n                            ctx.arc(point.x, point.y, wheelRadius, x, y, false);//绘制\n                            ctx.fill();//填充\n                            ctx.closePath();//结束绘制\n                        }\n                        ctx.beginPath();\n                        var dotGradient = ctx.createRadialGradient(center.x, center.y, 0, \n                        center.x, center.y, 40);\n                        dotGradient.addColorStop(0, &quot;#fff&quot;);\n                        dotGradient.addColorStop(1, &quot;#666&quot;);\n                        ctx.fillStyle = dotGradient;\n                        ctx.arc(center.x, center.y, 25, 0, 2 * Math.PI, false);\n                        ctx.fill();\n                        ctx.closePath();\n                        angle += rotateAngle;\n                        start = angle;\n                        end = Math.PI + angle;\n//                    }, 20)\n                },\n                hide: function () {\n                    clearInterval(window.timer);\n                }\n            };\n\n            var options = {\n                num: 4,\n                color: [&quot;red&quot;, &quot;yellow&quot;, &quot;blue&quot;, &quot;green&quot;],\n                radius: 50,\n                wheelRadius: 50,\n                part: 50\n            };\n\n            var a = new Pinwheel(&quot;canvas&quot;, options);\n            a.show();\n        }());\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre><ul>\n<li>首先，确定需要的各项参数：</li>\n</ul>\n<pre><code>var canvas = this.canvas,//取得canvas元素\nwidth = canvas.width,//canvas元素的宽度\nheight = canvas.height,//canvas元素的高度\ncolor = this.options.color,//风车叶子的颜色\nradius = this.options.radius,//整个风车的半径\nwheelRadius = this.options.wheelRadius,//风车叶子的半径\npart = this.options.part,//PI/2分成几份\nctx = canvas.getContext(&quot;2d&quot;),//获取上下文\nnum = this.options.num,//叶子数量\ncenter = {x: width / 2, y: height / 2},//绘图区域的中心\npoint, //叶子圆心位置\nstart = 0,//绘制叶子的开始角\nangle = 0,//start = angle\nend = Math.PI,//绘制叶子的结束角\noffset = Math.PI * (360 / num) / 180,//两个相邻叶子之间的角度\nrotateAngle = offset / part;//每次旋转的角度\n</code></pre><ul>\n<li>循环绘制每个叶子：</li>\n</ul>\n<pre><code>for (var i = 0; i &lt; num; i += 1) {\n　　ctx.beginPath();//开始绘制叶子\n　　var wheelGradient = ctx.createRadialGradient(center.x, center.y, 100, center.x, center.y, 0);\n//创建径向渐变\n　　wheelGradient.addColorStop(0, color[i]);//起始颜色\n　　wheelGradient.addColorStop(1, &quot;#000&quot;);//结束颜色\n　　ctx.fillStyle = wheelGradient;//填充渐变样式\n　　point = {x: center.x + Math.cos(offset * i + angle) * radius,\n y: center.y + Math.sin(offset * i + angle) * radius};//叶子圆心位置\n　　var x = start + offset * i;//绘制叶子的开始角\n　　var y = end + offset * i;//绘制叶子的结束角\n　　ctx.arc(point.x, point.y, wheelRadius, x, y, false);//绘制\n　　ctx.fill();//填充\n　　ctx.closePath();//结束绘制\n}\n</code></pre><ul>\n<li>绘制中间的大圆点：</li>\n</ul>\n<pre><code>ctx.beginPath();\nvar dotGradient = ctx.createRadialGradient(center.x, center.y, 0, center.x, center.y, 40);\ndotGradient.addColorStop(0, &quot;#fff&quot;);\ndotGradient.addColorStop(1, &quot;#666&quot;);\nctx.fillStyle = dotGradient;\nctx.arc(center.x, center.y, 25, 0, 2 * Math.PI, false);\nctx.fill();\nctx.closePath();\n</code></pre><ul>\n<li>上面的代码已经可以制作静态的风车了，但是我们要做的是动态的，于是我们需要一个计时器。下面是计时器代码：</li>\n</ul>\n<pre><code>\nwindow.timer = setInterval(function () {\n　　　　ctx.clearRect(0, 0, width, height);//每次调用计时器需要重绘\n　　　　for (var i = 0; i &lt; num; i += 1) {\n　　　　　　ctx.beginPath();//开始绘制叶子\n　　　　　　var wheelGradient = ctx.createRadialGradient(center.x, center.y, 100, center.x, center.y, 0);\n//创建径向渐变\n　　　　　　wheelGradient.addColorStop(0, color[i]);//起始颜色\n　　　　　　wheelGradient.addColorStop(1, &quot;#000&quot;);//结束颜色\n　　　　　　ctx.fillStyle = wheelGradient;//填充渐变样式\n　　　　　　point = {x: center.x + Math.cos(offset * i + angle) * radius, \n    y: center.y + Math.sin(offset * i + angle) * radius};//叶子圆心位置\n　　　　　　var x = start + offset * i;//绘制叶子的开始角\n　　　　　　var y = end + offset * i;//绘制叶子的结束角\n　　　　　　ctx.arc(point.x, point.y, wheelRadius, x, y, false);//绘制\n　　　　　　ctx.fill();//填充\n　　　　　　ctx.closePath();//结束绘制\n　　　　}\n　　　　ctx.beginPath();\n　　　　var dotGradient = ctx.createRadialGradient(center.x, center.y, 0, center.x, center.y, 40);\n　　　　dotGradient.addColorStop(0, &quot;#fff&quot;);\n　　　　dotGradient.addColorStop(1, &quot;#666&quot;);\n　　　　ctx.fillStyle = dotGradient;\n　　　　ctx.arc(center.x, center.y, 25, 0, 2 * Math.PI, false);\n　　　　ctx.fill();\n　　　　ctx.closePath();\n　　　　angle += rotateAngle;\n　　　　start = angle;\n　　　　end = Math.PI + angle;\n　　}, 20)\n</code></pre><ul>\n<li>动态的风车基本上就做完了，这是运行大风车代码：</li>\n</ul>\n<pre><code>var options = {\n　　num: 4,\n　　color: [&quot;red&quot;, &quot;yellow&quot;, &quot;blue&quot;, &quot;green&quot;],\n　　radius: 50,\n　　wheelRadius: 50,\n　　part: 50\n　　};\nvar a = new Pinwheel(&quot;canvas&quot;, options);\na.show();\n</code></pre><ul>\n<li><p>修改options对象的属性就会改变风车的状态。</p>\n</li>\n<li><p>需要停止风车运转调用这个函数：</p>\n</li>\n</ul>\n<pre><code>    hide: function () {\n　　clearInterval(window.timer);\n    }\n</code></pre>","updated":"2018-03-06T01:18:40.000Z","comments":true,"link":"","categories":[{"name":"canvas","slug":"canvas","permalink":"http://yoursite.com/categories/canvas/"}],"tags":[{"name":"canvas","slug":"canvas","permalink":"http://yoursite.com/tags/canvas/"}]},{"title":"自适应网站与响应式网站的区别","date":"2018-02-07T02:05:17.000Z","path":"2018/02/07/qianduan/","text":"对于自适应网站与响应式网站的区别，我想很多人都会有所误解。误以为两者是无区别的。但是如果你在网站的体验过程中，你会发现有许多细微的区别。从网站建设的角度来讲自适应网站建设也是响应式网站建设，响应式网站建设也是自适应网站建设。但是真正的细分起来，自适应网站只是响应式网站的一个子集。要分出一个网站他是响应式还是自适应。 你要先了解什么是响应式布局与自适应布局。 响应式网站设计优势：一个网站兼容多个不同终端，易于搜索推广优化，方便管理和维护. 1、灵活性强，可以适应不同分辨率的设备 2、方便快捷的解决多设备显示适应问题 自适应网页设计优势：固定断点的网站适合自适应网页设计 . 1、实施起来代价更低，测试更容易 2、自适应布局可以让设计更加可控，因为它只需要考虑几种状态就可以了 响应式布局简而言之就是一个网站能够兼容多个终端，而不是为每个终端做一个特定的版本。在这里大家可以理解为做一个网站就能适应多种设备，而不用在为每个设备做一个特定的版本，在不同的设备上展现的模式也不一样。响应式可以为不同终端的用户提供更舒适的界面和更好的浏览体验。 自适应布局指能使网页自适应显示在不同大小终端设备上新网页设计方式及技术。大家可以理解为不同大小的设备上呈现同样的页面，让同一个页面适应不同大小屏幕，根据屏幕的大小，自动调整布局。那制作网站的时候“什么样的网站适合使用自适应布局？什么样的网站适合响应式布局？理论上来说，响应式布局在任何情况下都比自适应布局好一些，但在某些情况下自适应布局更切实际。自适应布局可以让你的设计更加可控，因为你只需要考虑了了几种状态就万事大吉了。但在响应式布局中你可能需要面对非常多状态——是的，大部分状态之间的区别很小，但它们又的确是不同的——这样一来就很难确切搞清你的设计会是什么样。同时这也带来了测试上的难题，你很难有绝对的把握预测到它会怎样。换个角度说，这也是响应式布局的魅力所在。","content":"<p><img src=\"http://www.shenliyang.com/wp-content/uploads/2016/11/119b00082c6b91dfc497.gif\" alt=\"图片\"></p>\n<p>对于自适应网站与响应式网站的区别，我想很多人都会有所误解。误以为两者是无区别的。但是如果你在网站的体验过程中，你会发现有许多细微的区别。从网站建设的角度来讲自适应网站建设也是响应式网站建设，响应式网站建设也是自适应网站建设。但是真正的细分起来，自适应网站只是响应式网站的一个子集。要分出一个网站他是响应式还是自适应。</p>\n<p>你要先了解什么是响应式布局与自适应布局。</p>\n<p><strong> 响应式网站设计优势：一个网站兼容多个不同终端，易于搜索推广优化，方便管理和维护. </strong></p>\n<p>1、灵活性强，可以适应不同分辨率的设备</p>\n<p>2、方便快捷的解决多设备显示适应问题</p>\n<p><strong>自适应网页设计优势：固定断点的网站适合自适应网页设计   .</strong></p>\n<p>1、实施起来代价更低，测试更容易</p>\n<p>2、自适应布局可以让设计更加可控，因为它只需要考虑几种状态就可以了</p>\n<ul>\n<li><p>响应式布局简而言之就是一个网站能够兼容多个终端，而不是为每个终端做一个特定的版本。在这里大家可以理解为做一个网站就能适应多种设备，而不用在为每个设备做一个特定的版本，在不同的设备上展现的模式也不一样。响应式可以为不同终端的用户提供更舒适的界面和更好的浏览体验。</p>\n</li>\n<li><p>自适应布局指能使网页自适应显示在不同大小终端设备上新网页设计方式及技术。大家可以理解为不同大小的设备上呈现同样的页面，让同一个页面适应不同大小屏幕，根据屏幕的大小，自动调整布局。那制作网站的时候“什么样的网站适合使用自适应布局？什么样的网站适合响应式布局？理论上来说，响应式布局在任何情况下都比自适应布局好一些，但在某些情况下自适应布局更切实际。自适应布局可以让你的设计更加可控，因为你只需要考虑了了几种状态就万事大吉了。但在响应式布局中你可能需要面对非常多状态——是的，大部分状态之间的区别很小，但它们又的确是不同的——这样一来就很难确切搞清你的设计会是什么样。同时这也带来了测试上的难题，你很难有绝对的把握预测到它会怎样。换个角度说，这也是响应式布局的魅力所在。</p>\n</li>\n</ul>\n","updated":"2020-05-11T03:12:40.234Z","comments":true,"link":"","categories":[{"name":"移动端自适应","slug":"移动端自适应","permalink":"http://yoursite.com/categories/移动端自适应/"}],"tags":[{"name":"rem","slug":"rem","permalink":"http://yoursite.com/tags/rem/"}]},{"title":"关于小程序上拉加载更多...","date":"2018-02-07T02:03:58.000Z","path":"2018/02/07/wacharts/","text":"loadmore加载更多(使用分页加载)当用户打开一个页面时，假设后台数据量庞大时，一次性地返回所有数据给客户端，页面的打开速度就会有所下降，而且用户只看上面的内容而不需要看后面的内容时，也浪费用户流量，基于优化的角度来考虑，后台不要一次性返回所有数据，当用户有需要再往下翻的时候，再加载更加数据出来。 业务需求列表滚动到底部时，继续往上拉，加载更多内容 必备参数 pageindex: 1 //第几次加载 callbackcount: 15 //需要返回数据的个数 实现原理当第一次访问接口时，传递2个必备参数（第1次加载，需要返回数据的个数为15个），和其他参数（需要搜索的字符串）给后台，后台返回第一次数据过来。在请求成功的的回调函数中，判断返回的数据是否&gt;0，是，则取出数据，渲染视图层，并把“上拉加载”显示在列表底部；否，则没有数据可取，并把“没有更多”显示在列表底部，同时把“上拉加载”隐藏掉。 当用户已经滚动到列表底部（这里使用到小程序提供的scroll-view组件的bindscrolltolower事件），触发bindscrolltolower事件，参数pageindex+1，再把2个必备参数（第2次加载，需要返回数据的个数为15个）和其他参数（需要搜索的字符串）给后台，后台把其余的数据返回给前台，前台在原来数据的基础上添加数据。 示例wxml: &lt;view class=&quot;search&quot;&gt; &lt;view class=&quot;search-bar&quot;&gt; &lt;view class=&quot;search-wrap&quot;&gt; &lt;icon type=&quot;search&quot; size=&quot;16&quot; class=&quot;icon-search&quot; /&gt; &lt;input type=&quot;text&quot; placeholder=&quot;请输入搜索内容&quot; class=&quot;search-input&quot; name=&quot;searchKeyword&quot; bindinput=&quot;bindKeywordInput&quot; value=&quot;{{searchKeyword}}&quot; /&gt; &lt;/view&gt; &lt;view class=&quot;search-cancel&quot; bindtap=&quot;keywordSearch&quot;&gt;搜索&lt;/view&gt; &lt;/view&gt; &lt;view class=&quot;search-result&quot;&gt; &lt;scroll-view scroll-y=&quot;true&quot; bindscrolltolower=&quot;searchScrollLower&quot;&gt; &lt;view class=&quot;result-item&quot; wx:for=&quot;{{searchSongList}}&quot; wx:key=&quot;unique&quot; data-data=&quot;{{item}}&quot; &gt; &lt;view class=&quot;icon{{item.isonly=='0' ? ' nocopyright' : ''}}&quot;&gt;&lt;/view&gt; &lt;text class=&quot;title&quot;&gt;{{item.songname}}&lt;/text&gt; &lt;view class=&quot;subtitle&quot;&gt; &lt;text wx:for=&quot;{{item.singer}}&quot; wx:key=&quot;unique&quot;&gt;{{item.name}}&lt;/text&gt; &lt;/view&gt; &lt;/view&gt; &lt;view class=&quot;loading&quot; hidden=&quot;{{!searchLoading}}&quot;&gt;正在载入更多...&lt;/view&gt; &lt;view class=&quot;loading complete&quot; hidden=&quot;{{!searchLoadingComplete}}&quot;&gt;已加载全部&lt;/view&gt; &lt;/scroll-view&gt; &lt;/view&gt; &lt;/view&gt; js: var util = require(&#39;../../utils/util.js&#39;) Page({ data: { searchKeyword: &#39;&#39;, //需要搜索的字符 searchSongList: [], //放置返回数据的数组 isFromSearch: true, // 用于判断searchSongList数组是不是空数组，默认true，空的数组 searchPageNum: 1, // 设置加载的第几次，默认是第一次 callbackcount: 15, //返回数据的个数 searchLoading: false, //&quot;上拉加载&quot;的变量，默认false，隐藏 searchLoadingComplete: false //“没有数据”的变量，默认false，隐藏 }, //输入框事件，每输入一个字符，就会触发一次 bindKeywordInput: function(e){ console.log(&quot;输入框事件&quot;) this.setData({ searchKeyword: e.detail.value }) }, //搜索，访问网络 fetchSearchList: function(){ let that = this; let searchKeyword = that.data.searchKeyword,//输入框字符串作为参数 searchPageNum = that.data.searchPageNum,//把第几次加载次数作为参数 callbackcount =that.data.callbackcount; //返回数据的个数 //访问网络 util.getSearchMusic(searchKeyword, searchPageNum,callbackcount, function(data){ console.log(data) //判断是否有数据，有则取数据 if(data.data.song.curnum != 0){ let searchList = []; //如果isFromSearch是true从data中取出数据，否则先从原来的数据继续添加 that.data.isFromSearch ? searchList=data.data.song.list : searchList=that.data.searchSongList.concat(data.data.song.list) that.setData({ searchSongList: searchList, //获取数据数组 zhida: data.data.zhida, //存放歌手属性的对象 searchLoading: true //把&quot;上拉加载&quot;的变量设为false，显示 }); //没有数据了，把“没有数据”显示，把“上拉加载”隐藏 }else{ that.setData({ searchLoadingComplete: true, //把“没有数据”设为true，显示 searchLoading: false //把&quot;上拉加载&quot;的变量设为false，隐藏 }); } }) }, //点击搜索按钮，触发事件 keywordSearch: function(e){ this.setData({ searchPageNum: 1, //第一次加载，设置1 searchSongList:[], //放置返回数据的数组,设为空 isFromSearch: true, //第一次加载，设置true searchLoading: true, //把&quot;上拉加载&quot;的变量设为true，显示 searchLoadingComplete:false //把“没有数据”设为false，隐藏 }) this.fetchSearchList(); }, //滚动到底部触发事件 searchScrollLower: function(){ let that = this; if(that.data.searchLoading &amp;&amp; !that.data.searchLoadingComplete){ that.setData({ searchPageNum: that.data.searchPageNum+1, //每次触发上拉事件，把searchPageNum+1 isFromSearch: false //触发到上拉事件，把isFromSearch设为为false }); that.fetchSearchList(); } } }) uilt.js: function getSearchMusic(keyword, pageindex, callbackcount, callback){ wx.request({ url: &#39;https://c.y.qq.com/soso/fcgi-bin/search_for_qq_cp&#39;, data: { g_tk: 5381, uin: 0, format: &#39;json&#39;, inCharset: &#39;utf-8&#39;, outCharset: &#39;utf-8&#39;, notice: 0, platform: &#39;h5&#39;, needNewCode: 1, w: keyword, zhidaqu: 1, catZhida: 1, t: 0, flag: 1, ie: &#39;utf-8&#39;, sem: 1, aggr: 0, perpage: 20, n: callbackcount, //返回数据的个数 p: pageindex, remoteplace: &#39;txt.mqq.all&#39;, _: Date.now() }, method: &#39;GET&#39;, header: {&#39;content-Type&#39;: &#39;application/json&#39;}, success: function(res){ if(res.statusCode == 200){ callback(res.data); } } }) } module.exports = { getSearchMusic: getSearchMusic } wxss: page{ display: flex; flex-direction: column; height: 100%; } /*搜索*/ .search{ flex: auto; display: flex; flex-direction: column; background: #fff; } .search-bar{ flex: none; display: flex; align-items: center; justify-content: space-between; padding: 20rpx; background: #f4f4f4; } .search-wrap{ position: relative; flex: auto; display: flex; align-items: center; height: 80rpx; padding: 0 20rpx; background: #fff; border-radius: 6rpx; } .search-wrap .icon-search{ margin-right: 10rpx; } .search-wrap .search-input{ flex: auto; font-size: 28rpx; } .search-cancel{ padding: 0 20rpx; font-size: 28rpx; } /*搜索结果*/ .search-result{ flex: auto; position: relative; } .search-result scroll-view{ position: absolute; bottom: 0; left: 0; right: 0; top: 0; } .result-item{ position: relative; display: flex; flex-direction: column; padding: 20rpx 0 20rpx 110rpx; overflow: hidden; border-bottom: 2rpx solid #e5e5e5; } .result-item .media{ position: absolute; left: 16rpx; top: 16rpx; width: 80rpx; height: 80rpx; border-radius: 999rpx; } .result-item .title, .result-item .subtitle{ overflow: hidden; text-overflow: ellipsis; white-space: nowrap; line-height: 36rpx; } .result-item .title{ margin-bottom: 4rpx; color: #000; } .result-item .subtitle{ color: #808080; font-size: 24rpx; } .result-item:first-child .subtitle text{ margin-right: 20rpx; } .result-item:not(:first-child) .subtitle text:not(:first-child):before{ content: &#39;/&#39;; margin: 0 8rpx; } .loading{ padding: 10rpx; text-align: center; } .loading:before{ display: inline-block; margin-right: 5rpx; vertical-align: middle; content: &#39;&#39;; width: 40rpx; height: 40rpx; background: url(../../images/icon-loading.png) no-repeat; background-size: contain; animation: rotate 1s linear infinite; } .loading.complete:before{ display: none; } 运行： 说明：此文章转载于微信小程序之加载更多（分页加载）实例 —— 微信小程序实战系列（2）","content":"<h2 id=\"loadmore加载更多-使用分页加载\"><a href=\"#loadmore加载更多-使用分页加载\" class=\"headerlink\" title=\"loadmore加载更多(使用分页加载)\"></a>loadmore加载更多(使用分页加载)</h2><p>当用户打开一个页面时，假设后台数据量庞大时，一次性地返回所有数据给客户端，页面的打开速度就会有所下降，而且用户只看上面的内容而不需要看后面的内容时，也浪费用户流量，基于优化的角度来考虑，后台不要一次性返回所有数据，当用户有需要再往下翻的时候，再加载更加数据出来。</p>\n<h2 id=\"业务需求\"><a href=\"#业务需求\" class=\"headerlink\" title=\"业务需求\"></a>业务需求</h2><p>列表滚动到底部时，继续往上拉，加载更多内容</p>\n<h2 id=\"必备参数\"><a href=\"#必备参数\" class=\"headerlink\" title=\"必备参数\"></a>必备参数</h2><ul>\n<li>pageindex: 1 //第几次加载</li>\n<li>callbackcount: 15 //需要返回数据的个数</li>\n</ul>\n<h2 id=\"实现原理\"><a href=\"#实现原理\" class=\"headerlink\" title=\"实现原理\"></a>实现原理</h2><p>当第一次访问接口时，传递2个必备参数（第1次加载，需要返回数据的个数为15个），和其他参数（需要搜索的字符串）给后台，后台返回第一次数据过来。在请求成功的的回调函数中，判断返回的数据是否&gt;0，是，则取出数据，渲染视图层，并把“上拉加载”显示在列表底部；否，则没有数据可取，并把“没有更多”显示在列表底部，同时把“上拉加载”隐藏掉。</p>\n<p>当用户已经滚动到列表底部（这里使用到小程序提供的scroll-view组件的bindscrolltolower事件），触发bindscrolltolower事件，参数pageindex+1，再把2个必备参数（第2次加载，需要返回数据的个数为15个）和其他参数（需要搜索的字符串）给后台，后台把其余的数据返回给前台，前台在原来数据的基础上添加数据。</p>\n<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><p>wxml:</p>\n<pre><code>&lt;view class=&quot;search&quot;&gt;  \n  &lt;view class=&quot;search-bar&quot;&gt;  \n    &lt;view class=&quot;search-wrap&quot;&gt;  \n        &lt;icon type=&quot;search&quot; size=&quot;16&quot; class=&quot;icon-search&quot; /&gt;  \n        &lt;input type=&quot;text&quot; placeholder=&quot;请输入搜索内容&quot; class=&quot;search-input&quot;\n         name=&quot;searchKeyword&quot; bindinput=&quot;bindKeywordInput&quot; value=&quot;{{searchKeyword}}&quot; /&gt;  \n    &lt;/view&gt;  \n    &lt;view class=&quot;search-cancel&quot; bindtap=&quot;keywordSearch&quot;&gt;搜索&lt;/view&gt;  \n  &lt;/view&gt;  \n  &lt;view class=&quot;search-result&quot;&gt;  \n    &lt;scroll-view scroll-y=&quot;true&quot; bindscrolltolower=&quot;searchScrollLower&quot;&gt;  \n      &lt;view class=&quot;result-item&quot; wx:for=&quot;{{searchSongList}}&quot; wx:key=&quot;unique&quot;  \n      data-data=&quot;{{item}}&quot; &gt;  \n        &lt;view class=&quot;icon{{item.isonly=='0' ? ' nocopyright' : ''}}&quot;&gt;&lt;/view&gt;  \n        &lt;text class=&quot;title&quot;&gt;{{item.songname}}&lt;/text&gt;  \n        &lt;view class=&quot;subtitle&quot;&gt;  \n          &lt;text wx:for=&quot;{{item.singer}}&quot; wx:key=&quot;unique&quot;&gt;{{item.name}}&lt;/text&gt;  \n        &lt;/view&gt;  \n      &lt;/view&gt;  \n      &lt;view class=&quot;loading&quot; hidden=&quot;{{!searchLoading}}&quot;&gt;正在载入更多...&lt;/view&gt;  \n      &lt;view class=&quot;loading complete&quot; hidden=&quot;{{!searchLoadingComplete}}&quot;&gt;已加载全部&lt;/view&gt;  \n    &lt;/scroll-view&gt;    \n  &lt;/view&gt;  \n&lt;/view&gt;\n</code></pre><p>js:</p>\n<pre><code>var util = require(&#39;../../utils/util.js&#39;)  \nPage({  \n  data: {  \n    searchKeyword: &#39;&#39;,  //需要搜索的字符  \n    searchSongList: [], //放置返回数据的数组  \n    isFromSearch: true,   // 用于判断searchSongList数组是不是空数组，默认true，空的数组  \n    searchPageNum: 1,   // 设置加载的第几次，默认是第一次  \n    callbackcount: 15,      //返回数据的个数  \n    searchLoading: false, //&quot;上拉加载&quot;的变量，默认false，隐藏  \n    searchLoadingComplete: false  //“没有数据”的变量，默认false，隐藏  \n  },  \n  //输入框事件，每输入一个字符，就会触发一次  \n  bindKeywordInput: function(e){  \n    console.log(&quot;输入框事件&quot;)  \n    this.setData({  \n      searchKeyword: e.detail.value  \n    })  \n  },  \n  //搜索，访问网络  \n  fetchSearchList: function(){  \n    let that = this;  \n    let searchKeyword = that.data.searchKeyword,//输入框字符串作为参数  \n        searchPageNum = that.data.searchPageNum,//把第几次加载次数作为参数  \n        callbackcount =that.data.callbackcount; //返回数据的个数  \n    //访问网络  \n    util.getSearchMusic(searchKeyword, searchPageNum,callbackcount, \n      function(data){  \n      console.log(data)  \n      //判断是否有数据，有则取数据  \n      if(data.data.song.curnum != 0){  \n        let searchList = [];  \n        //如果isFromSearch是true从data中取出数据，否则先从原来的数据继续添加  \n        that.data.isFromSearch ? searchList=data.data.song.list :\n        searchList=that.data.searchSongList.concat(data.data.song.list)  \n        that.setData({  \n          searchSongList: searchList, //获取数据数组  \n          zhida: data.data.zhida, //存放歌手属性的对象  \n          searchLoading: true   //把&quot;上拉加载&quot;的变量设为false，显示  \n        });  \n      //没有数据了，把“没有数据”显示，把“上拉加载”隐藏  \n      }else{  \n        that.setData({  \n          searchLoadingComplete: true, //把“没有数据”设为true，显示  \n          searchLoading: false  //把&quot;上拉加载&quot;的变量设为false，隐藏  \n        });  \n      }  \n    })  \n  },  \n  //点击搜索按钮，触发事件  \n  keywordSearch: function(e){  \n    this.setData({    \n      searchPageNum: 1,   //第一次加载，设置1  \n      searchSongList:[],  //放置返回数据的数组,设为空  \n      isFromSearch: true,  //第一次加载，设置true  \n      searchLoading: true,  //把&quot;上拉加载&quot;的变量设为true，显示  \n      searchLoadingComplete:false //把“没有数据”设为false，隐藏  \n    })  \n    this.fetchSearchList();  \n  },  \n  //滚动到底部触发事件  \n  searchScrollLower: function(){  \n    let that = this;  \n    if(that.data.searchLoading &amp;&amp; !that.data.searchLoadingComplete){  \n      that.setData({  \n        searchPageNum: that.data.searchPageNum+1,  //每次触发上拉事件，把searchPageNum+1  \n        isFromSearch: false  //触发到上拉事件，把isFromSearch设为为false  \n      });  \n      that.fetchSearchList();  \n    }  \n  }  \n})\n</code></pre><p>uilt.js:</p>\n<pre><code>function getSearchMusic(keyword, pageindex, callbackcount, callback){  \n  wx.request({  \n    url: &#39;https://c.y.qq.com/soso/fcgi-bin/search_for_qq_cp&#39;,  \n    data: {  \n      g_tk: 5381,  \n      uin: 0,  \n      format: &#39;json&#39;,  \n      inCharset: &#39;utf-8&#39;,  \n      outCharset: &#39;utf-8&#39;,  \n      notice: 0,  \n      platform: &#39;h5&#39;,  \n      needNewCode: 1,  \n      w: keyword,  \n      zhidaqu: 1,  \n      catZhida: 1,  \n      t: 0,  \n      flag: 1,  \n      ie: &#39;utf-8&#39;,  \n      sem: 1,  \n      aggr: 0,  \n      perpage: 20,  \n      n: callbackcount,  //返回数据的个数  \n      p: pageindex,  \n      remoteplace: &#39;txt.mqq.all&#39;,  \n      _: Date.now()  \n    },  \n    method: &#39;GET&#39;,  \n    header: {&#39;content-Type&#39;: &#39;application/json&#39;},  \n    success: function(res){  \n      if(res.statusCode == 200){  \n        callback(res.data);  \n      }  \n    }  \n  })  \n}  \n\nmodule.exports = {  \n  getSearchMusic: getSearchMusic  \n}\n</code></pre><p>wxss:</p>\n<pre><code>page{  \n  display: flex;  \n  flex-direction: column;  \n  height: 100%;  \n}  \n\n/*搜索*/  \n.search{  \n  flex: auto;  \n  display: flex;  \n  flex-direction: column;  \n  background: #fff;  \n}  \n.search-bar{  \n  flex: none;  \n  display: flex;  \n  align-items: center;  \n  justify-content: space-between;  \n  padding: 20rpx;  \n  background: #f4f4f4;  \n}  \n.search-wrap{  \n  position: relative;  \n  flex: auto;  \n  display: flex;  \n  align-items: center;  \n  height: 80rpx;  \n  padding: 0 20rpx;  \n  background: #fff;  \n  border-radius: 6rpx;  \n}  \n.search-wrap .icon-search{  \n  margin-right: 10rpx;  \n}  \n.search-wrap .search-input{  \n  flex: auto;  \n  font-size: 28rpx;  \n}  \n.search-cancel{  \n  padding: 0 20rpx;  \n  font-size: 28rpx;  \n}  \n\n/*搜索结果*/  \n.search-result{  \n  flex: auto;  \n  position: relative;  \n}  \n.search-result scroll-view{  \n  position: absolute;  \n  bottom: 0;  \n  left: 0;  \n  right: 0;  \n  top: 0;  \n}  \n.result-item{  \n  position: relative;  \n  display: flex;  \n  flex-direction: column;  \n  padding: 20rpx 0 20rpx 110rpx;  \n  overflow: hidden;  \n  border-bottom: 2rpx solid #e5e5e5;  \n}  \n\n.result-item .media{  \n  position: absolute;  \n  left: 16rpx;  \n  top: 16rpx;  \n  width: 80rpx;  \n  height: 80rpx;  \n  border-radius: 999rpx;  \n}  \n.result-item .title,  \n.result-item .subtitle{  \n  overflow: hidden;  \n  text-overflow: ellipsis;  \n  white-space: nowrap;  \n  line-height: 36rpx;  \n}  \n.result-item .title{  \n  margin-bottom: 4rpx;  \n  color: #000;  \n}  \n.result-item .subtitle{  \n  color: #808080;  \n  font-size: 24rpx;  \n}  \n.result-item:first-child .subtitle text{  \n  margin-right: 20rpx;  \n}  \n.result-item:not(:first-child) .subtitle text:not(:first-child):before{  \n  content: &#39;/&#39;;  \n  margin: 0 8rpx;  \n}  \n.loading{  \n  padding: 10rpx;  \n  text-align: center;  \n}  \n.loading:before{  \n  display: inline-block;  \n  margin-right: 5rpx;  \n  vertical-align: middle;  \n  content: &#39;&#39;;  \n  width: 40rpx;  \n  height: 40rpx;  \n  background: url(../../images/icon-loading.png) no-repeat;  \n  background-size: contain;  \n  animation: rotate 1s linear infinite;  \n}  \n.loading.complete:before{  \n  display: none;  \n}\n</code></pre><p>运行：</p>\n<p><img src=\"http://img.blog.csdn.net/20170224172949375?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbWljaGFlbF9vdXlhbmc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"图片\"></p>\n<p>说明：此文章转载于<a href=\"http://blog.csdn.net/michael_ouyang/article/details/56846185\">微信小程序之加载更多（分页加载）实例 —— 微信小程序实战系列（2）</a></p>\n","updated":"2020-05-11T03:11:45.504Z","comments":true,"link":"","categories":[{"name":"小程序开发","slug":"小程序开发","permalink":"http://yoursite.com/categories/小程序开发/"}],"tags":[{"name":"loding","slug":"loding","permalink":"http://yoursite.com/tags/loding/"}]},{"title":"echarst记录","date":"2018-02-07T02:03:58.000Z","path":"2018/02/07/echarts/","text":"记录花了一天时间开发的一个时间联动的折线垂直图表 option = { timeline: { data: [ &#39;青盒子&#39;, &#39;红盒子&#39;, &#39;瞄金&#39;, &#39;雪涛&#39; ], axisType: &#39;category&#39;, show: true, autoPlay: false, playInterval: 1000 }, options: [ { title: { text: &#39;青盒子现世后的价格走势&#39;, }, grid: { top: 80, bottom: 100 }, tooltip: { trigger: &#39;axis&#39;, showContent:false, formatter: function (params) { console.log(params) var html = &#39;&#39;; for(var i=0;i&lt;params.length;i++){ html += &#39;出力: &#39; + params[i].data[0].toFixed(2) + &#39;&lt;br&gt;报价: &#39; + params[i].data[1].toFixed(2)+&#39;&lt;br&gt;&#39;; } return html } }, xAxis: { type: &#39;value&#39;, }, yAxis: { type: &#39;value&#39;, name: &#39;单位：元&#39; }, series: [{ id:&#39;a&#39;, type: &#39;line&#39;, symbolSize: 10, label: { normal: { show: false, position: &#39;top&#39;, } }, data: [[800,500], [950,500], [950,600], [1200,600]] }] }, { title: { text: &#39;青盒子现世后的价格走势&#39;, }, grid: { top: 80, bottom: 100 }, tooltip: { trigger: &#39;axis&#39;, showContent:false, formatter: function (params) { console.log(params) var html = &#39;&#39;; for(var i=0;i&lt;params.length;i++){ html += &#39;出力: &#39; + params[i].data[0].toFixed(2) + &#39;&lt;br&gt;报价: &#39; + params[i].data[1].toFixed(2)+&#39;&lt;br&gt;&#39;; } return html } }, xAxis: { type: &#39;value&#39;, }, yAxis: { type: &#39;value&#39;, name: &#39;单位：元&#39; }, series: [{ id:&#39;a&#39;, type: &#39;line&#39;, symbolSize: 10, data: [[750,900], [850,900], [850,600], [1000,600]] }] }, { title: { text: &#39;青盒子现世后的价格走势&#39;, }, grid: { top: 80, bottom: 100 }, tooltip: { trigger: &#39;axis&#39;, showContent:false, formatter: function (params) { console.log(params) var html = &#39;&#39;; for(var i=0;i&lt;params.length;i++){ html += &#39;出力: &#39; + params[i].data[0].toFixed(2) + &#39;&lt;br&gt;报价: &#39; + params[i].data[1].toFixed(2)+&#39;&lt;br&gt;&#39;; } return html } }, xAxis: { type: &#39;value&#39;, }, yAxis: { type: &#39;value&#39;, name: &#39;单位：元&#39; }, series: [{ id:&#39;a&#39;, type: &#39;line&#39;, symbolSize: 10, label: { normal: { show: true, position: &#39;top&#39;, } }, data: [[850,800], [1050,800], [1050,600], [1300,600]] }] }, { title: { text: &#39;青盒子现世后的价格走势&#39;, }, grid: { top: 80, bottom: 100 }, tooltip: { trigger: &#39;axis&#39;, showContent:false, formatter: function (params) { console.log(params) var html = &#39;&#39;; for(var i=0;i&lt;params.length;i++){ html += &#39;出力: &#39; + params[i].data[0].toFixed(2) + &#39;&lt;br&gt;报价: &#39; + params[i].data[1].toFixed(2)+&#39;&lt;br&gt;&#39;; } return html } }, xAxis: { type: &#39;value&#39;, }, yAxis: { type: &#39;value&#39;, name: &#39;单位：元&#39; }, series: [{ id:&#39;a&#39;, type: &#39;line&#39;, symbolSize: 10, label: { normal: { show: true, position: &#39;top&#39;, } }, data: [[950,1000], [1200,1000], [1200,600], [1300,600]] }] } ] };","content":"<ul>\n<li>记录花了一天时间开发的一个时间联动的折线垂直图表</li>\n</ul>\n<pre><code>option = {\n    timeline: {\n        data: [\n            &#39;青盒子&#39;, &#39;红盒子&#39;, &#39;瞄金&#39;, &#39;雪涛&#39;\n        ],\n        axisType: &#39;category&#39;,\n        show: true,\n        autoPlay: false,\n        playInterval: 1000\n    },\n\n    options: [\n    {\n        title: {\n            text: &#39;青盒子现世后的价格走势&#39;,\n        },\n        grid: {\n            top: 80,\n            bottom: 100\n        },\n        tooltip: {\n            trigger: &#39;axis&#39;,\n            showContent:false,\n            formatter: function (params) {\n                 console.log(params)\n                 var html = &#39;&#39;;\n                 for(var i=0;i&lt;params.length;i++){\n                     html += &#39;出力: &#39; + params[i].data[0].toFixed(2) + &#39;&lt;br&gt;报价: &#39; + params[i].data[1].toFixed(2)+&#39;&lt;br&gt;&#39;;\n\n                 }\n                return html\n            }\n        },\n        xAxis: {\n            type: &#39;value&#39;,\n        },\n        yAxis: {\n            type: &#39;value&#39;,\n            name: &#39;单位：元&#39;\n        },\n        series: [{\n            id:&#39;a&#39;,\n            type: &#39;line&#39;,\n            symbolSize: 10,\n\n            label: {\n                normal: {\n                    show: false,\n                    position: &#39;top&#39;,\n                }\n            },\n            data: [[800,500], [950,500], [950,600], [1200,600]]\n        }]\n    },\n    {\n        title: {\n            text: &#39;青盒子现世后的价格走势&#39;,\n        },\n        grid: {\n            top: 80,\n            bottom: 100\n        },\n        tooltip: {\n            trigger: &#39;axis&#39;,\n             showContent:false,\n            formatter: function (params) {\n                 console.log(params)\n                 var html = &#39;&#39;;\n                 for(var i=0;i&lt;params.length;i++){\n                     html += &#39;出力: &#39; + params[i].data[0].toFixed(2) + &#39;&lt;br&gt;报价: &#39; + params[i].data[1].toFixed(2)+&#39;&lt;br&gt;&#39;;\n\n                 }\n                return html\n            }\n        },\n        xAxis: {\n            type: &#39;value&#39;,\n        },\n        yAxis: {\n            type: &#39;value&#39;,\n            name: &#39;单位：元&#39;\n        },\n        series: [{\n            id:&#39;a&#39;,\n            type: &#39;line&#39;,\n            symbolSize: 10,\n\n            data: [[750,900], [850,900], [850,600], [1000,600]]\n        }]\n    },\n    {\n        title: {\n            text: &#39;青盒子现世后的价格走势&#39;,\n        },\n        grid: {\n            top: 80,\n            bottom: 100\n        },\n        tooltip: {\n            trigger: &#39;axis&#39;,\n             showContent:false,\n            formatter: function (params) {\n                 console.log(params)\n                 var html = &#39;&#39;;\n                 for(var i=0;i&lt;params.length;i++){\n                     html += &#39;出力: &#39; + params[i].data[0].toFixed(2) + &#39;&lt;br&gt;报价: &#39; + params[i].data[1].toFixed(2)+&#39;&lt;br&gt;&#39;;\n\n                 }\n                return html\n            }\n        },\n        xAxis: {\n            type: &#39;value&#39;,\n        },\n        yAxis: {\n            type: &#39;value&#39;,\n            name: &#39;单位：元&#39;\n        },\n        series: [{\n            id:&#39;a&#39;,\n            type: &#39;line&#39;,\n            symbolSize: 10,\n            label: {\n                normal: {\n                    show: true,\n                    position: &#39;top&#39;,\n                }\n            },\n            data: [[850,800], [1050,800], [1050,600], [1300,600]]\n        }]\n    },\n    {\n        title: {\n            text: &#39;青盒子现世后的价格走势&#39;,\n        },\n        grid: {\n            top: 80,\n            bottom: 100\n        },\n        tooltip: {\n            trigger: &#39;axis&#39;,\n             showContent:false,\n            formatter: function (params) {\n                 console.log(params)\n                 var html = &#39;&#39;;\n                 for(var i=0;i&lt;params.length;i++){\n                     html += &#39;出力: &#39; + params[i].data[0].toFixed(2) + &#39;&lt;br&gt;报价: &#39; + params[i].data[1].toFixed(2)+&#39;&lt;br&gt;&#39;;\n\n                 }\n                return html\n            }\n        },\n        xAxis: {\n            type: &#39;value&#39;,\n        },\n        yAxis: {\n            type: &#39;value&#39;,\n            name: &#39;单位：元&#39;\n        },\n        series: [{\n            id:&#39;a&#39;,\n            type: &#39;line&#39;,\n            symbolSize: 10,\n            label: {\n                normal: {\n                    show: true,\n                    position: &#39;top&#39;,\n                }\n            },\n            data: [[950,1000], [1200,1000], [1200,600], [1300,600]]\n        }]\n    }\n\n    ]\n\n};\n</code></pre>","updated":"2020-05-11T03:09:34.128Z","comments":true,"link":"","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://yoursite.com/categories/前端开发/"}],"tags":[{"name":"echarst","slug":"echarst","permalink":"http://yoursite.com/tags/echarst/"}]}]}